CCS PCH C Compiler, Version 5.025, 24702               19-Jul-22 10:46

               Filename:   C:\Users\Fairy11\Desktop\New folder\LAP-TRINH-ROBOT-TU-DONG-2014\tudong30-3\ltrobottd.lst

               ROM used:   6580 bytes (40%)
                           Largest free fragment is 9800
               RAM used:   102 (13%) at main() level
                           131 (17%) worst case
               Stack used: 6 locations (3 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   1852
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   0162
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   0A32
006C:  BTFSS  FF0.3
006E:  GOTO   0078
0072:  BTFSC  FF0.0
0074:  GOTO   00DE
0078:  BTFSS  FF0.4
007A:  GOTO   0084
007E:  BTFSC  FF0.1
0080:  GOTO   0120
0084:  BTFSS  FA3.0
0086:  GOTO   0090
008A:  BTFSC  FA4.0
008C:  GOTO   0B26
0090:  MOVFF  0E,00
0094:  MOVFF  0F,01
0098:  MOVFF  10,02
009C:  MOVFF  11,03
00A0:  MOVFF  0C,FE9
00A4:  MOVFF  07,FEA
00A8:  BSF    07.7
00AA:  MOVFF  08,FE1
00AE:  MOVFF  09,FE2
00B2:  MOVFF  0A,FD9
00B6:  MOVFF  0B,FDA
00BA:  MOVFF  12,FF3
00BE:  MOVFF  13,FF4
00C2:  MOVFF  14,FFA
00C6:  MOVFF  15,FF5
00CA:  MOVFF  16,FF6
00CE:  MOVFF  17,FF7
00D2:  MOVF   04,W
00D4:  MOVFF  06,FE0
00D8:  MOVFF  05,FD8
00DC:  RETFIE 0
....................  
.................... //#include <ltrobottd.h> 
.................... //#include <PIC18F4431_registers.h> 
.................... //#include <stdlib.h> 
.................... //#include <stdio.h> 
.................... #include <khoidong.c> 
.................... ///// KHOI DONG PIC 
....................  
.................... #include <18F4431.h> 
.................... //////////// Standard Header file for the PIC18F4431 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4431 
*
01E4:  MOVLW  8E
01E6:  MOVWF  00
01E8:  MOVFF  74,01
01EC:  MOVFF  73,02
01F0:  CLRF   03
01F2:  BTFSS  x74.7
01F4:  BRA    0200
01F6:  COMF   01,F
01F8:  COMF   02,F
01FA:  INCF   02,F
01FC:  BNZ   0200
01FE:  INCF   01,F
0200:  MOVF   01,F
0202:  BNZ   0216
0204:  MOVFF  02,01
0208:  CLRF   02
020A:  MOVLW  08
020C:  SUBWF  00,F
020E:  MOVF   01,F
0210:  BNZ   0216
0212:  CLRF   00
0214:  BRA    022A
0216:  BCF    FD8.0
0218:  BTFSC  01.7
021A:  BRA    0224
021C:  RLCF   02,F
021E:  RLCF   01,F
0220:  DECF   00,F
0222:  BRA    0216
0224:  BTFSC  x74.7
0226:  BRA    022A
0228:  BCF    01.7
022A:  RETURN 0
022C:  MOVF   x73,W
022E:  BTFSC  FD8.2
0230:  BRA    0314
0232:  MOVWF  00
0234:  MOVF   x77,W
0236:  BTFSC  FD8.2
0238:  BRA    0314
023A:  ADDWF  00,F
023C:  BNC   0246
023E:  MOVLW  81
0240:  ADDWF  00,F
0242:  BC    0314
0244:  BRA    024E
0246:  MOVLW  7F
0248:  SUBWF  00,F
024A:  BNC   0314
024C:  BZ    0314
024E:  MOVFF  74,7B
0252:  MOVF   x78,W
0254:  XORWF  x7B,F
0256:  BSF    x74.7
0258:  BSF    x78.7
025A:  MOVF   x76,W
025C:  MULWF  x7A
025E:  MOVFF  FF4,7D
0262:  MOVF   x75,W
0264:  MULWF  x79
0266:  MOVFF  FF4,03
026A:  MOVFF  FF3,7C
026E:  MULWF  x7A
0270:  MOVF   FF3,W
0272:  ADDWF  x7D,F
0274:  MOVF   FF4,W
0276:  ADDWFC x7C,F
0278:  MOVLW  00
027A:  ADDWFC 03,F
027C:  MOVF   x76,W
027E:  MULWF  x79
0280:  MOVF   FF3,W
0282:  ADDWF  x7D,F
0284:  MOVF   FF4,W
0286:  ADDWFC x7C,F
0288:  MOVLW  00
028A:  CLRF   02
028C:  ADDWFC 03,F
028E:  ADDWFC 02,F
0290:  MOVF   x74,W
0292:  MULWF  x7A
0294:  MOVF   FF3,W
0296:  ADDWF  x7C,F
0298:  MOVF   FF4,W
029A:  ADDWFC 03,F
029C:  MOVLW  00
029E:  ADDWFC 02,F
02A0:  MOVF   x74,W
02A2:  MULWF  x79
02A4:  MOVF   FF3,W
02A6:  ADDWF  03,F
02A8:  MOVF   FF4,W
02AA:  ADDWFC 02,F
02AC:  MOVLW  00
02AE:  CLRF   01
02B0:  ADDWFC 01,F
02B2:  MOVF   x76,W
02B4:  MULWF  x78
02B6:  MOVF   FF3,W
02B8:  ADDWF  x7C,F
02BA:  MOVF   FF4,W
02BC:  ADDWFC 03,F
02BE:  MOVLW  00
02C0:  ADDWFC 02,F
02C2:  ADDWFC 01,F
02C4:  MOVF   x75,W
02C6:  MULWF  x78
02C8:  MOVF   FF3,W
02CA:  ADDWF  03,F
02CC:  MOVF   FF4,W
02CE:  ADDWFC 02,F
02D0:  MOVLW  00
02D2:  ADDWFC 01,F
02D4:  MOVF   x74,W
02D6:  MULWF  x78
02D8:  MOVF   FF3,W
02DA:  ADDWF  02,F
02DC:  MOVF   FF4,W
02DE:  ADDWFC 01,F
02E0:  INCF   00,F
02E2:  BTFSC  01.7
02E4:  BRA    02F0
02E6:  RLCF   x7C,F
02E8:  RLCF   03,F
02EA:  RLCF   02,F
02EC:  RLCF   01,F
02EE:  DECF   00,F
02F0:  MOVLW  00
02F2:  BTFSS  x7C.7
02F4:  BRA    030A
02F6:  INCF   03,F
02F8:  ADDWFC 02,F
02FA:  ADDWFC 01,F
02FC:  MOVF   01,W
02FE:  BNZ   030A
0300:  MOVF   02,W
0302:  BNZ   030A
0304:  MOVF   03,W
0306:  BNZ   030A
0308:  INCF   00,F
030A:  BTFSC  x7B.7
030C:  BSF    01.7
030E:  BTFSS  x7B.7
0310:  BCF    01.7
0312:  BRA    031C
0314:  CLRF   00
0316:  CLRF   01
0318:  CLRF   02
031A:  CLRF   03
031C:  RETURN 0
031E:  MOVLW  80
0320:  BTFSC  FD8.1
0322:  XORWF  x78,F
0324:  CLRF   x7D
0326:  CLRF   x7E
0328:  MOVFF  74,7C
032C:  MOVF   x78,W
032E:  XORWF  x7C,F
0330:  MOVF   x73,W
0332:  BTFSC  FD8.2
0334:  BRA    04EE
0336:  MOVWF  x7B
0338:  MOVWF  00
033A:  MOVF   x77,W
033C:  BTFSC  FD8.2
033E:  BRA    0500
0340:  SUBWF  x7B,F
0342:  BTFSC  FD8.2
0344:  BRA    0448
0346:  BNC   03C2
0348:  MOVFF  78,81
034C:  BSF    x81.7
034E:  MOVFF  79,80
0352:  MOVFF  7A,7F
0356:  CLRF   x7E
0358:  BCF    FD8.0
035A:  RRCF   x81,F
035C:  RRCF   x80,F
035E:  RRCF   x7F,F
0360:  RRCF   x7E,F
0362:  DECFSZ x7B,F
0364:  BRA    0356
0366:  BTFSS  x7C.7
0368:  BRA    0370
036A:  BSF    x7D.0
036C:  BRA    0528
036E:  BCF    x7D.0
0370:  BCF    x7B.0
0372:  BSF    x7D.4
0374:  CLRF   FEA
0376:  MOVLW  76
0378:  MOVWF  FE9
037A:  BRA    054E
037C:  BCF    x7D.4
037E:  BTFSC  x7C.7
0380:  BRA    0396
0382:  BTFSS  x7B.0
0384:  BRA    03AC
0386:  RRCF   x81,F
0388:  RRCF   x80,F
038A:  RRCF   x7F,F
038C:  RRCF   x7E,F
038E:  INCF   00,F
0390:  BTFSC  FD8.2
0392:  BRA    051E
0394:  BRA    03AC
0396:  BTFSC  x81.7
0398:  BRA    03B2
039A:  BCF    FD8.0
039C:  RLCF   x7E,F
039E:  RLCF   x7F,F
03A0:  RLCF   x80,F
03A2:  RLCF   x81,F
03A4:  DECF   00,F
03A6:  BTFSC  FD8.2
03A8:  BRA    051E
03AA:  BRA    0396
03AC:  BSF    x7D.6
03AE:  BRA    0486
03B0:  BCF    x7D.6
03B2:  MOVFF  74,7C
03B6:  BTFSS  x74.7
03B8:  BRA    03BE
03BA:  BSF    x81.7
03BC:  BRA    0510
03BE:  BCF    x81.7
03C0:  BRA    0510
03C2:  MOVFF  77,7B
03C6:  MOVFF  77,00
03CA:  MOVF   x73,W
03CC:  SUBWF  x7B,F
03CE:  MOVFF  74,81
03D2:  BSF    x81.7
03D4:  MOVFF  75,80
03D8:  MOVFF  76,7F
03DC:  CLRF   x7E
03DE:  BCF    FD8.0
03E0:  RRCF   x81,F
03E2:  RRCF   x80,F
03E4:  RRCF   x7F,F
03E6:  RRCF   x7E,F
03E8:  DECFSZ x7B,F
03EA:  BRA    03DC
03EC:  BTFSS  x7C.7
03EE:  BRA    03F6
03F0:  BSF    x7D.1
03F2:  BRA    0528
03F4:  BCF    x7D.1
03F6:  BCF    x7B.0
03F8:  BSF    x7D.5
03FA:  CLRF   FEA
03FC:  MOVLW  7A
03FE:  MOVWF  FE9
0400:  BRA    054E
0402:  BCF    x7D.5
0404:  BTFSC  x7C.7
0406:  BRA    041C
0408:  BTFSS  x7B.0
040A:  BRA    0432
040C:  RRCF   x81,F
040E:  RRCF   x80,F
0410:  RRCF   x7F,F
0412:  RRCF   x7E,F
0414:  INCF   00,F
0416:  BTFSC  FD8.2
0418:  BRA    051E
041A:  BRA    0432
041C:  BTFSC  x81.7
041E:  BRA    0438
0420:  BCF    FD8.0
0422:  RLCF   x7E,F
0424:  RLCF   x7F,F
0426:  RLCF   x80,F
0428:  RLCF   x81,F
042A:  DECF   00,F
042C:  BTFSC  FD8.2
042E:  BRA    051E
0430:  BRA    041C
0432:  BSF    x7D.7
0434:  BRA    0486
0436:  BCF    x7D.7
0438:  MOVFF  78,7C
043C:  BTFSS  x78.7
043E:  BRA    0444
0440:  BSF    x81.7
0442:  BRA    0510
0444:  BCF    x81.7
0446:  BRA    0510
0448:  MOVFF  78,81
044C:  BSF    x81.7
044E:  MOVFF  79,80
0452:  MOVFF  7A,7F
0456:  BTFSS  x7C.7
0458:  BRA    0462
045A:  BCF    x81.7
045C:  BSF    x7D.2
045E:  BRA    0528
0460:  BCF    x7D.2
0462:  CLRF   x7E
0464:  BCF    x7B.0
0466:  CLRF   FEA
0468:  MOVLW  76
046A:  MOVWF  FE9
046C:  BRA    054E
046E:  BTFSC  x7C.7
0470:  BRA    04AA
0472:  MOVFF  74,7C
0476:  BTFSS  x7B.0
0478:  BRA    0486
047A:  RRCF   x81,F
047C:  RRCF   x80,F
047E:  RRCF   x7F,F
0480:  RRCF   x7E,F
0482:  INCF   00,F
0484:  BZ    051E
0486:  BTFSS  x7E.7
0488:  BRA    04A0
048A:  INCF   x7F,F
048C:  BNZ   04A0
048E:  INCF   x80,F
0490:  BNZ   04A0
0492:  INCF   x81,F
0494:  BNZ   04A0
0496:  RRCF   x81,F
0498:  RRCF   x80,F
049A:  RRCF   x7F,F
049C:  INCF   00,F
049E:  BZ    051E
04A0:  BTFSC  x7D.6
04A2:  BRA    03B0
04A4:  BTFSC  x7D.7
04A6:  BRA    0436
04A8:  BRA    04E2
04AA:  MOVLW  80
04AC:  XORWF  x81,F
04AE:  BTFSS  x81.7
04B0:  BRA    04BA
04B2:  BRA    0528
04B4:  MOVFF  78,7C
04B8:  BRA    04CE
04BA:  MOVFF  74,7C
04BE:  MOVF   x81,F
04C0:  BNZ   04CE
04C2:  MOVF   x80,F
04C4:  BNZ   04CE
04C6:  MOVF   x7F,F
04C8:  BNZ   04CE
04CA:  CLRF   00
04CC:  BRA    0510
04CE:  BTFSC  x81.7
04D0:  BRA    04E2
04D2:  BCF    FD8.0
04D4:  RLCF   x7E,F
04D6:  RLCF   x7F,F
04D8:  RLCF   x80,F
04DA:  RLCF   x81,F
04DC:  DECFSZ 00,F
04DE:  BRA    04CE
04E0:  BRA    051E
04E2:  BTFSS  x7C.7
04E4:  BRA    04EA
04E6:  BSF    x81.7
04E8:  BRA    0510
04EA:  BCF    x81.7
04EC:  BRA    0510
04EE:  MOVFF  77,00
04F2:  MOVFF  78,81
04F6:  MOVFF  79,80
04FA:  MOVFF  7A,7F
04FE:  BRA    0510
0500:  MOVFF  73,00
0504:  MOVFF  74,81
0508:  MOVFF  75,80
050C:  MOVFF  76,7F
0510:  MOVFF  81,01
0514:  MOVFF  80,02
0518:  MOVFF  7F,03
051C:  BRA    0586
051E:  CLRF   00
0520:  CLRF   01
0522:  CLRF   02
0524:  CLRF   03
0526:  BRA    0586
0528:  CLRF   x7E
052A:  COMF   x7F,F
052C:  COMF   x80,F
052E:  COMF   x81,F
0530:  COMF   x7E,F
0532:  INCF   x7E,F
0534:  BNZ   0540
0536:  INCF   x7F,F
0538:  BNZ   0540
053A:  INCF   x80,F
053C:  BNZ   0540
053E:  INCF   x81,F
0540:  BTFSC  x7D.0
0542:  BRA    036E
0544:  BTFSC  x7D.1
0546:  BRA    03F4
0548:  BTFSC  x7D.2
054A:  BRA    0460
054C:  BRA    04B4
054E:  MOVF   FEF,W
0550:  ADDWF  x7F,F
0552:  BNC   055E
0554:  INCF   x80,F
0556:  BNZ   055E
0558:  INCF   x81,F
055A:  BTFSC  FD8.2
055C:  BSF    x7B.0
055E:  MOVF   FED,F
0560:  MOVF   FEF,W
0562:  ADDWF  x80,F
0564:  BNC   056C
0566:  INCF   x81,F
0568:  BTFSC  FD8.2
056A:  BSF    x7B.0
056C:  MOVF   FED,F
056E:  MOVF   FEF,W
0570:  BTFSC  FEF.7
0572:  BRA    0576
0574:  XORLW  80
0576:  ADDWF  x81,F
0578:  BTFSC  FD8.0
057A:  BSF    x7B.0
057C:  BTFSC  x7D.4
057E:  BRA    037C
0580:  BTFSC  x7D.5
0582:  BRA    0402
0584:  BRA    046E
0586:  RETURN 0
0588:  MOVLW  8E
058A:  MOVWF  00
058C:  MOVF   x6F,W
058E:  SUBWF  00,F
0590:  MOVFF  70,02
0594:  MOVFF  71,01
0598:  BSF    02.7
059A:  MOVF   00,F
059C:  BZ    05B0
059E:  BCF    FD8.0
05A0:  MOVF   02,F
05A2:  BNZ   05A8
05A4:  MOVF   01,F
05A6:  BZ    05B0
05A8:  RRCF   02,F
05AA:  RRCF   01,F
05AC:  DECFSZ 00,F
05AE:  BRA    059E
05B0:  BTFSS  x70.7
05B2:  BRA    05BE
05B4:  COMF   01,F
05B6:  COMF   02,F
05B8:  INCF   01,F
05BA:  BTFSC  FD8.2
05BC:  INCF   02,F
05BE:  RETURN 0
*
0AB8:  ADDWF  FE8,W
0ABA:  CLRF   FF7
0ABC:  RLCF   FF7,F
0ABE:  ADDLW  D3
0AC0:  MOVWF  FF6
0AC2:  MOVLW  0A
0AC4:  ADDWFC FF7,F
0AC6:  TBLRD*-
0AC8:  MOVF   FF5,W
0ACA:  MOVWF  FFA
0ACC:  TBLRD*
0ACE:  MOVF   FF5,W
0AD0:  MOVWF  FF9
0AD2:  DATA 4A,0A
0AD4:  DATA 56,0A
0AD6:  DATA 6E,0A
0AD8:  DATA 86,0A
....................  
.................... #list 
....................  
.................... #include <PIC18F4431_registers.h> 
.................... #byte TOSU = 0xFFF 
.................... #word TOS = 0xFFE 
.................... #byte STKPTR = 0xFFC 
.................... #bit    STKOVF = STKPTR.7 
.................... #byte STKPTR = 0xFFC 
.................... #bit    STKPTR0 = STKPTR.0 
.................... #bit    STKPTR1 = STKPTR.1 
.................... #bit    STKPTR2 = STKPTR.2 
.................... #bit    STKPTR3 = STKPTR.3 
.................... #bit    STKPTR4 = STKPTR.4 
.................... #bit    STKUNF = STKPTR.6 
.................... #bit    STKFUL = STKPTR.7 
.................... #byte PCLATU = 0xFFB 
.................... #byte PCLATH = 0xFFA 
.................... #byte PCL = 0xFF9 
.................... #byte TBLPTRU = 0xFF8 
.................... #bit    TBLPTRU0 = TBLPTRU.0 
.................... #bit    TBLPTRU1 = TBLPTRU.1 
.................... #bit    TBLPTRU2 = TBLPTRU.2 
.................... #bit    TBLPTRU3 = TBLPTRU.3 
.................... #bit    TBLPTRU4 = TBLPTRU.4 
.................... #bit    ACSS = TBLPTRU.5 
.................... #word TBLPTR = 0xFF7 
.................... #byte TABLAT = 0xFF5 
.................... #word PROD = 0xFF4 
.................... #byte INTCON = 0xFF2 
.................... #bit    RBIF = INTCON.0 
.................... #bit    INT0IF = INTCON.1 
.................... #bit    TMR0IF = INTCON.2 
.................... #bit    RBIE = INTCON.3 
.................... #bit    INT0IE = INTCON.4 
.................... #bit    TMR0IE = INTCON.5 
.................... #bit    PEIE_GIEL = INTCON.6 
.................... #bit    GIE_GIEH = INTCON.7 
.................... #byte INTCON = 0xFF2 
.................... #bit    PEIE = INTCON.6 
.................... #bit    GIE = INTCON.7 
.................... #byte INTCON = 0xFF2 
.................... #bit    INT0F = INTCON.1 
.................... #bit    T0IF = INTCON.2 
.................... #bit    INT0E = INTCON.4 
.................... #bit    T0IE = INTCON.5 
.................... #bit    GIEL = INTCON.6 
.................... #bit    GIEH = INTCON.7 
.................... #byte INTCON2 = 0xFF1 
.................... #bit    T0IP = INTCON2.2 
.................... #byte INTCON2 = 0xFF1 
.................... #bit    RBIP = INTCON2.0 
.................... #bit    TMR0IP = INTCON2.2 
.................... #bit    INTEDG2 = INTCON2.4 
.................... #bit    INTEDG1 = INTCON2.5 
.................... #bit    INTEDG0 = INTCON2.6 
.................... #bit    RBPU = INTCON2.7 
.................... #byte INTCON3 = 0xFF0 
.................... #bit    INT1F = INTCON3.0 
.................... #bit    INT2F = INTCON3.1 
.................... #bit    INT1E = INTCON3.3 
.................... #bit    INT2E = INTCON3.4 
.................... #bit    INT1P = INTCON3.6 
.................... #bit    INT2P = INTCON3.7 
.................... #byte INTCON3 = 0xFF0 
.................... #bit    INT1IF = INTCON3.0 
.................... #bit    INT2IF = INTCON3.1 
.................... #bit    INT1IE = INTCON3.3 
.................... #bit    INT2IE = INTCON3.4 
.................... #bit    INT1IP = INTCON3.6 
.................... #bit    INT2IP = INTCON3.7 
.................... #byte INDF0 = 0xFEF 
.................... #byte POSTINC0 = 0xFEE 
.................... #byte POSTDEC0 = 0xFED 
.................... #byte PREINC0 = 0xFEC 
.................... #byte PLUSW0 = 0xFEB 
.................... #word FSR0 = 0xFEA 
.................... #byte WREG = 0xFE8 
.................... #byte INDF1 = 0xFE7 
.................... #byte POSTINC1 = 0xFE6 
.................... #byte POSTDEC1 = 0xFE5 
.................... #byte PREINC1 = 0xFE4 
.................... #byte PLUSW1 = 0xFE3 
.................... #word FSR1 = 0xFE2 
.................... #byte BSR = 0xFE0 
.................... #byte INDF2 = 0xFDF 
.................... #byte POSTINC2 = 0xFDE 
.................... #byte POSTDEC2 = 0xFDD 
.................... #byte PREINC2 = 0xFDC 
.................... #byte PLUSW2 = 0xFDB 
.................... #word FSR2 = 0xFDA 
.................... #byte STATUS = 0xFD8 
.................... #bit    C = STATUS.0 
.................... #bit    DC = STATUS.1 
.................... #bit    Z = STATUS.2 
.................... #bit    OV = STATUS.3 
.................... #bit    N = STATUS.4 
.................... #word TMR0 = 0xFD7 
.................... #byte T0CON = 0xFD5 
.................... #bit    T0PS0 = T0CON.0 
.................... #bit    T0PS1 = T0CON.1 
.................... #bit    T0PS2 = T0CON.2 
.................... #bit    PSA = T0CON.3 
.................... #bit    T0SE = T0CON.4 
.................... #bit    T0CS = T0CON.5 
.................... #bit    T016BIT = T0CON.6 
.................... #bit    TMR0ON = T0CON.7 
.................... #byte OSCCON = 0xFD3 
.................... #bit    FLTS = OSCCON.2 
.................... #byte OSCCON = 0xFD3 
.................... #bit    SCS0 = OSCCON.0 
.................... #bit    SCS1 = OSCCON.1 
.................... #bit    IOFS = OSCCON.2 
.................... #bit    OSTS = OSCCON.3 
.................... #bit    IRCF0 = OSCCON.4 
.................... #bit    IRCF1 = OSCCON.5 
.................... #bit    IRCF2 = OSCCON.6 
.................... #bit    IDLEN = OSCCON.7 
.................... #byte LVDCON = 0xFD2 
.................... #bit    IVRST = LVDCON.5 
.................... #byte LVDCON = 0xFD2 
.................... #bit    LVDL0 = LVDCON.0 
.................... #bit    LVDL1 = LVDCON.1 
.................... #bit    LVDL2 = LVDCON.2 
.................... #bit    LVDL3 = LVDCON.3 
.................... #bit    LVDEN = LVDCON.4 
.................... #bit    IRVST = LVDCON.5 
.................... #byte WDTCON = 0xFD1 
.................... #bit    SWDTEN = WDTCON.0 
.................... #bit    WDTW = WDTCON.7 
.................... #byte RCON = 0xFD0 
.................... #bit    BOR = RCON.0 
.................... #bit    POR = RCON.1 
.................... #bit    PD = RCON.2 
.................... #bit    TO = RCON.3 
.................... #bit    RI = RCON.4 
.................... #bit    IPEN = RCON.7 
.................... #word TMR1 = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... #bit    T1INSYNC = T1CON.2 
.................... #byte T1CON = 0xFCD 
.................... #bit    TMR1ON = T1CON.0 
.................... #bit    TMR1CS = T1CON.1 
.................... #bit    T1SYNC = T1CON.2 
.................... #bit    T1OSCEN = T1CON.3 
.................... #bit    T1CKPS0 = T1CON.4 
.................... #bit    T1CKPS1 = T1CON.5 
.................... #bit    T1RUN = T1CON.6 
.................... #bit    RD16 = T1CON.7 
.................... #byte TMR2 = 0xFCC 
.................... #byte PR2 = 0xFCB 
.................... #byte T2CON = 0xFCA 
.................... #bit    T2OUTPS0 = T2CON.3 
.................... #bit    T2OUTPS1 = T2CON.4 
.................... #bit    T2OUTPS2 = T2CON.5 
.................... #bit    T2OUTPS3 = T2CON.6 
.................... #byte T2CON = 0xFCA 
.................... #bit    T2CKPS0 = T2CON.0 
.................... #bit    T2CKPS1 = T2CON.1 
.................... #bit    TMR2ON = T2CON.2 
.................... #bit    TOUTPS0 = T2CON.3 
.................... #bit    TOUTPS1 = T2CON.4 
.................... #bit    TOUTPS2 = T2CON.5 
.................... #bit    TOUTPS3 = T2CON.6 
.................... #byte SSPBUF = 0xFC9 
.................... #byte SSPADD = 0xFC8 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    READ_WRITE = SSPSTAT.2 
.................... #bit    DATA_ADDRESS = SSPSTAT.5 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    WRITE = SSPSTAT.2 
.................... #bit    ADDRESS = SSPSTAT.5 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    BF = SSPSTAT.0 
.................... #bit    UA = SSPSTAT.1 
.................... #bit    R = SSPSTAT.2 
.................... #bit    S = SSPSTAT.3 
.................... #bit    P = SSPSTAT.4 
.................... #bit    D = SSPSTAT.5 
.................... #bit    CKE = SSPSTAT.6 
.................... #bit    SMP = SSPSTAT.7 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    R_W = SSPSTAT.2 
.................... #bit    D_A = SSPSTAT.5 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    W = SSPSTAT.2 
.................... #bit    A = SSPSTAT.5 
.................... #byte SSPCON = 0xFC6 
.................... #bit    SSPM0 = SSPCON.0 
.................... #bit    SSPM1 = SSPCON.1 
.................... #bit    SSPM2 = SSPCON.2 
.................... #bit    SSPM3 = SSPCON.3 
.................... #bit    CKP = SSPCON.4 
.................... #bit    SSPEN = SSPCON.5 
.................... #bit    SSPOV = SSPCON.6 
.................... #bit    WCOL = SSPCON.7 
.................... #word ADRES = 0xFC4 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    GO_DONE = ADCON0.1 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    ADON = ADCON0.0 
.................... #bit    GO = ADCON0.1 
.................... #bit    ACMOD0 = ADCON0.2 
.................... #bit    ACMOD1 = ADCON0.3 
.................... #bit    ACSCH = ADCON0.4 
.................... #bit    ACONV = ADCON0.5 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    GODONE = ADCON0.1 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    DONE = ADCON0.1 
.................... #byte ADCON1 = 0xFC1 
.................... #bit    FFOVFL = ADCON1.2 
.................... #byte ADCON1 = 0xFC1 
.................... #bit    ADPNT0 = ADCON1.0 
.................... #bit    ADPNT1 = ADCON1.1 
.................... #bit    BFOVFL = ADCON1.2 
.................... #bit    BFEMT = ADCON1.3 
.................... #bit    FIFOEN = ADCON1.4 
.................... #bit    VCFG0 = ADCON1.6 
.................... #bit    VCFG1 = ADCON1.7 
.................... #byte ADCON2 = 0xFC0 
.................... #bit    ADCS0 = ADCON2.0 
.................... #bit    ADCS1 = ADCON2.1 
.................... #bit    ADCS2 = ADCON2.2 
.................... #bit    ACQT0 = ADCON2.3 
.................... #bit    ACQT1 = ADCON2.4 
.................... #bit    ACQT2 = ADCON2.5 
.................... #bit    ACQT3 = ADCON2.6 
.................... #bit    ADFM = ADCON2.7 
.................... #word CCPR1 = 0xFBF 
.................... #byte CCP1CON = 0xFBD 
.................... #bit    CCP1Y = CCP1CON.4 
.................... #bit    CCP1X = CCP1CON.5 
.................... #byte CCP1CON = 0xFBD 
.................... #bit    CCP1M0 = CCP1CON.0 
.................... #bit    CCP1M1 = CCP1CON.1 
.................... #bit    CCP1M2 = CCP1CON.2 
.................... #bit    CCP1M3 = CCP1CON.3 
.................... #bit    DC1B0 = CCP1CON.4 
.................... #bit    DC1B1 = CCP1CON.5 
.................... #word CCPR2 = 0xFBC 
.................... #byte CCP2CON = 0xFBA 
.................... #bit    CCP2Y = CCP2CON.4 
.................... #bit    CCP2X = CCP2CON.5 
.................... #byte CCP2CON = 0xFBA 
.................... #bit    CCP2M0 = CCP2CON.0 
.................... #bit    CCP2M1 = CCP2CON.1 
.................... #bit    CCP2M2 = CCP2CON.2 
.................... #bit    CCP2M3 = CCP2CON.3 
.................... #bit    DC2B0 = CCP2CON.4 
.................... #bit    DC2B1 = CCP2CON.5 
.................... #byte ANSEL1 = 0xFB9 
.................... #bit    ANS8 = ANSEL1.0 
.................... #byte ANSEL0 = 0xFB8 
.................... #byte T5CON = 0xFB7 
.................... #bit    TMR5ON = T5CON.0 
.................... #bit    TMR5CS = T5CON.1 
.................... #bit    T5SYNC = T5CON.2 
.................... #bit    T5PS0 = T5CON.3 
.................... #bit    T5PS1 = T5CON.4 
.................... #bit    T5MOD = T5CON.5 
.................... #bit    RESEN = T5CON.6 
.................... #bit    T5SEN = T5CON.7 
.................... #byte QEICON = 0xFB6 
.................... #bit    UP_DOWN = QEICON.5 
.................... #byte QEICON = 0xFB6 
.................... #bit    PDEC0 = QEICON.0 
.................... #bit    PDEC1 = QEICON.1 
.................... #bit    QEIM0 = QEICON.2 
.................... #bit    QEIM1 = QEICON.3 
.................... #bit    QEIM2 = QEICON.4 
.................... #bit    UP = QEICON.5 
.................... #bit    QERR = QEICON.6 
.................... #bit    VELM = QEICON.7 
.................... #byte QEICON = 0xFB6 
.................... #bit    UPDOWN = QEICON.5 
.................... #byte QEICON = 0xFB6 
.................... #bit    DOWN = QEICON.5 
.................... #byte SPBRGH = 0xFB0 
.................... #byte SPBRG = 0xFAF 
.................... #byte RCREG = 0xFAE 
.................... #byte TXREG = 0xFAD 
.................... #byte TXSTA = 0xFAC 
.................... #bit    TX9D = TXSTA.0 
.................... #bit    TRMT = TXSTA.1 
.................... #bit    BRGH = TXSTA.2 
.................... #bit    SENDB = TXSTA.3 
.................... #bit    SYNC = TXSTA.4 
.................... #bit    TXEN = TXSTA.5 
.................... #bit    TX9 = TXSTA.6 
.................... #bit    CSRC = TXSTA.7 
.................... #byte RCSTA = 0xFAB 
.................... #bit    ADEN = RCSTA.3 
.................... #byte RCSTA = 0xFAB 
.................... #bit    RX9D = RCSTA.0 
.................... #bit    OERR = RCSTA.1 
.................... #bit    FERR = RCSTA.2 
.................... #bit    ADDEN = RCSTA.3 
.................... #bit    CREN = RCSTA.4 
.................... #bit    SREN = RCSTA.5 
.................... #bit    RX9 = RCSTA.6 
.................... #bit    SPEN = RCSTA.7 
.................... #byte BAUDCON = 0xFAA 
.................... #bit    SCKP = BAUDCON.4 
.................... #bit    RCMT = BAUDCON.6 
.................... #byte BAUDCON = 0xFAA 
.................... #bit    ABDEN = BAUDCON.0 
.................... #bit    WUE = BAUDCON.1 
.................... #bit    BRG16 = BAUDCON.3 
.................... #bit    TXCKP = BAUDCON.4 
.................... #bit    RXDTP = BAUDCON.5 
.................... #bit    RCIDL = BAUDCON.6 
.................... #bit    ABDOVF = BAUDCON.7 
.................... #byte EEADR = 0xFA9 
.................... #byte EEDATA = 0xFA8 
.................... #byte EECON2 = 0xFA7 
.................... #byte EECON1 = 0xFA6 
.................... #bit    RD = EECON1.0 
.................... #bit    WR = EECON1.1 
.................... #bit    WREN = EECON1.2 
.................... #bit    WRERR = EECON1.3 
.................... #bit    FREE = EECON1.4 
.................... #bit    CFGS = EECON1.6 
.................... #bit    EEPGD = EECON1.7 
.................... #byte IPR3 = 0xFA5 
.................... #bit    TMR5IP = IPR3.0 
.................... #bit    IC1IP = IPR3.1 
.................... #bit    IC2QEIP = IPR3.2 
.................... #bit    IC3DRIP = IPR3.3 
.................... #bit    PTIP = IPR3.4 
.................... #byte PIR3 = 0xFA4 
.................... #bit    TMR5IF = PIR3.0 
.................... #bit    IC1IF = PIR3.1 
.................... #bit    IC2QEIF = PIR3.2 
.................... #bit    IC3DRIF = PIR3.3 
.................... #bit    PTIF = PIR3.4 
.................... #byte PIE3 = 0xFA3 
.................... #bit    TMR5IE = PIE3.0 
.................... #bit    IC1IE = PIE3.1 
.................... #bit    IC2QEIE = PIE3.2 
.................... #bit    IC3DRIE = PIE3.3 
.................... #bit    PTIE = PIE3.4 
.................... #byte IPR2 = 0xFA2 
.................... #bit    CCP2IP = IPR2.0 
.................... #bit    LVDIP = IPR2.2 
.................... #bit    EEIP = IPR2.4 
.................... #bit    OSFIP = IPR2.7 
.................... #byte PIR2 = 0xFA1 
.................... #bit    CCP2IF = PIR2.0 
.................... #bit    LVDIF = PIR2.2 
.................... #bit    EEIF = PIR2.4 
.................... #bit    OSFIF = PIR2.7 
.................... #byte PIE2 = 0xFA0 
.................... #bit    CCP2IE = PIE2.0 
.................... #bit    LVDIE = PIE2.2 
.................... #bit    EEIE = PIE2.4 
.................... #bit    OSFIE = PIE2.7 
.................... #byte IPR1 = 0xF9F 
.................... #bit    TBIP = IPR1.4 
.................... #byte IPR1 = 0xF9F 
.................... #bit    TMR1IP = IPR1.0 
.................... #bit    TMR2IP = IPR1.1 
.................... #bit    CCP1IP = IPR1.2 
.................... #bit    SSPIP = IPR1.3 
.................... #bit    TXIP = IPR1.4 
.................... #bit    RCIP = IPR1.5 
.................... #bit    ADIP = IPR1.6 
.................... #byte PIR1 = 0xF9E 
.................... #bit    TBIF = PIR1.4 
.................... #byte PIR1 = 0xF9E 
.................... #bit    TMR1IF = PIR1.0 
.................... #bit    TMR2IF = PIR1.1 
.................... #bit    CCP1IF = PIR1.2 
.................... #bit    SSPIF = PIR1.3 
.................... #bit    TXIF = PIR1.4 
.................... #bit    RCIF = PIR1.5 
.................... #bit    ADIF = PIR1.6 
.................... #byte PIE1 = 0xF9D 
.................... #bit    TBIE = PIE1.4 
.................... #byte PIE1 = 0xF9D 
.................... #bit    TMR1IE = PIE1.0 
.................... #bit    TMR2IE = PIE1.1 
.................... #bit    CCP1IE = PIE1.2 
.................... #bit    SSPIE = PIE1.3 
.................... #bit    TXIE = PIE1.4 
.................... #bit    RCIE = PIE1.5 
.................... #bit    ADIE = PIE1.6 
.................... #byte OSCTUNE = 0xF9B 
.................... #byte ADCON3 = 0xF9A 
.................... #bit    SSRC0 = ADCON3.0 
.................... #bit    SSRC1 = ADCON3.1 
.................... #bit    SSRC2 = ADCON3.2 
.................... #bit    SSRC3 = ADCON3.3 
.................... #bit    SSRC4 = ADCON3.4 
.................... #bit    ADRS0 = ADCON3.6 
.................... #bit    ADRS1 = ADCON3.7 
.................... #byte ADCHS = 0xF99 
.................... #bit    GASEL0 = ADCHS.0 
.................... #bit    GASEL1 = ADCHS.1 
.................... #bit    GCSEL0 = ADCHS.2 
.................... #bit    GCSEL1 = ADCHS.3 
.................... #bit    GBSEL0 = ADCHS.4 
.................... #bit    GBSEL1 = ADCHS.5 
.................... #bit    GDSEL0 = ADCHS.6 
.................... #bit    GDSEL1 = ADCHS.7 
.................... #byte ADCHS = 0xF99 
.................... #bit    SASEL0 = ADCHS.0 
.................... #bit    SASEL1 = ADCHS.1 
.................... #bit    SCSEL0 = ADCHS.2 
.................... #bit    SCSEL1 = ADCHS.3 
.................... #bit    SBSEL0 = ADCHS.4 
.................... #bit    SBSEL1 = ADCHS.5 
.................... #bit    SDSEL0 = ADCHS.6 
.................... #bit    SDSEL1 = ADCHS.7 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
.................... #byte TRISA = 0xF92 
.................... #word PR5 = 0xF91 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
.................... #byte LATA = 0xF89 
.................... #word TMR5 = 0xF88 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #byte PTCON0 = 0xF7F 
.................... #bit    PTMOD0 = PTCON0.0 
.................... #bit    PTMOD1 = PTCON0.1 
.................... #bit    PTCKPS0 = PTCON0.2 
.................... #bit    PTCKPS1 = PTCON0.3 
.................... #bit    PTOPS0 = PTCON0.4 
.................... #bit    PTOPS1 = PTCON0.5 
.................... #bit    PTOPS2 = PTCON0.6 
.................... #bit    PTOPS3 = PTCON0.7 
.................... #byte PTCON1 = 0xF7E 
.................... #bit    PTDIR = PTCON1.6 
.................... #bit    PTEN = PTCON1.7 
.................... #byte PTMRL = 0xF7D 
.................... #byte PTMRH = 0xF7C 
.................... #byte PTPERL = 0xF7B 
.................... #byte PTPERH = 0xF7A 
.................... #byte PDC0L = 0xF79 
.................... #byte PDC0H = 0xF78 
.................... #byte PDC1L = 0xF77 
.................... #byte PDC1H = 0xF76 
.................... #byte PDC2L = 0xF75 
.................... #byte PDC2H = 0xF74 
.................... #byte PDC3L = 0xF73 
.................... #byte PDC3H = 0xF72 
.................... #byte SEVTCMPL = 0xF71 
.................... #byte SEVTCMPH = 0xF70 
.................... #byte PWMCON0 = 0xF6F 
.................... #bit    PMOD0 = PWMCON0.0 
.................... #bit    PMOD1 = PWMCON0.1 
.................... #bit    PMOD2 = PWMCON0.2 
.................... #bit    PMOD3 = PWMCON0.3 
.................... #bit    PWMEN0 = PWMCON0.4 
.................... #bit    PWMEN1 = PWMCON0.5 
.................... #bit    PWMEN2 = PWMCON0.6 
.................... #byte PWMCON1 = 0xF6E 
.................... #bit    OSYNC = PWMCON1.0 
.................... #bit    UDIS = PWMCON1.1 
.................... #bit    SEVTDIR = PWMCON1.3 
.................... #bit    SEVOPS0 = PWMCON1.4 
.................... #bit    SEVOPS1 = PWMCON1.5 
.................... #bit    SEVOPS2 = PWMCON1.6 
.................... #bit    SEVOPS3 = PWMCON1.7 
.................... #byte DTCON = 0xF6D 
.................... #bit    DT0 = DTCON.0 
.................... #bit    DT1 = DTCON.1 
.................... #bit    DT2 = DTCON.2 
.................... #bit    DT3 = DTCON.3 
.................... #bit    DT4 = DTCON.4 
.................... #bit    DT5 = DTCON.5 
.................... #bit    DTPS0 = DTCON.6 
.................... #bit    DTPS1 = DTCON.7 
.................... #byte DTCON = 0xF6D 
.................... #bit    DTA0 = DTCON.0 
.................... #bit    DTA1 = DTCON.1 
.................... #bit    DTA2 = DTCON.2 
.................... #bit    DTA3 = DTCON.3 
.................... #bit    DTA4 = DTCON.4 
.................... #bit    DTA5 = DTCON.5 
.................... #bit    DTAPS0 = DTCON.6 
.................... #bit    DTAPS1 = DTCON.7 
.................... #byte FLTCONFIG = 0xF6C 
.................... #bit    FLTAEN = FLTCONFIG.0 
.................... #bit    FLTAMOD = FLTCONFIG.1 
.................... #bit    FLTAS = FLTCONFIG.2 
.................... #bit    FLTCON = FLTCONFIG.3 
.................... #bit    FLTBEN = FLTCONFIG.4 
.................... #bit    FLTBMOD = FLTCONFIG.5 
.................... #bit    FLTBS = FLTCONFIG.6 
.................... #bit    BRFEN = FLTCONFIG.7 
.................... #byte OVDCOND = 0xF6B 
.................... #byte OVDCONS = 0xF6A 
.................... #word CAP1BUF = 0xF69 
.................... #word CAP2BUF = 0xF67 
.................... #word CAP3BUF = 0xF65 
.................... #byte CAP1CON = 0xF63 
.................... #bit    CAP1M0 = CAP1CON.0 
.................... #bit    CAP1M1 = CAP1CON.1 
.................... #bit    CAP1M2 = CAP1CON.2 
.................... #bit    CAP1M3 = CAP1CON.3 
.................... #bit    CAP1TMR = CAP1CON.5 
.................... #bit    CAP1REN = CAP1CON.6 
.................... #byte CAP2CON = 0xF62 
.................... #bit    CAP2M0 = CAP2CON.0 
.................... #bit    CAP2M1 = CAP2CON.1 
.................... #bit    CAP2M2 = CAP2CON.2 
.................... #bit    CAP2M3 = CAP2CON.3 
.................... #bit    CAP2TMR = CAP2CON.5 
.................... #bit    CAP2REN = CAP2CON.6 
.................... #byte CAP3CON = 0xF61 
.................... #bit    CAP3M0 = CAP3CON.0 
.................... #bit    CAP3M1 = CAP3CON.1 
.................... #bit    CAP3M2 = CAP3CON.2 
.................... #bit    CAP3M3 = CAP3CON.3 
.................... #bit    CAP3TMR = CAP3CON.5 
.................... #bit    CAP3REN = CAP3CON.6 
.................... #byte DFLTCON = 0xF60 
.................... #bit    FLTCK0 = DFLTCON.0 
.................... #bit    FLTCK1 = DFLTCON.1 
.................... #bit    FLTCK2 = DFLTCON.2 
.................... #bit    FLT1EN = DFLTCON.3 
.................... #bit    FLT2EN = DFLTCON.4 
.................... #bit    FLT3EN = DFLTCON.5 
.................... #bit    FLT4EN = DFLTCON.6 
....................  
.................... //#device ADC=16 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... //#FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... //#FUSES H4 
.................... #use delay(clock=40000000,crystal=10000000) 
0ADA:  CLRF   FEA
0ADC:  MOVLW  6F
0ADE:  MOVWF  FE9
0AE0:  MOVF   FEF,W
0AE2:  BZ    0B00
0AE4:  MOVLW  0C
0AE6:  MOVWF  01
0AE8:  CLRF   00
0AEA:  DECFSZ 00,F
0AEC:  BRA    0AEA
0AEE:  DECFSZ 01,F
0AF0:  BRA    0AE8
0AF2:  MOVLW  F7
0AF4:  MOVWF  00
0AF6:  DECFSZ 00,F
0AF8:  BRA    0AF6
0AFA:  BRA    0AFC
0AFC:  DECFSZ FEF,F
0AFE:  BRA    0AE4
0B00:  RETURN 0
.................... //#use spi(MASTER ,FORCE_HW, BITS=16) 
.................... //#bit ss1 = PORTD.0 
.................... #use fast_io(a) 
.................... #use fast_io(d) 
.................... #use fast_io(c) 
.................... #use fast_io(e) 
....................  
.................... void khoidong() 
.................... { 
....................    trisa=0b00011000; /// DAU VAO QEI CUNG 
*
0B80:  MOVLW  18
0B82:  MOVWF  F92
....................    porta=0b11100111; 
0B84:  MOVLW  E7
0B86:  MOVWF  F80
....................    trisb=0b11111111; /// DAU VAO CONG TAC HANH TRINH 
0B88:  SETF   F93
....................    port_b_pullups(0xff); 
0B8A:  BCF    FF1.7
....................    portb=0xff; 
0B8C:  SETF   F81
....................    trisc=0b00110000; /// DAU VAO QEI MEM 
0B8E:  MOVLW  30
0B90:  MOVWF  F94
....................    portc=0b00000000; 
0B92:  CLRF   F82
....................    trisd=0b00000000; /// DAU VAO SPI 0b00000100 
0B94:  CLRF   F95
....................    portd=0b11110000; 
0B96:  MOVLW  F0
0B98:  MOVWF  F83
....................    trise=0b00000000; 
0B9A:  CLRF   F96
....................    porte=0b11111111; 
0B9C:  SETF   F84
....................     
....................    enable_interrupts(INT_EXT1); 
0B9E:  BSF    FF0.3
....................    enable_interrupts(INT_EXT2); 
0BA0:  BSF    FF0.4
....................     
....................    //enable_interrupts(int_timer0); 
....................    //enable_interrupts(int_timer1); 
....................    //enable_interrupts(int_timer5); 
....................     
....................    enable_interrupts(GLOBAL); 
0BA2:  MOVLW  C0
0BA4:  IORWF  FF2,F
....................    ext_int_edge(1,L_to_H); 
0BA6:  BSF    FF1.5
....................    ext_int_edge(2,L_to_H); 
0BA8:  BSF    FF1.4
....................     
....................    clear_interrupt(INT_EXT1); 
0BAA:  BCF    FF0.0
....................    clear_interrupt(INT_EXT2); 
0BAC:  BCF    FF0.1
....................    clear_interrupt(int_timer0); 
0BAE:  BCF    FF2.2
....................    clear_interrupt(int_timer1); 
0BB0:  BCF    F9E.0
....................    clear_interrupt(int_timer5); 
0BB2:  BCF    FA4.0
....................     
....................    setup_qei(QEI_MODE_X4_RESET_WITH_INDX,qei_filter_enable_qea|qei_filter_enable_qeb|qei_filter_div_2,65535); 
0BB4:  MOVLW  14
0BB6:  MOVWF  FB6
0BB8:  MOVLW  31
0BBA:  MOVWF  F60
0BBC:  SETF   F65
0BBE:  SETF   F64
0BC0:  CLRF   F67
0BC2:  CLRF   F66
....................    qei_set_count(0); 
0BC4:  CLRF   F67
0BC6:  CLRF   F66
....................     
....................    //setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1);      //6.5 ms overflow, 0.1us 
....................    //set_timer0(64535); 
....................     
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_4|RTCC_8_bit);      //102 us overflow, 0.4us 
0BC8:  MOVLW  C1
0BCA:  MOVWF  FD5
....................    set_timer0(5); 
0BCC:  CLRF   FD7
0BCE:  MOVLW  05
0BD0:  MOVWF  FD6
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);      //52.4 ms overflow, 0.8us 
0BD2:  MOVLW  B5
0BD4:  MOVWF  FCD
....................    set_timer1(50286); 
0BD6:  MOVLW  C4
0BD8:  MOVWF  FCF
0BDA:  MOVLW  6E
0BDC:  MOVWF  FCE
....................    setup_timer_5(T5_INTERNAL|T5_DIV_BY_8);      //52.4 ms overflow, 0.8us 
0BDE:  MOVLW  19
0BE0:  MOVWF  FB7
....................    set_timer5(53035); 
0BE2:  MOVLW  CF
0BE4:  MOVWF  F88
0BE6:  MOVLW  2B
0BE8:  MOVWF  F87
0BEA:  GOTO   18DA (RETURN)
....................     
....................    //setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_CLK_DIV_16); 
....................    //ss1=1; 
....................  
....................       
.................... } 
....................  
....................  
.................... #include <van-ctht.c> 
....................  
.................... ///// DEFINE VAN 
....................  
.................... #bit vantay1=porta.5 
.................... #bit vantay2=porte.0 
.................... #bit vancanh2=porta.0     
.................... #bit vancanh1=porta.1     
.................... #bit vanduoi=porta.2 
....................  
.................... ///// DEFINE CONG TAC HANH TRINH 
.................... #bit ctt2=portb.0 
.................... #bit ctc2=portb.1 
.................... #bit ctt1=portb.2 
.................... #bit ctc1=portb.3 
....................  
.................... #bit ctld=portb.4 
.................... #bit ctlt=portb.5 
....................  
.................... #bit ctsel=portb.7 
.................... #bit cten=portb.6 
....................  
.................... ///// CHUONG TRINH LOA TIN HIEU 
.................... #bit trisloa = trisd.7 
.................... #bit loa = portd.7 
.................... void beep(int8 solan,int8 time) 
.................... { 
.................... int8 i; 
.................... for (i=0; i<solan; i++) 
*
0B02:  CLRF   x6D
0B04:  MOVF   x6B,W
0B06:  SUBWF  x6D,W
0B08:  BC    0B24
....................    { 
....................    trisloa = 0; 
0B0A:  BCF    F95.7
....................    loa = 0; 
0B0C:  BCF    F83.7
....................    delay_ms(20); 
0B0E:  MOVLW  14
0B10:  MOVWF  x6F
0B12:  RCALL  0ADA
....................    loa = 1; 
0B14:  BSF    F83.7
....................    delay_ms(time-20); 
0B16:  MOVLW  14
0B18:  SUBWF  x6C,W
0B1A:  MOVWF  x6E
0B1C:  MOVWF  x6F
0B1E:  RCALL  0ADA
0B20:  INCF   x6D,F
0B22:  BRA    0B04
....................    } 
0B24:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <dongco.c> 
....................  
.................... ///// DEFINE CAC DONG CO 
....................  
.................... #bit br1=porte.2 
.................... #bit br2=porte.1 
.................... #bit trisbr1 = trise.2 
.................... #bit trisbr2 = trise.1 
.................... #bit dir1=portc.3 
.................... #bit dir2=portc.0 
.................... #bit trisdir1 = trisc.3 
.................... #bit trisdir2 = trisc.0 
.................... #bit pwm1=portc.2 
.................... #bit pwm2=portc.1 
.................... #bit trispwm1 = trisc.2 
.................... #bit trispwm2 = trisc.1 
....................  
.................... void dc1t(INT16 x) 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
*
0BEE:  BCF    F96.2
0BF0:  BCF    F94.3
0BF2:  BCF    F94.2
....................    dir1 = 1; 
0BF4:  BSF    F82.3
....................    br1 = 0; 
0BF6:  BCF    F84.2
....................    setup_timer_2(T2_DIV_BY_16,250,1);      //401 us overflow, 401 us interrupt 
0BF8:  MOVLW  00
0BFA:  IORLW  06
0BFC:  MOVWF  FCA
0BFE:  MOVLW  FA
0C00:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
0C02:  BCF    F8B.2
0C04:  MOVLW  0C
0C06:  MOVWF  FBD
....................    set_pwm1_duty (x); 
0C08:  MOVFF  66,02
0C0C:  MOVFF  65,01
0C10:  RRCF   02,F
0C12:  RRCF   01,F
0C14:  RRCF   02,F
0C16:  RRCF   01,F
0C18:  RRCF   02,F
0C1A:  MOVFF  01,FBE
0C1E:  RRCF   02,F
0C20:  RRCF   02,W
0C22:  ANDLW  30
0C24:  MOVWF  00
0C26:  MOVF   FBD,W
0C28:  ANDLW  CF
0C2A:  IORWF  00,W
0C2C:  MOVWF  FBD
0C2E:  RETURN 0
.................... } 
....................  
.................... void dc1n(INT16 x) 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
*
0DE8:  BCF    F96.2
0DEA:  BCF    F94.3
0DEC:  BCF    F94.2
....................    dir1 = 0; 
0DEE:  BCF    F82.3
....................    br1 = 0; 
0DF0:  BCF    F84.2
....................    setup_timer_2(T2_DIV_BY_16,250,1);      //401 us overflow, 401 us interrupt 
0DF2:  MOVLW  00
0DF4:  IORLW  06
0DF6:  MOVWF  FCA
0DF8:  MOVLW  FA
0DFA:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
0DFC:  BCF    F8B.2
0DFE:  MOVLW  0C
0E00:  MOVWF  FBD
....................    set_pwm1_duty (x); 
0E02:  MOVFF  66,02
0E06:  MOVFF  65,01
0E0A:  RRCF   02,F
0E0C:  RRCF   01,F
0E0E:  RRCF   02,F
0E10:  RRCF   01,F
0E12:  RRCF   02,F
0E14:  MOVFF  01,FBE
0E18:  RRCF   02,F
0E1A:  RRCF   02,W
0E1C:  ANDLW  30
0E1E:  MOVWF  00
0E20:  MOVF   FBD,W
0E22:  ANDLW  CF
0E24:  IORWF  00,W
0E26:  MOVWF  FBD
0E28:  RETURN 0
.................... } 
....................  
.................... void resetdc1() 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
*
01A8:  BCF    F96.2
01AA:  BCF    F94.3
01AC:  BCF    F94.2
....................    setup_timer_2(T2_DIV_BY_16,250,1);      //401 us overflow, 401 us interrupt 
01AE:  MOVLW  00
01B0:  IORLW  06
01B2:  MOVWF  FCA
01B4:  MOVLW  FA
01B6:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
01B8:  BCF    F8B.2
01BA:  MOVLW  0C
01BC:  MOVWF  FBD
....................    set_pwm1_duty (0); 
01BE:  CLRF   FBE
....................    br1 = 1; 
01C0:  BSF    F84.2
....................    dir1 = 0; 
01C2:  BCF    F82.3
01C4:  RETURN 0
.................... } 
....................  
.................... void dc2n(INT16 x) 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
*
0E2A:  BCF    F96.1
0E2C:  BCF    F94.0
0E2E:  BCF    F94.1
....................    dir2 = 1; 
0E30:  BSF    F82.0
....................    br2 = 0; 
0E32:  BCF    F84.1
....................    setup_timer_2(T2_DIV_BY_16,250,1);      //401 us overflow, 401 us interrupt 
0E34:  MOVLW  00
0E36:  IORLW  06
0E38:  MOVWF  FCA
0E3A:  MOVLW  FA
0E3C:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
0E3E:  BCF    F8B.1
0E40:  MOVLW  0C
0E42:  MOVWF  FBA
....................    set_pwm2_duty (x); 
0E44:  MOVFF  66,02
0E48:  MOVFF  65,01
0E4C:  RRCF   02,F
0E4E:  RRCF   01,F
0E50:  RRCF   02,F
0E52:  RRCF   01,F
0E54:  RRCF   02,F
0E56:  MOVFF  01,FBB
0E5A:  RRCF   02,F
0E5C:  RRCF   02,W
0E5E:  ANDLW  30
0E60:  MOVWF  00
0E62:  MOVF   FBA,W
0E64:  ANDLW  CF
0E66:  IORWF  00,W
0E68:  MOVWF  FBA
0E6A:  RETURN 0
.................... } 
....................  
.................... void dc2t(INT16 x) 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
*
0C30:  BCF    F96.1
0C32:  BCF    F94.0
0C34:  BCF    F94.1
....................    br2 = 0; 
0C36:  BCF    F84.1
....................    dir2 = 0; 
0C38:  BCF    F82.0
....................    setup_timer_2(T2_DIV_BY_16,250,1);      //401 us overflow, 401 us interrupt 
0C3A:  MOVLW  00
0C3C:  IORLW  06
0C3E:  MOVWF  FCA
0C40:  MOVLW  FA
0C42:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
0C44:  BCF    F8B.1
0C46:  MOVLW  0C
0C48:  MOVWF  FBA
....................    set_pwm2_duty (x); 
0C4A:  MOVFF  66,02
0C4E:  MOVFF  65,01
0C52:  RRCF   02,F
0C54:  RRCF   01,F
0C56:  RRCF   02,F
0C58:  RRCF   01,F
0C5A:  RRCF   02,F
0C5C:  MOVFF  01,FBB
0C60:  RRCF   02,F
0C62:  RRCF   02,W
0C64:  ANDLW  30
0C66:  MOVWF  00
0C68:  MOVF   FBA,W
0C6A:  ANDLW  CF
0C6C:  IORWF  00,W
0C6E:  MOVWF  FBA
0C70:  RETURN 0
.................... } 
....................  
.................... void resetdc2() 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
*
01C6:  BCF    F96.1
01C8:  BCF    F94.0
01CA:  BCF    F94.1
....................    br2 = 1; 
01CC:  BSF    F84.1
....................    dir2 = 0; 
01CE:  BCF    F82.0
....................    setup_timer_2(T2_DIV_BY_16,250,1);      //401 us overflow, 401 us interrupt 
01D0:  MOVLW  00
01D2:  IORLW  06
01D4:  MOVWF  FCA
01D6:  MOVLW  FA
01D8:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
01DA:  BCF    F8B.1
01DC:  MOVLW  0C
01DE:  MOVWF  FBA
....................    set_pwm2_duty (0); 
01E0:  CLRF   FBB
01E2:  RETURN 0
.................... } 
....................  
....................  
.................... #bit pwm3 = portd.6 
.................... #bit dir3 = portd.5 
.................... #bit trispwm3 = trisd.6 
.................... #bit trisdir3 = trisd.5 
....................  
.................... #include <qei_piddc.c> 
....................  
.................... ///// QEI MEM + DU LIEU QEI 
.................... signed int16 En2; 
.................... #define ChanelA PIN_C4 
.................... #define ChanelB PIN_C5 
.................... #INT_EXT1 
.................... void  EXT1_L2H_isr(void)  
.................... { 
.................... INTEDG1^=1; 
*
00DE:  MOVLW  00
00E0:  BTFSC  FF1.5
00E2:  MOVLW  01
00E4:  XORLW  01
00E6:  BCF    FF1.5
00E8:  BTFSC  FE8.0
00EA:  BSF    FF1.5
.................... if (INTEDG1) 
00EC:  BTFSS  FF1.5
00EE:  BRA    0106
....................    { 
....................    if (input(ChanelB)) {En2--;}  
00F0:  BTFSS  F82.5
00F2:  BRA    00FE
00F4:  MOVF   20,W
00F6:  BTFSC  FD8.2
00F8:  DECF   21,F
00FA:  DECF   20,F
00FC:  BRA    0104
....................    else {En2++;} 
00FE:  INCF   20,F
0100:  BTFSC  FD8.2
0102:  INCF   21,F
....................    } 
0104:  BRA    011A
.................... else  
....................    {  
....................    if (input(ChanelB)) {En2++;} 
0106:  BTFSS  F82.5
0108:  BRA    0112
010A:  INCF   20,F
010C:  BTFSC  FD8.2
010E:  INCF   21,F
0110:  BRA    011A
....................    else {En2--;} 
0112:  MOVF   20,W
0114:  BTFSC  FD8.2
0116:  DECF   21,F
0118:  DECF   20,F
....................    } 
.................... } 
011A:  BCF    FF0.0
011C:  GOTO   0090
.................... #int_EXT2 
.................... void  EXT2_isr(void)  
.................... { 
.................... INTEDG2^=1; 
0120:  MOVLW  00
0122:  BTFSC  FF1.4
0124:  MOVLW  01
0126:  XORLW  01
0128:  BCF    FF1.4
012A:  BTFSC  FE8.0
012C:  BSF    FF1.4
.................... if (INTEDG2) 
012E:  BTFSS  FF1.4
0130:  BRA    0148
....................    { 
....................    if (input(ChanelA)) {En2++;}  
0132:  BTFSS  F82.4
0134:  BRA    013E
0136:  INCF   20,F
0138:  BTFSC  FD8.2
013A:  INCF   21,F
013C:  BRA    0146
....................    else {En2--;} 
013E:  MOVF   20,W
0140:  BTFSC  FD8.2
0142:  DECF   21,F
0144:  DECF   20,F
....................    } 
0146:  BRA    015C
.................... else  
....................    {  
....................    if (input(ChanelA)) {En2--;} 
0148:  BTFSS  F82.4
014A:  BRA    0156
014C:  MOVF   20,W
014E:  BTFSC  FD8.2
0150:  DECF   21,F
0152:  DECF   20,F
0154:  BRA    015C
....................    else {En2++;} 
0156:  INCF   20,F
0158:  BTFSC  FD8.2
015A:  INCF   21,F
....................    } 
015C:  BCF    FF0.1
015E:  GOTO   0090
.................... } 
....................  
.................... /// PID DONG CO 1 ////////////////// 
.................... volatile float kp=2, ki=0.2,kd=0.7, pid1, pid2; 
.................... signed int16 realvt1, errs1=0, err1=0, delta1=0, epre1=0, duty1 ; 
.................... signed int16 realvt2, errs2=0, err2=0, delta2=0, epre2=0, duty2 ; 
.................... volatile unsigned int16 Ti1,Ti2; 
.................... volatile signed int16 setvt1,setvt2,vt1=900,vt2=900; 
....................  
.................... void piddc1(signed int16 setvt1, signed int16 vt1) 
....................      { 
....................      br1=0; 
*
05C0:  BCF    F84.2
....................      realvt1 =  qei_get_count();  
05C2:  MOVFF  F67,01
05C6:  MOVFF  F66,00
05CA:  MOVFF  F67,03
05CE:  MOVF   03,W
05D0:  SUBWF  01,W
05D2:  BZ    05D8
05D4:  MOVFF  F66,00
05D8:  MOVF   00,W
05DA:  MOVWF  36
05DC:  MOVFF  03,37
....................      err1 = setvt1 - realvt1; 
05E0:  MOVF   36,W
05E2:  SUBWF  x6B,W
05E4:  MOVWF  3A
05E6:  MOVF   37,W
05E8:  SUBWFB x6C,W
05EA:  MOVWF  3B
....................      if(Ti1>=2) 
05EC:  MOVF   4F,F
05EE:  BNZ   05F6
05F0:  MOVF   4E,W
05F2:  SUBLW  01
05F4:  BC    0656
....................      { 
....................        delta1 = err1-epre1; 
05F6:  MOVF   3E,W
05F8:  SUBWF  3A,W
05FA:  MOVWF  3C
05FC:  MOVF   3F,W
05FE:  SUBWFB 3B,W
0600:  MOVWF  3D
....................        Ti1=0; 
0602:  CLRF   4F
0604:  CLRF   4E
....................        if(delta1>-10) errs1 += err1;//(err1>-20)&&(err1<20) 
0606:  BTFSS  3D.7
0608:  BRA    061A
060A:  MOVF   3D,W
060C:  SUBLW  FE
060E:  BC    0622
0610:  XORLW  FF
0612:  BNZ   061A
0614:  MOVF   3C,W
0616:  SUBLW  F6
0618:  BC    0622
061A:  MOVF   3A,W
061C:  ADDWF  38,F
061E:  MOVF   3B,W
0620:  ADDWFC 39,F
....................        if (errs1 > 200 ) errs1=200; 
0622:  BTFSC  39.7
0624:  BRA    0636
0626:  MOVF   39,F
0628:  BNZ   0630
062A:  MOVF   38,W
062C:  SUBLW  C8
062E:  BC    0636
0630:  CLRF   39
0632:  MOVLW  C8
0634:  MOVWF  38
....................        if (errs1 < -200 ) errs1=-200; 
0636:  BTFSS  39.7
0638:  BRA    064E
063A:  MOVF   39,W
063C:  SUBLW  FF
063E:  BNC   064E
0640:  BNZ   0648
0642:  MOVF   38,W
0644:  SUBLW  37
0646:  BNC   064E
0648:  SETF   39
064A:  MOVLW  38
064C:  MOVWF  38
....................        epre1=err1; 
064E:  MOVFF  3B,3F
0652:  MOVFF  3A,3E
....................      } 
....................    
....................      pid1 =kp*err1 + ki*errs1+kd*delta1;  
0656:  MOVFF  3B,74
065A:  MOVFF  3A,73
065E:  RCALL  01E4
0660:  MOVFF  25,76
0664:  MOVFF  24,75
0668:  MOVFF  23,74
066C:  MOVFF  22,73
0670:  MOVFF  03,7A
0674:  MOVFF  02,79
0678:  MOVFF  01,78
067C:  MOVFF  00,77
0680:  RCALL  022C
0682:  MOVFF  03,72
0686:  MOVFF  02,71
068A:  MOVFF  01,70
068E:  MOVFF  00,6F
0692:  MOVFF  39,74
0696:  MOVFF  38,73
069A:  RCALL  01E4
069C:  MOVFF  29,76
06A0:  MOVFF  28,75
06A4:  MOVFF  27,74
06A8:  MOVFF  26,73
06AC:  MOVFF  03,7A
06B0:  MOVFF  02,79
06B4:  MOVFF  01,78
06B8:  MOVFF  00,77
06BC:  RCALL  022C
06BE:  BCF    FD8.1
06C0:  MOVFF  72,76
06C4:  MOVFF  71,75
06C8:  MOVFF  70,74
06CC:  MOVFF  6F,73
06D0:  MOVFF  03,7A
06D4:  MOVFF  02,79
06D8:  MOVFF  01,78
06DC:  MOVFF  00,77
06E0:  RCALL  031E
06E2:  MOVFF  03,72
06E6:  MOVFF  02,71
06EA:  MOVFF  01,70
06EE:  MOVFF  00,6F
06F2:  MOVFF  3D,74
06F6:  MOVFF  3C,73
06FA:  RCALL  01E4
06FC:  MOVFF  2D,76
0700:  MOVFF  2C,75
0704:  MOVFF  2B,74
0708:  MOVFF  2A,73
070C:  MOVFF  03,7A
0710:  MOVFF  02,79
0714:  MOVFF  01,78
0718:  MOVFF  00,77
071C:  RCALL  022C
071E:  BCF    FD8.1
0720:  MOVFF  72,76
0724:  MOVFF  71,75
0728:  MOVFF  70,74
072C:  MOVFF  6F,73
0730:  MOVFF  03,7A
0734:  MOVFF  02,79
0738:  MOVFF  01,78
073C:  MOVFF  00,77
0740:  RCALL  031E
0742:  MOVFF  03,31
0746:  MOVFF  02,30
074A:  MOVFF  01,2F
074E:  MOVFF  00,2E
....................      duty1=pid1;    
0752:  MOVFF  31,72
0756:  MOVFF  30,71
075A:  MOVFF  2F,70
075E:  MOVFF  2E,6F
0762:  RCALL  0588
0764:  MOVFF  02,41
0768:  MOVFF  01,40
....................      if (duty1 > 0)   dir1 = 0; 
076C:  BTFSC  41.7
076E:  BRA    077C
0770:  MOVF   41,F
0772:  BNZ   077A
0774:  MOVF   40,W
0776:  SUBLW  00
0778:  BC    077C
077A:  BCF    F82.3
....................      if (duty1 <  0)    dir1 = 1; 
077C:  BTFSS  41.7
077E:  BRA    0782
0780:  BSF    F82.3
....................      duty1= abs(duty1); 
0782:  MOVFF  41,03
0786:  MOVF   40,W
0788:  BTFSS  41.7
078A:  BRA    079C
078C:  MOVLW  00
078E:  BSF    FD8.0
0790:  SUBFWB 40,W
0792:  MOVWF  00
0794:  MOVLW  00
0796:  SUBFWB 41,W
0798:  MOVWF  03
079A:  MOVF   00,W
079C:  MOVWF  40
079E:  MOVFF  03,41
....................      if(duty1>5) duty1+=230; 
07A2:  BTFSC  41.7
07A4:  BRA    07B8
07A6:  MOVF   41,F
07A8:  BNZ   07B0
07AA:  MOVF   40,W
07AC:  SUBLW  05
07AE:  BC    07B8
07B0:  MOVLW  E6
07B2:  ADDWF  40,F
07B4:  MOVLW  00
07B6:  ADDWFC 41,F
....................      if(duty1>vt1) duty1=vt1; 
07B8:  BTFSS  x6E.7
07BA:  BRA    07C2
07BC:  BTFSS  41.7
07BE:  BRA    07D4
07C0:  BRA    07C6
07C2:  BTFSC  41.7
07C4:  BRA    07DC
07C6:  MOVF   x6E,W
07C8:  SUBWF  41,W
07CA:  BNC   07DC
07CC:  BNZ   07D4
07CE:  MOVF   40,W
07D0:  SUBWF  x6D,W
07D2:  BC    07DC
07D4:  MOVFF  6E,41
07D8:  MOVFF  6D,40
....................      set_pwm1_duty (duty1); 
07DC:  MOVFF  41,02
07E0:  MOVFF  40,01
07E4:  RRCF   02,F
07E6:  RRCF   01,F
07E8:  RRCF   02,F
07EA:  RRCF   01,F
07EC:  RRCF   02,F
07EE:  MOVFF  01,FBE
07F2:  RRCF   02,F
07F4:  RRCF   02,W
07F6:  ANDLW  30
07F8:  MOVWF  00
07FA:  MOVF   FBD,W
07FC:  ANDLW  CF
07FE:  IORWF  00,W
0800:  MOVWF  FBD
0802:  RETURN 0
....................      } 
....................       
.................... /// PID DONG CO 2 ////////////////// 
....................  
.................... void piddc2(signed int16 setvt2, signed int16 vt2) 
....................      { 
....................      br2=0; 
0804:  BCF    F84.1
....................      realvt2 =  En2;  
0806:  MOVFF  21,43
080A:  MOVFF  20,42
....................      err2 = setvt2 - realvt2; 
080E:  MOVF   42,W
0810:  SUBWF  x6B,W
0812:  MOVWF  46
0814:  MOVF   43,W
0816:  SUBWFB x6C,W
0818:  MOVWF  47
....................      if(Ti2>=2) 
081A:  MOVF   51,F
081C:  BNZ   0824
081E:  MOVF   50,W
0820:  SUBLW  01
0822:  BC    0884
....................      { 
....................        delta2 = err2-epre2; 
0824:  MOVF   4A,W
0826:  SUBWF  46,W
0828:  MOVWF  48
082A:  MOVF   4B,W
082C:  SUBWFB 47,W
082E:  MOVWF  49
....................        Ti2=0; 
0830:  CLRF   51
0832:  CLRF   50
....................        if(delta2>-10) errs2 += err2; /// (err2>-20)&&(err2<20) 
0834:  BTFSS  49.7
0836:  BRA    0848
0838:  MOVF   49,W
083A:  SUBLW  FE
083C:  BC    0850
083E:  XORLW  FF
0840:  BNZ   0848
0842:  MOVF   48,W
0844:  SUBLW  F6
0846:  BC    0850
0848:  MOVF   46,W
084A:  ADDWF  44,F
084C:  MOVF   47,W
084E:  ADDWFC 45,F
....................        if (errs2 > 200 ) errs2=200; 
0850:  BTFSC  45.7
0852:  BRA    0864
0854:  MOVF   45,F
0856:  BNZ   085E
0858:  MOVF   44,W
085A:  SUBLW  C8
085C:  BC    0864
085E:  CLRF   45
0860:  MOVLW  C8
0862:  MOVWF  44
....................        if (errs2 < -200 ) errs2=-200; 
0864:  BTFSS  45.7
0866:  BRA    087C
0868:  MOVF   45,W
086A:  SUBLW  FF
086C:  BNC   087C
086E:  BNZ   0876
0870:  MOVF   44,W
0872:  SUBLW  37
0874:  BNC   087C
0876:  SETF   45
0878:  MOVLW  38
087A:  MOVWF  44
....................        epre2=err2; 
087C:  MOVFF  47,4B
0880:  MOVFF  46,4A
....................      } 
....................    
....................      pid2 =kp*err2 + ki*errs2+kd*delta2;  
0884:  MOVFF  47,74
0888:  MOVFF  46,73
088C:  RCALL  01E4
088E:  MOVFF  25,76
0892:  MOVFF  24,75
0896:  MOVFF  23,74
089A:  MOVFF  22,73
089E:  MOVFF  03,7A
08A2:  MOVFF  02,79
08A6:  MOVFF  01,78
08AA:  MOVFF  00,77
08AE:  RCALL  022C
08B0:  MOVFF  03,72
08B4:  MOVFF  02,71
08B8:  MOVFF  01,70
08BC:  MOVFF  00,6F
08C0:  MOVFF  45,74
08C4:  MOVFF  44,73
08C8:  RCALL  01E4
08CA:  MOVFF  29,76
08CE:  MOVFF  28,75
08D2:  MOVFF  27,74
08D6:  MOVFF  26,73
08DA:  MOVFF  03,7A
08DE:  MOVFF  02,79
08E2:  MOVFF  01,78
08E6:  MOVFF  00,77
08EA:  RCALL  022C
08EC:  BCF    FD8.1
08EE:  MOVFF  72,76
08F2:  MOVFF  71,75
08F6:  MOVFF  70,74
08FA:  MOVFF  6F,73
08FE:  MOVFF  03,7A
0902:  MOVFF  02,79
0906:  MOVFF  01,78
090A:  MOVFF  00,77
090E:  RCALL  031E
0910:  MOVFF  03,72
0914:  MOVFF  02,71
0918:  MOVFF  01,70
091C:  MOVFF  00,6F
0920:  MOVFF  49,74
0924:  MOVFF  48,73
0928:  RCALL  01E4
092A:  MOVFF  2D,76
092E:  MOVFF  2C,75
0932:  MOVFF  2B,74
0936:  MOVFF  2A,73
093A:  MOVFF  03,7A
093E:  MOVFF  02,79
0942:  MOVFF  01,78
0946:  MOVFF  00,77
094A:  RCALL  022C
094C:  BCF    FD8.1
094E:  MOVFF  72,76
0952:  MOVFF  71,75
0956:  MOVFF  70,74
095A:  MOVFF  6F,73
095E:  MOVFF  03,7A
0962:  MOVFF  02,79
0966:  MOVFF  01,78
096A:  MOVFF  00,77
096E:  RCALL  031E
0970:  MOVFF  03,35
0974:  MOVFF  02,34
0978:  MOVFF  01,33
097C:  MOVFF  00,32
....................      duty2=pid2;     
0980:  MOVFF  35,72
0984:  MOVFF  34,71
0988:  MOVFF  33,70
098C:  MOVFF  32,6F
0990:  RCALL  0588
0992:  MOVFF  02,4D
0996:  MOVFF  01,4C
....................      if (duty2 > 0)   dir2 = 1; 
099A:  BTFSC  4D.7
099C:  BRA    09AA
099E:  MOVF   4D,F
09A0:  BNZ   09A8
09A2:  MOVF   4C,W
09A4:  SUBLW  00
09A6:  BC    09AA
09A8:  BSF    F82.0
....................      if (duty2 <  0)    dir2 = 0; 
09AA:  BTFSS  4D.7
09AC:  BRA    09B0
09AE:  BCF    F82.0
....................      duty2= abs(duty2); 
09B0:  MOVFF  4D,03
09B4:  MOVF   4C,W
09B6:  BTFSS  4D.7
09B8:  BRA    09CA
09BA:  MOVLW  00
09BC:  BSF    FD8.0
09BE:  SUBFWB 4C,W
09C0:  MOVWF  00
09C2:  MOVLW  00
09C4:  SUBFWB 4D,W
09C6:  MOVWF  03
09C8:  MOVF   00,W
09CA:  MOVWF  4C
09CC:  MOVFF  03,4D
....................      if(duty2>5) duty2+=230; 
09D0:  BTFSC  4D.7
09D2:  BRA    09E6
09D4:  MOVF   4D,F
09D6:  BNZ   09DE
09D8:  MOVF   4C,W
09DA:  SUBLW  05
09DC:  BC    09E6
09DE:  MOVLW  E6
09E0:  ADDWF  4C,F
09E2:  MOVLW  00
09E4:  ADDWFC 4D,F
....................      if(duty2>vt2) duty2=vt2; 
09E6:  BTFSS  x6E.7
09E8:  BRA    09F0
09EA:  BTFSS  4D.7
09EC:  BRA    0A02
09EE:  BRA    09F4
09F0:  BTFSC  4D.7
09F2:  BRA    0A0A
09F4:  MOVF   x6E,W
09F6:  SUBWF  4D,W
09F8:  BNC   0A0A
09FA:  BNZ   0A02
09FC:  MOVF   4C,W
09FE:  SUBWF  x6D,W
0A00:  BC    0A0A
0A02:  MOVFF  6E,4D
0A06:  MOVFF  6D,4C
....................      set_pwm2_duty (duty2); 
0A0A:  MOVFF  4D,02
0A0E:  MOVFF  4C,01
0A12:  RRCF   02,F
0A14:  RRCF   01,F
0A16:  RRCF   02,F
0A18:  RRCF   01,F
0A1A:  RRCF   02,F
0A1C:  MOVFF  01,FBB
0A20:  RRCF   02,F
0A22:  RRCF   02,W
0A24:  ANDLW  30
0A26:  MOVWF  00
0A28:  MOVF   FBA,W
0A2A:  ANDLW  CF
0A2C:  IORWF  00,W
0A2E:  MOVWF  FBA
0A30:  RETURN 0
....................      } 
....................       
....................  
....................  
....................  
....................  
.................... ///// CHUONG TRINH QUET PHIM 
.................... int8 demct=0; 
....................  
.................... ///// NGAT TIMER0 LEO THANG, SERVO 
.................... volatile char demservo=0, xungleo=100; 
.................... volatile int1 dclep=0 ; 
.................... int16 demvanduoi=0; 
.................... #int_timer0 
.................... void ngat_timer0(void)  
....................    { 
....................    demvanduoi++; 
*
0162:  INCF   5E,F
0164:  BTFSC  FD8.2
0166:  INCF   5F,F
....................    if (dclep==1) 
0168:  BTFSS  5D.0
016A:  BRA    0188
....................    { 
....................       set_timer0(5); 
016C:  CLRF   FD7
016E:  MOVLW  05
0170:  MOVWF  FD6
....................       demservo++; 
0172:  INCF   5B,F
....................       if (demservo>100) 
0174:  MOVF   5B,W
0176:  SUBLW  64
0178:  BC    017E
....................          { 
....................          demservo=0; 
017A:  CLRF   5B
....................          pwm3=0; 
017C:  BCF    F83.6
....................          } 
....................       if (demservo >=xungleo) pwm3=1; 
017E:  MOVF   5C,W
0180:  SUBWF  5B,W
0182:  BNC   0186
0184:  BSF    F83.6
....................    } 
0186:  BRA    01A2
....................    else 
....................       { 
....................       set_timer0(5); 
0188:  CLRF   FD7
018A:  MOVLW  05
018C:  MOVWF  FD6
....................       demservo++; 
018E:  INCF   5B,F
....................       if (demservo>=200) 
0190:  MOVF   5B,W
0192:  SUBLW  C7
0194:  BC    019A
....................          { 
....................          demservo=0; 
0196:  CLRF   5B
....................          output_high(pin_c7); 
0198:  BSF    F8B.7
....................          } 
....................       if (demservo >=xungleo) output_low(pin_c7); 
019A:  MOVF   5C,W
019C:  SUBWF  5B,W
019E:  BNC   01A2
01A0:  BCF    F8B.7
....................       } 
01A2:  BCF    FF2.2
01A4:  GOTO   0090
....................    }    
....................       
.................... ///// NGAT TIMER1 PID 
.................... volatile int8 chonpid=4; 
.................... #int_timer1 
.................... void ngat_timer1(void)  
....................    { 
....................       Ti1++; 
*
0A32:  INCF   4E,F
0A34:  BTFSC  FD8.2
0A36:  INCF   4F,F
....................       Ti2++; 
0A38:  INCF   50,F
0A3A:  BTFSC  FD8.2
0A3C:  INCF   51,F
....................       switch (chonpid)   
0A3E:  MOVF   x60,W
0A40:  ADDLW  FC
0A42:  BC    0AAA
0A44:  ADDLW  04
0A46:  GOTO   0AB8
....................          { 
....................           case 0 : disable_interrupts(int_timer1); resetdc1(); resetdc2(); break; 
0A4A:  BCF    F9D.0
0A4C:  CALL   01A8
0A50:  CALL   01C6
0A54:  BRA    0AAA
....................           case 1 : resetdc2(); piddc1(setvt1,vt1); break; 
0A56:  CALL   01C6
0A5A:  MOVFF  53,6C
0A5E:  MOVFF  52,6B
0A62:  MOVFF  57,6E
0A66:  MOVFF  56,6D
0A6A:  RCALL  05C0
0A6C:  BRA    0AAA
....................           case 2 : resetdc1(); piddc2(setvt2,vt2); break; 
0A6E:  CALL   01A8
0A72:  MOVFF  55,6C
0A76:  MOVFF  54,6B
0A7A:  MOVFF  59,6E
0A7E:  MOVFF  58,6D
0A82:  RCALL  0804
0A84:  BRA    0AAA
....................           case 3 : piddc1(setvt1,vt1); piddc2(setvt2,vt2);  break; 
0A86:  MOVFF  53,6C
0A8A:  MOVFF  52,6B
0A8E:  MOVFF  57,6E
0A92:  MOVFF  56,6D
0A96:  RCALL  05C0
0A98:  MOVFF  55,6C
0A9C:  MOVFF  54,6B
0AA0:  MOVFF  59,6E
0AA4:  MOVFF  58,6D
0AA8:  RCALL  0804
....................          } 
....................         
....................       set_timer1(50286);    
0AAA:  MOVLW  C4
0AAC:  MOVWF  FCF
0AAE:  MOVLW  6E
0AB0:  MOVWF  FCE
....................        
....................    } 
....................     
.................... ///// NGAT TIMER5 QUET PHIM  
0AB2:  BCF    F9E.0
0AB4:  GOTO   0090
.................... #int_timer5 
.................... void ngat_timer5(void)  
....................    { 
....................       
....................       set_timer5(50035); 
*
0B26:  MOVLW  C3
0B28:  MOVWF  F88
0B2A:  MOVLW  73
0B2C:  MOVWF  F87
....................       demct++; 
0B2E:  INCF   5A,F
....................       if (demct==2) { beep(1,50); } 
0B30:  MOVF   5A,W
0B32:  SUBLW  02
0B34:  BNZ   0B40
0B36:  MOVLW  01
0B38:  MOVWF  x6B
0B3A:  MOVLW  32
0B3C:  MOVWF  x6C
0B3E:  RCALL  0B02
....................       if (demct==50) { beep(1,50); } 
0B40:  MOVF   5A,W
0B42:  SUBLW  32
0B44:  BNZ   0B50
0B46:  MOVLW  01
0B48:  MOVWF  x6B
0B4A:  MOVLW  32
0B4C:  MOVWF  x6C
0B4E:  RCALL  0B02
....................       if (demct==100) { beep(1,50); } 
0B50:  MOVF   5A,W
0B52:  SUBLW  64
0B54:  BNZ   0B60
0B56:  MOVLW  01
0B58:  MOVWF  x6B
0B5A:  MOVLW  32
0B5C:  MOVWF  x6C
0B5E:  RCALL  0B02
....................       if (demct==150) { beep(1,50); } 
0B60:  MOVF   5A,W
0B62:  SUBLW  96
0B64:  BNZ   0B70
0B66:  MOVLW  01
0B68:  MOVWF  x6B
0B6A:  MOVLW  32
0B6C:  MOVWF  x6C
0B6E:  RCALL  0B02
....................       if (demct>200) {demct=0; disable_interrupts(int_timer5); } 
0B70:  MOVF   5A,W
0B72:  SUBLW  C8
0B74:  BC    0B7A
0B76:  CLRF   5A
0B78:  BCF    FA3.0
....................       
....................        
....................    }    
....................  
.................... ///// KHAI BAO NHIEM VU 
.................... //#include <resetall.c> 
0B7A:  BCF    FA4.0
0B7C:  GOTO   0090
.................... #include <resetvan.c> 
....................  
.................... ///// RESET TAT CA 
.................... int8 ire=0; 
....................  
.................... void resetvan() 
.................... { 
....................  
.................... disable_interrupts(int_timer1); 
*
0C72:  BCF    F9D.0
.................... disable_interrupts(int_timer0); 
0C74:  BCF    FF2.5
....................  
.................... delay_ms(500); 
0C76:  MOVLW  02
0C78:  MOVWF  x65
0C7A:  CLRF   19
0C7C:  BTFSC  FF2.7
0C7E:  BSF    19.7
0C80:  BCF    FF2.7
0C82:  MOVLW  FA
0C84:  MOVWF  x6F
0C86:  RCALL  0ADA
0C88:  BTFSC  19.7
0C8A:  BSF    FF2.7
0C8C:  DECFSZ x65,F
0C8E:  BRA    0C7A
0C90:  CLRF   19
0C92:  BTFSC  FF2.7
0C94:  BSF    19.7
0C96:  BCF    FF2.7
.................... beep(1,100); 
0C98:  MOVLW  01
0C9A:  MOVWF  x6B
0C9C:  MOVLW  64
0C9E:  MOVWF  x6C
0CA0:  RCALL  0B02
0CA2:  BTFSC  19.7
0CA4:  BSF    FF2.7
....................  
.................... for (ire=0; ire<50; ire++) 
0CA6:  CLRF   x61
0CA8:  MOVF   x61,W
0CAA:  SUBLW  31
0CAC:  BNC   0CEE
....................    { 
....................    if (ctsel==0) {vancanh1=vancanh2=0; delay_ms(1000); vantay1=vantay2=0; ire=100; } 
0CAE:  BTFSC  F81.7
0CB0:  BRA    0CD8
0CB2:  BCF    F80.0
0CB4:  BCF    F80.1
0CB6:  MOVLW  04
0CB8:  MOVWF  x65
0CBA:  CLRF   19
0CBC:  BTFSC  FF2.7
0CBE:  BSF    19.7
0CC0:  BCF    FF2.7
0CC2:  MOVLW  FA
0CC4:  MOVWF  x6F
0CC6:  RCALL  0ADA
0CC8:  BTFSC  19.7
0CCA:  BSF    FF2.7
0CCC:  DECFSZ x65,F
0CCE:  BRA    0CBA
0CD0:  BCF    F84.0
0CD2:  BCF    F80.5
0CD4:  MOVLW  64
0CD6:  MOVWF  x61
0CD8:  CLRF   19
0CDA:  BTFSC  FF2.7
0CDC:  BSF    19.7
0CDE:  BCF    FF2.7
....................    delay_ms(10); 
0CE0:  MOVLW  0A
0CE2:  MOVWF  x6F
0CE4:  RCALL  0ADA
0CE6:  BTFSC  19.7
0CE8:  BSF    FF2.7
0CEA:  INCF   x61,F
0CEC:  BRA    0CA8
....................    } 
.................... delay_ms(500);    
0CEE:  MOVLW  02
0CF0:  MOVWF  x65
0CF2:  CLRF   19
0CF4:  BTFSC  FF2.7
0CF6:  BSF    19.7
0CF8:  BCF    FF2.7
0CFA:  MOVLW  FA
0CFC:  MOVWF  x6F
0CFE:  RCALL  0ADA
0D00:  BTFSC  19.7
0D02:  BSF    FF2.7
0D04:  DECFSZ x65,F
0D06:  BRA    0CF2
.................... while (ctc1==1) { dc1t(430); } 
0D08:  BTFSS  F81.3
0D0A:  BRA    0D18
0D0C:  MOVLW  01
0D0E:  MOVWF  x66
0D10:  MOVLW  AE
0D12:  MOVWF  x65
0D14:  RCALL  0BEE
0D16:  BRA    0D08
.................... resetdc1(); 
0D18:  CALL   01A8
.................... while (ctc2==1) { dc2t(600); } 
0D1C:  BTFSS  F81.1
0D1E:  BRA    0D2C
0D20:  MOVLW  02
0D22:  MOVWF  x66
0D24:  MOVLW  58
0D26:  MOVWF  x65
0D28:  RCALL  0C30
0D2A:  BRA    0D1C
.................... resetdc2(); 
0D2C:  CALL   01C6
0D30:  CLRF   19
0D32:  BTFSC  FF2.7
0D34:  BSF    19.7
0D36:  BCF    FF2.7
.................... beep(1,100); 
0D38:  MOVLW  01
0D3A:  MOVWF  x6B
0D3C:  MOVLW  64
0D3E:  MOVWF  x6C
0D40:  RCALL  0B02
0D42:  BTFSC  19.7
0D44:  BSF    FF2.7
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
0D46:  BSF    F80.2
0D48:  BSF    F80.0
0D4A:  BSF    F80.1
0D4C:  BSF    F84.0
0D4E:  BSF    F80.5
....................  
.................... trispwm3=trisdir3=0; 
0D50:  BCF    F95.5
0D52:  BCF    F95.6
.................... pwm3=dir3=1; 
0D54:  BSF    F83.5
0D56:  BSF    F83.6
.................... enable_interrupts(int_timer0); 
0D58:  BSF    FF2.5
.................... dclep=1; 
0D5A:  BSF    5D.0
.................... while (ctlt==1) 
0D5C:  BTFSS  F81.5
0D5E:  BRA    0D68
....................    { 
....................    dir3=1; 
0D60:  BSF    F83.5
....................    xungleo=30; 
0D62:  MOVLW  1E
0D64:  MOVWF  5C
0D66:  BRA    0D5C
....................    } 
....................    xungleo=0;   
0D68:  CLRF   5C
....................    delay_ms(300); 
0D6A:  MOVLW  02
0D6C:  MOVWF  x65
0D6E:  CLRF   19
0D70:  BTFSC  FF2.7
0D72:  BSF    19.7
0D74:  BCF    FF2.7
0D76:  MOVLW  96
0D78:  MOVWF  x6F
0D7A:  RCALL  0ADA
0D7C:  BTFSC  19.7
0D7E:  BSF    FF2.7
0D80:  DECFSZ x65,F
0D82:  BRA    0D6E
.................... while (ctlt==0) 
0D84:  BTFSC  F81.5
0D86:  BRA    0D90
....................    { 
....................    dir3=0;  
0D88:  BCF    F83.5
....................    xungleo=60; 
0D8A:  MOVLW  3C
0D8C:  MOVWF  5C
0D8E:  BRA    0D84
....................    } 
....................    xungleo=0; 
0D90:  CLRF   5C
0D92:  CLRF   19
0D94:  BTFSC  FF2.7
0D96:  BSF    19.7
0D98:  BCF    FF2.7
....................    beep(1,100);    
0D9A:  MOVLW  01
0D9C:  MOVWF  x6B
0D9E:  MOVLW  64
0DA0:  MOVWF  x6C
0DA2:  RCALL  0B02
0DA4:  BTFSC  19.7
0DA6:  BSF    FF2.7
.................... disable_interrupts(int_timer0); 
0DA8:  BCF    FF2.5
.................... pwm3=1; 
0DAA:  BSF    F83.6
.................... dir3=1; 
0DAC:  BSF    F83.5
0DAE:  CLRF   19
0DB0:  BTFSC  FF2.7
0DB2:  BSF    19.7
0DB4:  BCF    FF2.7
.................... beep(1,100); 
0DB6:  MOVLW  01
0DB8:  MOVWF  x6B
0DBA:  MOVLW  64
0DBC:  MOVWF  x6C
0DBE:  RCALL  0B02
0DC0:  BTFSC  19.7
0DC2:  BSF    FF2.7
....................  
.................... qei_set_count(0); 
0DC4:  CLRF   F67
0DC6:  CLRF   F66
.................... En2=0; 
0DC8:  CLRF   21
0DCA:  CLRF   20
.................... Ti1=0; 
0DCC:  CLRF   4F
0DCE:  CLRF   4E
.................... Ti2=0; 
0DD0:  CLRF   51
0DD2:  CLRF   50
.................... setvt1=0; 
0DD4:  CLRF   53
0DD6:  CLRF   52
.................... setvt2=0; 
0DD8:  CLRF   55
0DDA:  CLRF   54
.................... chonpid=4; 
0DDC:  MOVLW  04
0DDE:  MOVWF  x60
....................  
.................... demct=200; 
0DE0:  MOVLW  C8
0DE2:  MOVWF  5A
.................... enable_interrupts(int_timer5); 
0DE4:  BSF    FA3.0
0DE6:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... #include <nhiemvu2.c> 
....................  
.................... ///// NHIEM VU 2 
....................  
.................... void nhiemvu2() 
.................... { 
....................  
....................  
.................... delay_ms(1000); 
.................... beep(2,100); 
....................  
.................... while(cten==1){} 
.................... delay_ms(100); 
....................  
.................... if(cten==0) { vanduoi=0; } 
.................... delay_ms(100); 
....................  
.................... while(cten==0) {} 
....................  
.................... delay_ms(2000); 
....................  
.................... while(cten==1) {} 
....................  
.................... if(cten==0) { vanduoi=1; } 
....................  
.................... demct=200; 
.................... enable_interrupts(int_timer5); 
....................  
.................... } 
....................  
....................  
....................  
.................... #include <nhiemvu3.c> 
....................  
.................... ///// NHIEM VU 3 
.................... int8 inv3=0;  
.................... void nhiemvu3() 
.................... { 
....................  
.................... delay_ms(1000); 
*
0E6C:  MOVLW  04
0E6E:  MOVWF  x65
0E70:  CLRF   19
0E72:  BTFSC  FF2.7
0E74:  BSF    19.7
0E76:  BCF    FF2.7
0E78:  MOVLW  FA
0E7A:  MOVWF  x6F
0E7C:  RCALL  0ADA
0E7E:  BTFSC  19.7
0E80:  BSF    FF2.7
0E82:  DECFSZ x65,F
0E84:  BRA    0E70
0E86:  CLRF   19
0E88:  BTFSC  FF2.7
0E8A:  BSF    19.7
0E8C:  BCF    FF2.7
.................... beep(3,100); 
0E8E:  MOVLW  03
0E90:  MOVWF  x6B
0E92:  MOVLW  64
0E94:  MOVWF  x6C
0E96:  RCALL  0B02
0E98:  BTFSC  19.7
0E9A:  BSF    FF2.7
.................... setup_timer_2(T2_DIV_BY_16,250,1);      //401 us overflow, 401 us interrupt 
0E9C:  MOVLW  00
0E9E:  IORLW  06
0EA0:  MOVWF  FCA
0EA2:  MOVLW  FA
0EA4:  MOVWF  FCB
.................... setup_ccp1 (ccp_pwm); 
0EA6:  BCF    F8B.2
0EA8:  MOVLW  0C
0EAA:  MOVWF  FBD
.................... setup_ccp2 (ccp_pwm); 
0EAC:  BCF    F8B.1
0EAE:  MOVWF  FBA
....................  
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
0EB0:  BSF    F80.2
0EB2:  BSF    F80.0
0EB4:  BSF    F80.1
0EB6:  BSF    F84.0
0EB8:  BSF    F80.5
.................... vancanh1=vancanh2=0; 
0EBA:  BCF    F80.0
0EBC:  BCF    F80.1
....................  
.................... chonpid=2; 
0EBE:  MOVLW  02
0EC0:  MOVWF  x60
.................... setvt2=280; 
0EC2:  MOVLW  01
0EC4:  MOVWF  55
0EC6:  MOVLW  18
0EC8:  MOVWF  54
.................... enable_interrupts(int_timer1); 
0ECA:  BSF    F9D.0
.................... while (En2<280) {} 
0ECC:  BTFSC  21.7
0ECE:  BRA    0EDE
0ED0:  MOVF   21,W
0ED2:  SUBLW  01
0ED4:  BNC   0EE0
0ED6:  BNZ   0EDE
0ED8:  MOVF   20,W
0EDA:  SUBLW  17
0EDC:  BTFSC  FD8.0
0EDE:  BRA    0ECC
....................  
.................... chonpid=1; 
0EE0:  MOVLW  01
0EE2:  MOVWF  x60
.................... setvt1=235; 
0EE4:  CLRF   53
0EE6:  MOVLW  EB
0EE8:  MOVWF  52
.................... while (qei_get_count() <235) {} 
0EEA:  MOVFF  F67,01
0EEE:  MOVFF  F66,00
0EF2:  MOVFF  F67,03
0EF6:  MOVF   03,W
0EF8:  SUBWF  01,W
0EFA:  BZ    0F00
0EFC:  MOVFF  F66,00
0F00:  MOVF   00,W
0F02:  MOVWF  x65
0F04:  MOVFF  03,66
0F08:  MOVF   x66,F
0F0A:  BNZ   0F14
0F0C:  MOVF   x65,W
0F0E:  SUBLW  EA
0F10:  BNC   0F14
0F12:  BRA    0EEA
....................  
.................... vantay1=vantay2=0; 
0F14:  BCF    F84.0
0F16:  BCF    F80.5
....................  
.................... while (ctsel==1) {} 
0F18:  BTFSC  F81.7
0F1A:  BRA    0F18
.................... if (ctsel==0) { vantay1=1; beep(1,100); } 
0F1C:  BTFSC  F81.7
0F1E:  BRA    0F38
0F20:  BSF    F80.5
0F22:  CLRF   19
0F24:  BTFSC  FF2.7
0F26:  BSF    19.7
0F28:  BCF    FF2.7
0F2A:  MOVLW  01
0F2C:  MOVWF  x6B
0F2E:  MOVLW  64
0F30:  MOVWF  x6C
0F32:  RCALL  0B02
0F34:  BTFSC  19.7
0F36:  BSF    FF2.7
.................... while (cten==1) {} 
0F38:  BTFSC  F81.6
0F3A:  BRA    0F38
.................... chonpid=1;  
0F3C:  MOVLW  01
0F3E:  MOVWF  x60
.................... if (cten==0) { setvt1=270; } 
0F40:  BTFSC  F81.6
0F42:  BRA    0F4C
0F44:  MOVLW  01
0F46:  MOVWF  53
0F48:  MOVLW  0E
0F4A:  MOVWF  52
.................... while (qei_get_count() <270) {}; 
0F4C:  MOVFF  F67,01
0F50:  MOVFF  F66,00
0F54:  MOVFF  F67,03
0F58:  MOVF   03,W
0F5A:  SUBWF  01,W
0F5C:  BZ    0F62
0F5E:  MOVFF  F66,00
0F62:  MOVF   00,W
0F64:  MOVWF  x65
0F66:  MOVFF  03,66
0F6A:  MOVF   x66,W
0F6C:  SUBLW  01
0F6E:  BNC   0F7A
0F70:  BNZ   0F78
0F72:  MOVF   x65,W
0F74:  SUBLW  0D
0F76:  BNC   0F7A
0F78:  BRA    0F4C
.................... chonpid=0; 
0F7A:  CLRF   x60
....................  
.................... dc1n(700); 
0F7C:  MOVLW  02
0F7E:  MOVWF  x66
0F80:  MOVLW  BC
0F82:  MOVWF  x65
0F84:  RCALL  0DE8
.................... for ( inv3=0; inv3 < 6 ; inv3++) 
0F86:  CLRF   x62
0F88:  MOVF   x62,W
0F8A:  SUBLW  05
0F8C:  BNC   0FEA
.................... { 
.................... while (ctt2==1) { } //if ( qei_get_count()>285 ) {resetdc1(); beep(10,100);} } 
0F8E:  BTFSC  F81.0
0F90:  BRA    0F8E
.................... if (ctt2==0) {vantay2=1; resetdc1(); beep(1,100); } 
0F92:  BTFSC  F81.0
0F94:  BRA    0FB2
0F96:  BSF    F84.0
0F98:  CALL   01A8
0F9C:  CLRF   19
0F9E:  BTFSC  FF2.7
0FA0:  BSF    19.7
0FA2:  BCF    FF2.7
0FA4:  MOVLW  01
0FA6:  MOVWF  x6B
0FA8:  MOVLW  64
0FAA:  MOVWF  x6C
0FAC:  RCALL  0B02
0FAE:  BTFSC  19.7
0FB0:  BSF    FF2.7
.................... if (ctt2==1) {vantay2=0; dc1t(300); delay_ms(400); dc1n(600); } 
0FB2:  BTFSS  F81.0
0FB4:  BRA    0FE6
0FB6:  BCF    F84.0
0FB8:  MOVLW  01
0FBA:  MOVWF  x66
0FBC:  MOVLW  2C
0FBE:  MOVWF  x65
0FC0:  RCALL  0BEE
0FC2:  MOVLW  02
0FC4:  MOVWF  x65
0FC6:  CLRF   19
0FC8:  BTFSC  FF2.7
0FCA:  BSF    19.7
0FCC:  BCF    FF2.7
0FCE:  MOVLW  C8
0FD0:  MOVWF  x6F
0FD2:  RCALL  0ADA
0FD4:  BTFSC  19.7
0FD6:  BSF    FF2.7
0FD8:  DECFSZ x65,F
0FDA:  BRA    0FC6
0FDC:  MOVLW  02
0FDE:  MOVWF  x66
0FE0:  MOVLW  58
0FE2:  MOVWF  x65
0FE4:  RCALL  0DE8
0FE6:  INCF   x62,F
0FE8:  BRA    0F88
.................... } 
.................... vantay2=1; resetdc1(); 
0FEA:  BSF    F84.0
0FEC:  CALL   01A8
....................  
.................... delay_ms(1000); 
0FF0:  MOVLW  04
0FF2:  MOVWF  x65
0FF4:  CLRF   19
0FF6:  BTFSC  FF2.7
0FF8:  BSF    19.7
0FFA:  BCF    FF2.7
0FFC:  MOVLW  FA
0FFE:  MOVWF  x6F
1000:  RCALL  0ADA
1002:  BTFSC  19.7
1004:  BSF    FF2.7
1006:  DECFSZ x65,F
1008:  BRA    0FF4
.................... vantay1=0; 
100A:  BCF    F80.5
.................... chonpid=2; 
100C:  MOVLW  02
100E:  MOVWF  x60
.................... setvt2=250; 
1010:  CLRF   55
1012:  MOVLW  FA
1014:  MOVWF  54
.................... enable_interrupts(int_timer1); 
1016:  BSF    F9D.0
.................... while ( En2 >250) {} 
1018:  BTFSC  21.7
101A:  BRA    1028
101C:  MOVF   21,F
101E:  BNZ   1026
1020:  MOVF   20,W
1022:  SUBLW  FA
1024:  BTFSS  FD8.0
1026:  BRA    1018
....................  
.................... setvt2=10; 
1028:  CLRF   55
102A:  MOVLW  0A
102C:  MOVWF  54
.................... setvt1=0; 
102E:  CLRF   53
1030:  CLRF   52
.................... chonpid=3; 
1032:  MOVLW  03
1034:  MOVWF  x60
.................... while ( En2 >11) {} 
1036:  BTFSC  21.7
1038:  BRA    1046
103A:  MOVF   21,F
103C:  BNZ   1044
103E:  MOVF   20,W
1040:  SUBLW  0B
1042:  BTFSS  FD8.0
1044:  BRA    1036
.................... chonpid=0; 
1046:  CLRF   x60
....................  
.................... dc2t(700); 
1048:  MOVLW  02
104A:  MOVWF  x66
104C:  MOVLW  BC
104E:  MOVWF  x65
1050:  RCALL  0C30
.................... for (inv3=0; inv3 < 4; inv3++) 
1052:  CLRF   x62
1054:  MOVF   x62,W
1056:  SUBLW  03
1058:  BNC   10B6
....................    { 
....................    while (ctt1==1) { } //if ( En2 <-5 ) {resetdc2(); beep(10,100);} } 
105A:  BTFSC  F81.2
105C:  BRA    105A
....................    if (ctt1==0) {vantay1=1;resetdc2(); beep(1,100); } 
105E:  BTFSC  F81.2
1060:  BRA    107E
1062:  BSF    F80.5
1064:  CALL   01C6
1068:  CLRF   19
106A:  BTFSC  FF2.7
106C:  BSF    19.7
106E:  BCF    FF2.7
1070:  MOVLW  01
1072:  MOVWF  x6B
1074:  MOVLW  64
1076:  MOVWF  x6C
1078:  RCALL  0B02
107A:  BTFSC  19.7
107C:  BSF    FF2.7
....................    if (ctt1==1) {vantay1=0; dc2n(300); delay_ms(400); dc2t(600); } 
107E:  BTFSS  F81.2
1080:  BRA    10B2
1082:  BCF    F80.5
1084:  MOVLW  01
1086:  MOVWF  x66
1088:  MOVLW  2C
108A:  MOVWF  x65
108C:  RCALL  0E2A
108E:  MOVLW  02
1090:  MOVWF  x65
1092:  CLRF   19
1094:  BTFSC  FF2.7
1096:  BSF    19.7
1098:  BCF    FF2.7
109A:  MOVLW  C8
109C:  MOVWF  x6F
109E:  RCALL  0ADA
10A0:  BTFSC  19.7
10A2:  BSF    FF2.7
10A4:  DECFSZ x65,F
10A6:  BRA    1092
10A8:  MOVLW  02
10AA:  MOVWF  x66
10AC:  MOVLW  58
10AE:  MOVWF  x65
10B0:  RCALL  0C30
10B2:  INCF   x62,F
10B4:  BRA    1054
....................    } 
.................... vantay1=1;resetdc1();  
10B6:  BSF    F80.5
10B8:  CALL   01A8
....................  
....................  
.................... delay_ms(1000); 
10BC:  MOVLW  04
10BE:  MOVWF  x65
10C0:  CLRF   19
10C2:  BTFSC  FF2.7
10C4:  BSF    19.7
10C6:  BCF    FF2.7
10C8:  MOVLW  FA
10CA:  MOVWF  x6F
10CC:  RCALL  0ADA
10CE:  BTFSC  19.7
10D0:  BSF    FF2.7
10D2:  DECFSZ x65,F
10D4:  BRA    10C0
.................... vantay2=0; 
10D6:  BCF    F84.0
.................... chonpid=1; 
10D8:  MOVLW  01
10DA:  MOVWF  x60
.................... setvt1=30; 
10DC:  CLRF   53
10DE:  MOVLW  1E
10E0:  MOVWF  52
.................... enable_interrupts(int_timer1); 
10E2:  BSF    F9D.0
.................... while (qei_get_count() < 30) {} 
10E4:  MOVFF  F67,01
10E8:  MOVFF  F66,00
10EC:  MOVFF  F67,03
10F0:  MOVF   03,W
10F2:  SUBWF  01,W
10F4:  BZ    10FA
10F6:  MOVFF  F66,00
10FA:  MOVF   00,W
10FC:  MOVWF  x65
10FE:  MOVFF  03,66
1102:  MOVF   x66,F
1104:  BNZ   110E
1106:  MOVF   x65,W
1108:  SUBLW  1D
110A:  BNC   110E
110C:  BRA    10E4
....................  
.................... setvt1=270; 
110E:  MOVLW  01
1110:  MOVWF  53
1112:  MOVLW  0E
1114:  MOVWF  52
.................... setvt2=280; 
1116:  MOVLW  01
1118:  MOVWF  55
111A:  MOVLW  18
111C:  MOVWF  54
.................... chonpid=3; 
111E:  MOVLW  03
1120:  MOVWF  x60
.................... while (qei_get_count() < 270) {} 
1122:  MOVFF  F67,01
1126:  MOVFF  F66,00
112A:  MOVFF  F67,03
112E:  MOVF   03,W
1130:  SUBWF  01,W
1132:  BZ    1138
1134:  MOVFF  F66,00
1138:  MOVF   00,W
113A:  MOVWF  x65
113C:  MOVFF  03,66
1140:  MOVF   x66,W
1142:  SUBLW  01
1144:  BNC   1150
1146:  BNZ   114E
1148:  MOVF   x65,W
114A:  SUBLW  0D
114C:  BNC   1150
114E:  BRA    1122
.................... chonpid=0; 
1150:  CLRF   x60
....................  
.................... dc1n(700); 
1152:  MOVLW  02
1154:  MOVWF  x66
1156:  MOVLW  BC
1158:  MOVWF  x65
115A:  RCALL  0DE8
.................... for ( inv3=0; inv3 < 4 ; inv3++) 
115C:  CLRF   x62
115E:  MOVF   x62,W
1160:  SUBLW  03
1162:  BNC   11DE
.................... { 
.................... while (ctt1==1) {} // if ( qei_get_count() >285 ) {resetdc1(); beep(10,100);} } 
1164:  BTFSC  F81.2
1166:  BRA    1164
.................... if (ctt1==0) {vantay2=1; resetdc1(); beep(1,100); } 
1168:  BTFSC  F81.2
116A:  BRA    1188
116C:  BSF    F84.0
116E:  CALL   01A8
1172:  CLRF   19
1174:  BTFSC  FF2.7
1176:  BSF    19.7
1178:  BCF    FF2.7
117A:  MOVLW  01
117C:  MOVWF  x6B
117E:  MOVLW  64
1180:  MOVWF  x6C
1182:  RCALL  0B02
1184:  BTFSC  19.7
1186:  BSF    FF2.7
.................... if (ctt1==1) {vantay2=0; dc1t(300); delay_ms(300); resetdc1(); delay_ms(300); dc1n(700); } 
1188:  BTFSS  F81.2
118A:  BRA    11DA
118C:  BCF    F84.0
118E:  MOVLW  01
1190:  MOVWF  x66
1192:  MOVLW  2C
1194:  MOVWF  x65
1196:  RCALL  0BEE
1198:  MOVLW  02
119A:  MOVWF  x65
119C:  CLRF   19
119E:  BTFSC  FF2.7
11A0:  BSF    19.7
11A2:  BCF    FF2.7
11A4:  MOVLW  96
11A6:  MOVWF  x6F
11A8:  RCALL  0ADA
11AA:  BTFSC  19.7
11AC:  BSF    FF2.7
11AE:  DECFSZ x65,F
11B0:  BRA    119C
11B2:  CALL   01A8
11B6:  MOVLW  02
11B8:  MOVWF  x65
11BA:  CLRF   19
11BC:  BTFSC  FF2.7
11BE:  BSF    19.7
11C0:  BCF    FF2.7
11C2:  MOVLW  96
11C4:  MOVWF  x6F
11C6:  RCALL  0ADA
11C8:  BTFSC  19.7
11CA:  BSF    FF2.7
11CC:  DECFSZ x65,F
11CE:  BRA    11BA
11D0:  MOVLW  02
11D2:  MOVWF  x66
11D4:  MOVLW  BC
11D6:  MOVWF  x65
11D8:  RCALL  0DE8
11DA:  INCF   x62,F
11DC:  BRA    115E
.................... } 
.................... vantay2=1; resetdc2(); 
11DE:  BSF    F84.0
11E0:  CALL   01C6
....................  
....................  
.................... delay_ms(1000); 
11E4:  MOVLW  04
11E6:  MOVWF  x65
11E8:  CLRF   19
11EA:  BTFSC  FF2.7
11EC:  BSF    19.7
11EE:  BCF    FF2.7
11F0:  MOVLW  FA
11F2:  MOVWF  x6F
11F4:  RCALL  0ADA
11F6:  BTFSC  19.7
11F8:  BSF    FF2.7
11FA:  DECFSZ x65,F
11FC:  BRA    11E8
.................... vantay2=0; 
11FE:  BCF    F84.0
.................... chonpid=2; 
1200:  MOVLW  02
1202:  MOVWF  x60
.................... setvt2=220; 
1204:  CLRF   55
1206:  MOVLW  DC
1208:  MOVWF  54
.................... enable_interrupts(int_timer1); 
120A:  BSF    F9D.0
.................... while ( En2 > 220) {} 
120C:  BTFSC  21.7
120E:  BRA    121C
1210:  MOVF   21,F
1212:  BNZ   121A
1214:  MOVF   20,W
1216:  SUBLW  DC
1218:  BTFSS  FD8.0
121A:  BRA    120C
.................... chonpid=0; 
121C:  CLRF   x60
....................  
.................... while (cten==1) {} 
121E:  BTFSC  F81.6
1220:  BRA    121E
.................... if (cten==0) {delay_ms(100);} 
1222:  BTFSC  F81.6
1224:  BRA    1238
1226:  CLRF   19
1228:  BTFSC  FF2.7
122A:  BSF    19.7
122C:  BCF    FF2.7
122E:  MOVLW  64
1230:  MOVWF  x6F
1232:  RCALL  0ADA
1234:  BTFSC  19.7
1236:  BSF    FF2.7
.................... while (cten==1) {} 
1238:  BTFSC  F81.6
123A:  BRA    1238
.................... while (ctsel==1) {} 
123C:  BTFSC  F81.7
123E:  BRA    123C
....................  
.................... if (ctsel==0) { vantay1=0; delay_ms(400); } 
1240:  BTFSC  F81.7
1242:  BRA    1260
1244:  BCF    F80.5
1246:  MOVLW  02
1248:  MOVWF  x65
124A:  CLRF   19
124C:  BTFSC  FF2.7
124E:  BSF    19.7
1250:  BCF    FF2.7
1252:  MOVLW  C8
1254:  MOVWF  x6F
1256:  RCALL  0ADA
1258:  BTFSC  19.7
125A:  BSF    FF2.7
125C:  DECFSZ x65,F
125E:  BRA    124A
.................... while (ctsel==1) {} 
1260:  BTFSC  F81.7
1262:  BRA    1260
.................... if (ctsel==0) { delay_ms(400);  resetvan(); } 
1264:  BTFSC  F81.7
1266:  BRA    1284
1268:  MOVLW  02
126A:  MOVWF  x65
126C:  CLRF   19
126E:  BTFSC  FF2.7
1270:  BSF    19.7
1272:  BCF    FF2.7
1274:  MOVLW  C8
1276:  MOVWF  x6F
1278:  RCALL  0ADA
127A:  BTFSC  19.7
127C:  BSF    FF2.7
127E:  DECFSZ x65,F
1280:  BRA    126C
1282:  RCALL  0C72
....................  
.................... enable_interrupts(int_timer5); 
1284:  BSF    FA3.0
1286:  GOTO   1966 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... /* 
.................... void nhiemvu3xdg() 
.................... { 
.................... delay_ms(1000); 
.................... beep(3,100); 
....................  
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
.................... vancanh1=vancanh2=0; 
.................... vantay1=vantay2=0; 
.................... En2=0; 
.................... qei_set_count(0); 
....................  
.................... while( En2< 235) dc2n(500);   
.................... resetdc2(); 
.................... while (En2> 235) dc2t(250); 
.................... resetdc2(); 
....................  
.................... while( qei_get_count() < 280) dc1n(500);   
.................... resetdc1(); 
.................... while (qei_get_count() > 280) dc1t(250); 
.................... resetdc1(); 
....................  
.................... while (ctsel==1) {} 
....................  
.................... vantay2=1; beep(1,100);  
....................  
.................... while (cten==1) {} 
....................  
.................... while( En2< 270) dc2n(370);  
....................  
.................... while (ctt1==1) { dc2n(600); } 
.................... vantay1=0;  
.................... resetdc2(); 
.................... delay_ms(200); 
.................... if (ctt1==1) { vantay1=0; }    
.................... while (ctt1==1) { dc2n(800); } 
....................  
....................  
....................  
....................  
.................... } 
.................... */ 
....................  
....................  
....................  
.................... #include <nhiemvu3x.c> 
....................  
.................... ///// NHIEM VU 3X 
....................  
.................... int8 inv3x=0; 
.................... void nhiemvu3x() 
.................... { 
.................... delay_ms(1000); 
128A:  MOVLW  04
128C:  MOVWF  x65
128E:  CLRF   19
1290:  BTFSC  FF2.7
1292:  BSF    19.7
1294:  BCF    FF2.7
1296:  MOVLW  FA
1298:  MOVWF  x6F
129A:  RCALL  0ADA
129C:  BTFSC  19.7
129E:  BSF    FF2.7
12A0:  DECFSZ x65,F
12A2:  BRA    128E
12A4:  CLRF   19
12A6:  BTFSC  FF2.7
12A8:  BSF    19.7
12AA:  BCF    FF2.7
.................... beep(3,100); 
12AC:  MOVLW  03
12AE:  MOVWF  x6B
12B0:  MOVLW  64
12B2:  MOVWF  x6C
12B4:  RCALL  0B02
12B6:  BTFSC  19.7
12B8:  BSF    FF2.7
.................... setup_timer_2(T2_DIV_BY_16,250,1);      //401 us overflow, 401 us interrupt 
12BA:  MOVLW  00
12BC:  IORLW  06
12BE:  MOVWF  FCA
12C0:  MOVLW  FA
12C2:  MOVWF  FCB
.................... setup_ccp1 (ccp_pwm); 
12C4:  BCF    F8B.2
12C6:  MOVLW  0C
12C8:  MOVWF  FBD
.................... setup_ccp2 (ccp_pwm); 
12CA:  BCF    F8B.1
12CC:  MOVWF  FBA
....................  
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
12CE:  BSF    F80.2
12D0:  BSF    F80.0
12D2:  BSF    F80.1
12D4:  BSF    F84.0
12D6:  BSF    F80.5
.................... vancanh1=vancanh2=0; 
12D8:  BCF    F80.0
12DA:  BCF    F80.1
....................  
.................... chonpid=2; 
12DC:  MOVLW  02
12DE:  MOVWF  x60
.................... setvt2=230; 
12E0:  CLRF   55
12E2:  MOVLW  E6
12E4:  MOVWF  54
.................... enable_interrupts(int_timer1); 
12E6:  BSF    F9D.0
.................... while (En2<230) {} 
12E8:  BTFSC  21.7
12EA:  BRA    12F6
12EC:  MOVF   21,F
12EE:  BNZ   12F8
12F0:  MOVF   20,W
12F2:  SUBLW  E5
12F4:  BTFSC  FD8.0
12F6:  BRA    12E8
....................  
.................... chonpid=1; 
12F8:  MOVLW  01
12FA:  MOVWF  x60
.................... setvt1=280; 
12FC:  MOVWF  53
12FE:  MOVLW  18
1300:  MOVWF  52
.................... while (qei_get_count() <280) {} 
1302:  MOVFF  F67,01
1306:  MOVFF  F66,00
130A:  MOVFF  F67,03
130E:  MOVF   03,W
1310:  SUBWF  01,W
1312:  BZ    1318
1314:  MOVFF  F66,00
1318:  MOVF   00,W
131A:  MOVWF  x65
131C:  MOVFF  03,66
1320:  MOVF   x66,W
1322:  SUBLW  01
1324:  BNC   1330
1326:  BNZ   132E
1328:  MOVF   x65,W
132A:  SUBLW  17
132C:  BNC   1330
132E:  BRA    1302
....................  
.................... vantay1=vantay2=0; 
1330:  BCF    F84.0
1332:  BCF    F80.5
....................  
.................... while (ctsel==1) {} 
1334:  BTFSC  F81.7
1336:  BRA    1334
....................  
.................... vantay2=1; beep(1,100);  
1338:  BSF    F84.0
133A:  CLRF   19
133C:  BTFSC  FF2.7
133E:  BSF    19.7
1340:  BCF    FF2.7
1342:  MOVLW  01
1344:  MOVWF  x6B
1346:  MOVLW  64
1348:  MOVWF  x6C
134A:  CALL   0B02
134E:  BTFSC  19.7
1350:  BSF    FF2.7
....................  
.................... while (cten==1) {} 
1352:  BTFSC  F81.6
1354:  BRA    1352
.................... chonpid=2;  
1356:  MOVLW  02
1358:  MOVWF  x60
.................... setvt2=270; 
135A:  MOVLW  01
135C:  MOVWF  55
135E:  MOVLW  0E
1360:  MOVWF  54
.................... while (En2 <270) {}; 
1362:  BTFSC  21.7
1364:  BRA    1374
1366:  MOVF   21,W
1368:  SUBLW  01
136A:  BNC   1376
136C:  BNZ   1374
136E:  MOVF   20,W
1370:  SUBLW  0D
1372:  BTFSC  FD8.0
1374:  BRA    1362
.................... chonpid=0; 
1376:  CLRF   x60
1378:  CLRF   19
137A:  BTFSC  FF2.7
137C:  BSF    19.7
137E:  BCF    FF2.7
.................... delay_ms(100); 
1380:  MOVLW  64
1382:  MOVWF  x6F
1384:  CALL   0ADA
1388:  BTFSC  19.7
138A:  BSF    FF2.7
....................  
.................... dc2n(600); 
138C:  MOVLW  02
138E:  MOVWF  x66
1390:  MOVLW  58
1392:  MOVWF  x65
1394:  RCALL  0E2A
.................... for ( inv3x=0; inv3x < 6 ; inv3x++) 
1396:  CLRF   x63
1398:  MOVF   x63,W
139A:  SUBLW  05
139C:  BNC   13FE
.................... { 
.................... while (ctt1==1) {} ///*if ( En2>285 ) {resetdc2(); beep(10,100);}*/} 
139E:  BTFSC  F81.2
13A0:  BRA    139E
.................... if (ctt1==0) {vantay1=1; resetdc2(); } 
13A2:  BTFSC  F81.2
13A4:  BRA    13AC
13A6:  BSF    F80.5
13A8:  CALL   01C6
13AC:  CLRF   19
13AE:  BTFSC  FF2.7
13B0:  BSF    19.7
13B2:  BCF    FF2.7
.................... delay_ms(100); 
13B4:  MOVLW  64
13B6:  MOVWF  x6F
13B8:  CALL   0ADA
13BC:  BTFSC  19.7
13BE:  BSF    FF2.7
.................... if (ctt1==1) {vantay1=0; dc2t(300); delay_ms(400);resetdc2(); dc2n(600); } 
13C0:  BTFSS  F81.2
13C2:  BRA    13FA
13C4:  BCF    F80.5
13C6:  MOVLW  01
13C8:  MOVWF  x66
13CA:  MOVLW  2C
13CC:  MOVWF  x65
13CE:  RCALL  0C30
13D0:  MOVLW  02
13D2:  MOVWF  x65
13D4:  CLRF   19
13D6:  BTFSC  FF2.7
13D8:  BSF    19.7
13DA:  BCF    FF2.7
13DC:  MOVLW  C8
13DE:  MOVWF  x6F
13E0:  CALL   0ADA
13E4:  BTFSC  19.7
13E6:  BSF    FF2.7
13E8:  DECFSZ x65,F
13EA:  BRA    13D4
13EC:  CALL   01C6
13F0:  MOVLW  02
13F2:  MOVWF  x66
13F4:  MOVLW  58
13F6:  MOVWF  x65
13F8:  RCALL  0E2A
13FA:  INCF   x63,F
13FC:  BRA    1398
.................... } 
.................... vantay1=1; resetdc2(); 
13FE:  BSF    F80.5
1400:  CALL   01C6
....................  
.................... delay_ms(1000); 
1404:  MOVLW  04
1406:  MOVWF  x65
1408:  CLRF   19
140A:  BTFSC  FF2.7
140C:  BSF    19.7
140E:  BCF    FF2.7
1410:  MOVLW  FA
1412:  MOVWF  x6F
1414:  CALL   0ADA
1418:  BTFSC  19.7
141A:  BSF    FF2.7
141C:  DECFSZ x65,F
141E:  BRA    1408
.................... vantay2=0; 
1420:  BCF    F84.0
.................... chonpid=1; 
1422:  MOVLW  01
1424:  MOVWF  x60
.................... setvt1=0; 
1426:  CLRF   53
1428:  CLRF   52
.................... enable_interrupts(int_timer1); 
142A:  BSF    F9D.0
.................... while ( qei_get_count() >220) {} 
142C:  MOVFF  F67,01
1430:  MOVFF  F66,00
1434:  MOVFF  F67,03
1438:  MOVF   03,W
143A:  SUBWF  01,W
143C:  BZ    1442
143E:  MOVFF  F66,00
1442:  MOVF   00,W
1444:  MOVWF  x65
1446:  MOVFF  03,66
144A:  MOVF   x66,F
144C:  BNZ   1454
144E:  MOVF   x65,W
1450:  SUBLW  DC
1452:  BC    1456
1454:  BRA    142C
....................  
.................... setvt1=10; 
1456:  CLRF   53
1458:  MOVLW  0A
145A:  MOVWF  52
.................... setvt2=0; 
145C:  CLRF   55
145E:  CLRF   54
.................... chonpid=3; 
1460:  MOVLW  03
1462:  MOVWF  x60
.................... while ( qei_get_count() >10) {} 
1464:  MOVFF  F67,01
1468:  MOVFF  F66,00
146C:  MOVFF  F67,03
1470:  MOVF   03,W
1472:  SUBWF  01,W
1474:  BZ    147A
1476:  MOVFF  F66,00
147A:  MOVF   00,W
147C:  MOVWF  x65
147E:  MOVFF  03,66
1482:  MOVF   x66,F
1484:  BNZ   148C
1486:  MOVF   x65,W
1488:  SUBLW  0A
148A:  BC    148E
148C:  BRA    1464
.................... chonpid=0; 
148E:  CLRF   x60
1490:  CLRF   19
1492:  BTFSC  FF2.7
1494:  BSF    19.7
1496:  BCF    FF2.7
.................... delay_ms(100); 
1498:  MOVLW  64
149A:  MOVWF  x6F
149C:  CALL   0ADA
14A0:  BTFSC  19.7
14A2:  BSF    FF2.7
.................... dc1t(600); 
14A4:  MOVLW  02
14A6:  MOVWF  x66
14A8:  MOVLW  58
14AA:  MOVWF  x65
14AC:  CALL   0BEE
.................... for (inv3x=0; inv3x <6; inv3x++) 
14B0:  CLRF   x63
14B2:  MOVF   x63,W
14B4:  SUBLW  05
14B6:  BNC   151A
....................    { 
....................    while (ctt2==1) {} ///* if ( qei_get_count() <-5 ) {resetdc1(); beep(10,100);} */} 
14B8:  BTFSC  F81.0
14BA:  BRA    14B8
....................    if (ctt2==0) {vantay2=1;resetdc1(); } 
14BC:  BTFSC  F81.0
14BE:  BRA    14C6
14C0:  BSF    F84.0
14C2:  CALL   01A8
14C6:  CLRF   19
14C8:  BTFSC  FF2.7
14CA:  BSF    19.7
14CC:  BCF    FF2.7
....................    delay_ms(100); 
14CE:  MOVLW  64
14D0:  MOVWF  x6F
14D2:  CALL   0ADA
14D6:  BTFSC  19.7
14D8:  BSF    FF2.7
....................    if (ctt2==1) {vantay2=0; dc1n(300); delay_ms(400);resetdc1(); dc1t(600); } 
14DA:  BTFSS  F81.0
14DC:  BRA    1516
14DE:  BCF    F84.0
14E0:  MOVLW  01
14E2:  MOVWF  x66
14E4:  MOVLW  2C
14E6:  MOVWF  x65
14E8:  RCALL  0DE8
14EA:  MOVLW  02
14EC:  MOVWF  x65
14EE:  CLRF   19
14F0:  BTFSC  FF2.7
14F2:  BSF    19.7
14F4:  BCF    FF2.7
14F6:  MOVLW  C8
14F8:  MOVWF  x6F
14FA:  CALL   0ADA
14FE:  BTFSC  19.7
1500:  BSF    FF2.7
1502:  DECFSZ x65,F
1504:  BRA    14EE
1506:  CALL   01A8
150A:  MOVLW  02
150C:  MOVWF  x66
150E:  MOVLW  58
1510:  MOVWF  x65
1512:  CALL   0BEE
1516:  INCF   x63,F
1518:  BRA    14B2
....................    } 
.................... vantay2=1;resetdc1();  
151A:  BSF    F84.0
151C:  CALL   01A8
....................  
....................  
.................... delay_ms(1000); 
1520:  MOVLW  04
1522:  MOVWF  x65
1524:  CLRF   19
1526:  BTFSC  FF2.7
1528:  BSF    19.7
152A:  BCF    FF2.7
152C:  MOVLW  FA
152E:  MOVWF  x6F
1530:  CALL   0ADA
1534:  BTFSC  19.7
1536:  BSF    FF2.7
1538:  DECFSZ x65,F
153A:  BRA    1524
.................... vantay1=0; 
153C:  BCF    F80.5
.................... chonpid=2; 
153E:  MOVLW  02
1540:  MOVWF  x60
.................... setvt2=280; 
1542:  MOVLW  01
1544:  MOVWF  55
1546:  MOVLW  18
1548:  MOVWF  54
.................... enable_interrupts(int_timer1); 
154A:  BSF    F9D.0
.................... while (En2 < 50) {} 
154C:  BTFSC  21.7
154E:  BRA    155A
1550:  MOVF   21,F
1552:  BNZ   155C
1554:  MOVF   20,W
1556:  SUBLW  31
1558:  BTFSC  FD8.0
155A:  BRA    154C
.................... setvt1=280; 
155C:  MOVLW  01
155E:  MOVWF  53
1560:  MOVLW  18
1562:  MOVWF  52
.................... setvt2=270; 
1564:  MOVLW  01
1566:  MOVWF  55
1568:  MOVLW  0E
156A:  MOVWF  54
.................... chonpid=3; 
156C:  MOVLW  03
156E:  MOVWF  x60
.................... while (En2<270) {} 
1570:  BTFSC  21.7
1572:  BRA    1582
1574:  MOVF   21,W
1576:  SUBLW  01
1578:  BNC   1584
157A:  BNZ   1582
157C:  MOVF   20,W
157E:  SUBLW  0D
1580:  BTFSC  FD8.0
1582:  BRA    1570
.................... chonpid=0; 
1584:  CLRF   x60
1586:  CLRF   19
1588:  BTFSC  FF2.7
158A:  BSF    19.7
158C:  BCF    FF2.7
.................... delay_ms(100); 
158E:  MOVLW  64
1590:  MOVWF  x6F
1592:  CALL   0ADA
1596:  BTFSC  19.7
1598:  BSF    FF2.7
.................... dc2n(600); 
159A:  MOVLW  02
159C:  MOVWF  x66
159E:  MOVLW  58
15A0:  MOVWF  x65
15A2:  RCALL  0E2A
.................... for ( inv3x=0; inv3x < 6 ; inv3x++) 
15A4:  CLRF   x63
15A6:  MOVF   x63,W
15A8:  SUBLW  05
15AA:  BNC   1626
.................... { 
.................... while (ctt1==1) {} ///*if ( En2>285 ) {resetdc2(); beep(10,100);}*/ } 
15AC:  BTFSC  F81.2
15AE:  BRA    15AC
.................... if (ctt1==0) {vantay1=1; resetdc2(); beep(1,100); } 
15B0:  BTFSC  F81.2
15B2:  BRA    15D2
15B4:  BSF    F80.5
15B6:  CALL   01C6
15BA:  CLRF   19
15BC:  BTFSC  FF2.7
15BE:  BSF    19.7
15C0:  BCF    FF2.7
15C2:  MOVLW  01
15C4:  MOVWF  x6B
15C6:  MOVLW  64
15C8:  MOVWF  x6C
15CA:  CALL   0B02
15CE:  BTFSC  19.7
15D0:  BSF    FF2.7
15D2:  CLRF   19
15D4:  BTFSC  FF2.7
15D6:  BSF    19.7
15D8:  BCF    FF2.7
.................... delay_ms(30); 
15DA:  MOVLW  1E
15DC:  MOVWF  x6F
15DE:  CALL   0ADA
15E2:  BTFSC  19.7
15E4:  BSF    FF2.7
.................... if (ctt1==1) {vantay1=0; dc2t(300); delay_ms(400);resetdc2(); dc2n(600); } 
15E6:  BTFSS  F81.2
15E8:  BRA    1622
15EA:  BCF    F80.5
15EC:  MOVLW  01
15EE:  MOVWF  x66
15F0:  MOVLW  2C
15F2:  MOVWF  x65
15F4:  CALL   0C30
15F8:  MOVLW  02
15FA:  MOVWF  x65
15FC:  CLRF   19
15FE:  BTFSC  FF2.7
1600:  BSF    19.7
1602:  BCF    FF2.7
1604:  MOVLW  C8
1606:  MOVWF  x6F
1608:  CALL   0ADA
160C:  BTFSC  19.7
160E:  BSF    FF2.7
1610:  DECFSZ x65,F
1612:  BRA    15FC
1614:  CALL   01C6
1618:  MOVLW  02
161A:  MOVWF  x66
161C:  MOVLW  58
161E:  MOVWF  x65
1620:  RCALL  0E2A
1622:  INCF   x63,F
1624:  BRA    15A6
.................... } 
.................... vantay1=1; resetdc2(); 
1626:  BSF    F80.5
1628:  CALL   01C6
....................  
....................  
.................... delay_ms(1000); 
162C:  MOVLW  04
162E:  MOVWF  x65
1630:  CLRF   19
1632:  BTFSC  FF2.7
1634:  BSF    19.7
1636:  BCF    FF2.7
1638:  MOVLW  FA
163A:  MOVWF  x6F
163C:  CALL   0ADA
1640:  BTFSC  19.7
1642:  BSF    FF2.7
1644:  DECFSZ x65,F
1646:  BRA    1630
.................... vantay2=0; 
1648:  BCF    F84.0
.................... chonpid=1; 
164A:  MOVLW  01
164C:  MOVWF  x60
.................... setvt1=240; 
164E:  CLRF   53
1650:  MOVLW  F0
1652:  MOVWF  52
.................... enable_interrupts(int_timer1); 
1654:  BSF    F9D.0
.................... while ( qei_get_count() > 240) {} 
1656:  MOVFF  F67,01
165A:  MOVFF  F66,00
165E:  MOVFF  F67,03
1662:  MOVF   03,W
1664:  SUBWF  01,W
1666:  BZ    166C
1668:  MOVFF  F66,00
166C:  MOVF   00,W
166E:  MOVWF  x65
1670:  MOVFF  03,66
1674:  MOVF   x66,F
1676:  BNZ   167E
1678:  MOVF   x65,W
167A:  SUBLW  F0
167C:  BC    1680
167E:  BRA    1656
.................... chonpid=0; 
1680:  CLRF   x60
....................  
.................... while (cten==1) {} 
1682:  BTFSC  F81.6
1684:  BRA    1682
....................  
.................... while (ctsel==1) {} 
1686:  BTFSC  F81.7
1688:  BRA    1686
....................  
.................... vantay1=0; delay_ms(500);  
168A:  BCF    F80.5
168C:  MOVLW  02
168E:  MOVWF  x65
1690:  CLRF   19
1692:  BTFSC  FF2.7
1694:  BSF    19.7
1696:  BCF    FF2.7
1698:  MOVLW  FA
169A:  MOVWF  x6F
169C:  CALL   0ADA
16A0:  BTFSC  19.7
16A2:  BSF    FF2.7
16A4:  DECFSZ x65,F
16A6:  BRA    1690
....................  
.................... while (ctsel==1) {} 
16A8:  BTFSC  F81.7
16AA:  BRA    16A8
....................  
.................... resetvan(); 
16AC:  CALL   0C72
....................  
.................... demct=200; 
16B0:  MOVLW  C8
16B2:  MOVWF  5A
.................... enable_interrupts(int_timer5); 
16B4:  BSF    FA3.0
16B6:  GOTO   198C (RETURN)
....................  
.................... } 
.................... /* 
.................... void nhiemvu3xdan() 
.................... { 
.................... delay_ms(1000); 
.................... beep(3,100); 
.................... setup_timer_2(T2_DIV_BY_16,250,1);      //401 us overflow, 401 us interrupt 
.................... setup_ccp1 (ccp_pwm); 
.................... setup_ccp2 (ccp_pwm); 
....................  
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
.................... vancanh1=vancanh2=0; 
....................  
.................... chonpid=2; 
.................... setvt2=280; 
.................... enable_interrupts(int_timer1); 
.................... while (En2<280) {} 
....................  
.................... chonpid=1; 
.................... setvt1=280; 
.................... while (qei_get_count() <280) {} 
....................  
.................... chonpid=0; 
.................... vantay1=vantay2=0; 
....................  
.................... while (ctsel==1) {} 
....................  
.................... vantay1=1; 
.................... vantay2=1; beep(1,100);  
....................  
.................... while (cten==1) {} 
....................  
.................... while (ctsel==1) {} 
.................... while (cten==1) {} 
....................  
.................... } 
....................  
.................... */ 
....................  
.................... #include <nhiemvu4.c> 
....................  
.................... ///// NHIEM VU 4 
....................  
....................  
.................... void nhiemvu4() 
.................... { 
....................  
.................... int8 inv4; 
.................... delay_ms(1000); 
16BA:  MOVLW  04
16BC:  MOVWF  x66
16BE:  CLRF   19
16C0:  BTFSC  FF2.7
16C2:  BSF    19.7
16C4:  BCF    FF2.7
16C6:  MOVLW  FA
16C8:  MOVWF  x6F
16CA:  CALL   0ADA
16CE:  BTFSC  19.7
16D0:  BSF    FF2.7
16D2:  DECFSZ x66,F
16D4:  BRA    16BE
16D6:  CLRF   19
16D8:  BTFSC  FF2.7
16DA:  BSF    19.7
16DC:  BCF    FF2.7
.................... beep(4,100); 
16DE:  MOVLW  04
16E0:  MOVWF  x6B
16E2:  MOVLW  64
16E4:  MOVWF  x6C
16E6:  CALL   0B02
16EA:  BTFSC  19.7
16EC:  BSF    FF2.7
....................  
.................... trispwm3=trisdir3=0; 
16EE:  BCF    F95.5
16F0:  BCF    F95.6
.................... pwm3=dir3=1; 
16F2:  BSF    F83.5
16F4:  BSF    F83.6
.................... while (cten==1) {} 
16F6:  BTFSC  F81.6
16F8:  BRA    16F6
16FA:  CLRF   19
16FC:  BTFSC  FF2.7
16FE:  BSF    19.7
1700:  BCF    FF2.7
.................... delay_ms(100); 
1702:  MOVLW  64
1704:  MOVWF  x6F
1706:  CALL   0ADA
170A:  BTFSC  19.7
170C:  BSF    FF2.7
....................  
.................... dclep=1; 
170E:  BSF    5D.0
.................... enable_interrupts(int_timer0); 
1710:  BSF    FF2.5
.................... vanduoi=0;    
1712:  BCF    F80.2
.................... while (ctld==1) 
1714:  BTFSS  F81.4
1716:  BRA    1720
....................    { 
....................    dir3=0; 
1718:  BCF    F83.5
....................    xungleo=80; 
171A:  MOVLW  50
171C:  MOVWF  5C
171E:  BRA    1714
....................     
....................    }  
.................... dir3=1; 
1720:  BSF    F83.5
.................... xungleo=0; 
1722:  CLRF   5C
1724:  CLRF   19
1726:  BTFSC  FF2.7
1728:  BSF    19.7
172A:  BCF    FF2.7
.................... beep(1,100); 
172C:  MOVLW  01
172E:  MOVWF  x6B
1730:  MOVLW  64
1732:  MOVWF  x6C
1734:  CALL   0B02
1738:  BTFSC  19.7
173A:  BSF    FF2.7
....................  
.................... for (inv4=0; inv4 < 3; inv4++)    /// 4 lan la ok 
173C:  CLRF   x65
173E:  MOVF   x65,W
1740:  SUBLW  02
1742:  BNC   1798
....................  { 
....................    while (ctlt==1) 
1744:  BTFSS  F81.5
1746:  BRA    1750
....................       { 
....................       dir3=1; 
1748:  BSF    F83.5
....................       xungleo=80; 
174A:  MOVLW  50
174C:  MOVWF  5C
174E:  BRA    1744
....................       } 
....................    dir3=0;    
1750:  BCF    F83.5
....................    xungleo=0; 
1752:  CLRF   5C
1754:  CLRF   19
1756:  BTFSC  FF2.7
1758:  BSF    19.7
175A:  BCF    FF2.7
....................    beep(1,100); 
175C:  MOVLW  01
175E:  MOVWF  x6B
1760:  MOVLW  64
1762:  MOVWF  x6C
1764:  CALL   0B02
1768:  BTFSC  19.7
176A:  BSF    FF2.7
....................  
....................    while (ctld==1) 
176C:  BTFSS  F81.4
176E:  BRA    1778
....................       { 
....................       dir3=0; 
1770:  BCF    F83.5
....................       xungleo=85; 
1772:  MOVLW  55
1774:  MOVWF  5C
1776:  BRA    176C
....................       } 
....................    dir3=1;    
1778:  BSF    F83.5
....................    xungleo=0; 
177A:  CLRF   5C
177C:  CLRF   19
177E:  BTFSC  FF2.7
1780:  BSF    19.7
1782:  BCF    FF2.7
....................    beep(1,100); 
1784:  MOVLW  01
1786:  MOVWF  x6B
1788:  MOVLW  64
178A:  MOVWF  x6C
178C:  CALL   0B02
1790:  BTFSC  19.7
1792:  BSF    FF2.7
1794:  INCF   x65,F
1796:  BRA    173E
....................  } 
....................   
....................  //delay_ms(1000); 
....................  /////////////////////delay nga robot 
....................  while (ctlt==1) 
1798:  BTFSS  F81.5
179A:  BRA    17A4
....................       { 
....................       dir3=1; 
179C:  BSF    F83.5
....................       xungleo=80; 
179E:  MOVLW  50
17A0:  MOVWF  5C
17A2:  BRA    1798
....................       } 
....................    dir3=0;    
17A4:  BCF    F83.5
....................    xungleo=0; 
17A6:  CLRF   5C
17A8:  CLRF   19
17AA:  BTFSC  FF2.7
17AC:  BSF    19.7
17AE:  BCF    FF2.7
....................    beep(1,100); 
17B0:  MOVLW  01
17B2:  MOVWF  x6B
17B4:  MOVLW  64
17B6:  MOVWF  x6C
17B8:  CALL   0B02
17BC:  BTFSC  19.7
17BE:  BSF    FF2.7
....................  
....................    while (ctld==1) 
17C0:  BTFSS  F81.4
17C2:  BRA    17CC
....................       { 
....................       dir3=0; 
17C4:  BCF    F83.5
....................       xungleo=85; 
17C6:  MOVLW  55
17C8:  MOVWF  5C
17CA:  BRA    17C0
....................       } 
....................    dir3=1;    
17CC:  BSF    F83.5
....................    xungleo=0; 
17CE:  CLRF   5C
17D0:  CLRF   19
17D2:  BTFSC  FF2.7
17D4:  BSF    19.7
17D6:  BCF    FF2.7
....................    beep(1,100); 
17D8:  MOVLW  01
17DA:  MOVWF  x6B
17DC:  MOVLW  64
17DE:  MOVWF  x6C
17E0:  CALL   0B02
17E4:  BTFSC  19.7
17E6:  BSF    FF2.7
....................   
....................   
....................  
.................... while (ctlt==1) 
17E8:  BTFSS  F81.5
17EA:  BRA    17F4
....................       { 
....................       dir3=1; 
17EC:  BSF    F83.5
....................       xungleo=80; 
17EE:  MOVLW  50
17F0:  MOVWF  5C
17F2:  BRA    17E8
....................       } 
....................    dir3=0;    
17F4:  BCF    F83.5
....................    xungleo=0; 
17F6:  CLRF   5C
17F8:  CLRF   19
17FA:  BTFSC  FF2.7
17FC:  BSF    19.7
17FE:  BCF    FF2.7
....................    beep(1,100); 
1800:  MOVLW  01
1802:  MOVWF  x6B
1804:  MOVLW  64
1806:  MOVWF  x6C
1808:  CALL   0B02
180C:  BTFSC  19.7
180E:  BSF    FF2.7
....................     
.................... while (ctlt==0) 
1810:  BTFSC  F81.5
1812:  BRA    181C
....................    { 
....................    dir3=0;  
1814:  BCF    F83.5
....................    xungleo=60; 
1816:  MOVLW  3C
1818:  MOVWF  5C
181A:  BRA    1810
....................    } 
....................    xungleo=0; 
181C:  CLRF   5C
181E:  CLRF   19
1820:  BTFSC  FF2.7
1822:  BSF    19.7
1824:  BCF    FF2.7
....................    beep(1,100); 
1826:  MOVLW  01
1828:  MOVWF  x6B
182A:  MOVLW  64
182C:  MOVWF  x6C
182E:  CALL   0B02
1832:  BTFSC  19.7
1834:  BSF    FF2.7
....................   
.................... vanduoi=1; 
1836:  BSF    F80.2
.................... pwm3=1; 
1838:  BSF    F83.6
.................... dir3=1; 
183A:  BSF    F83.5
.................... dclep=0; 
183C:  BCF    5D.0
.................... xungleo=10; 
183E:  MOVLW  0A
1840:  MOVWF  5C
.................... while (cten==1) { } 
1842:  BTFSC  F81.6
1844:  BRA    1842
.................... disable_interrupts(int_timer0); 
1846:  BCF    FF2.5
....................  
.................... demct=200; 
1848:  MOVLW  C8
184A:  MOVWF  5A
.................... enable_interrupts(int_timer5); 
184C:  BSF    FA3.0
184E:  GOTO   19B2 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... ///// MAIN ///// 
.................... int8 i=0; 
....................  
.................... void main() 
1852:  CLRF   FF8
1854:  BCF    FD0.7
1856:  BSF    07.7
1858:  CLRF   25
185A:  CLRF   24
185C:  CLRF   23
185E:  MOVLW  80
1860:  MOVWF  22
1862:  MOVLW  CD
1864:  MOVWF  29
1866:  MOVLW  CC
1868:  MOVWF  28
186A:  MOVLW  4C
186C:  MOVWF  27
186E:  MOVLW  7C
1870:  MOVWF  26
1872:  MOVLW  33
1874:  MOVWF  2D
1876:  MOVWF  2C
1878:  MOVWF  2B
187A:  MOVLW  7E
187C:  MOVWF  2A
187E:  CLRF   39
1880:  CLRF   38
1882:  CLRF   3B
1884:  CLRF   3A
1886:  CLRF   3D
1888:  CLRF   3C
188A:  CLRF   3F
188C:  CLRF   3E
188E:  CLRF   45
1890:  CLRF   44
1892:  CLRF   47
1894:  CLRF   46
1896:  CLRF   49
1898:  CLRF   48
189A:  CLRF   4B
189C:  CLRF   4A
189E:  MOVLW  03
18A0:  MOVWF  57
18A2:  MOVLW  84
18A4:  MOVWF  56
18A6:  MOVLW  03
18A8:  MOVWF  59
18AA:  MOVLW  84
18AC:  MOVWF  58
18AE:  CLRF   5A
18B0:  CLRF   5B
18B2:  MOVLW  64
18B4:  MOVWF  5C
18B6:  BCF    5D.0
18B8:  CLRF   5F
18BA:  CLRF   5E
18BC:  MOVLW  04
18BE:  MOVWF  x60
18C0:  CLRF   x61
18C2:  CLRF   x62
18C4:  CLRF   x63
18C6:  CLRF   x64
18C8:  BCF    FB9.0
18CA:  BCF    FC1.6
18CC:  BCF    FC1.7
18CE:  MOVLW  00
18D0:  MOVWF  FB8
18D2:  CLRF   1A
18D4:  CLRF   1B
.................... { 
....................    khoidong();  
18D6:  GOTO   0B80
....................    En2=0; 
18DA:  CLRF   21
18DC:  CLRF   20
....................    Ti1=0; 
18DE:  CLRF   4F
18E0:  CLRF   4E
....................    Ti2=0; 
18E2:  CLRF   51
18E4:  CLRF   50
....................    setvt1=0; 
18E6:  CLRF   53
18E8:  CLRF   52
....................    setvt2=0; 
18EA:  CLRF   55
18EC:  CLRF   54
18EE:  CLRF   19
18F0:  BTFSC  FF2.7
18F2:  BSF    19.7
18F4:  BCF    FF2.7
....................    beep(2,100);  
18F6:  MOVLW  02
18F8:  MOVWF  x6B
18FA:  MOVLW  64
18FC:  MOVWF  x6C
18FE:  CALL   0B02
1902:  BTFSC  19.7
1904:  BSF    FF2.7
....................    
.................... while(true) 
....................    { 
....................     
....................    if (ctsel==0)  
1906:  BTFSC  F81.7
1908:  BRA    192A
....................       { 
....................       enable_interrupts(int_timer5); 
190A:  BSF    FA3.0
....................       demct=0; i=1; delay_ms(10);  
190C:  CLRF   5A
190E:  MOVLW  01
1910:  MOVWF  x64
1912:  CLRF   19
1914:  BTFSC  FF2.7
1916:  BSF    19.7
1918:  BCF    FF2.7
191A:  MOVLW  0A
191C:  MOVWF  x6F
191E:  CALL   0ADA
1922:  BTFSC  19.7
1924:  BSF    FF2.7
....................       while (ctsel==0) {} 
1926:  BTFSS  F81.7
1928:  BRA    1926
....................       } 
....................        
....................    while (i==1)  
192A:  DECFSZ x64,W
192C:  BRA    19B4
....................       { 
....................       if ( demct<50 ) {disable_interrupts(int_timer5); i=0; demct=0;  resetvan(); } 
192E:  MOVF   5A,W
1930:  SUBLW  31
1932:  BNC   193E
1934:  BCF    FA3.0
1936:  CLRF   x64
1938:  CLRF   5A
193A:  CALL   0C72
....................       if ((50<demct)&(demct<100)) {disable_interrupts(int_timer5); i=0; demct=0; nhiemvu3(); }  
193E:  MOVF   5A,W
1940:  SUBLW  32
1942:  BNC   1948
1944:  MOVLW  00
1946:  BRA    194A
1948:  MOVLW  01
194A:  MOVWF  x65
194C:  MOVF   5A,W
194E:  SUBLW  63
1950:  BC    1956
1952:  MOVLW  00
1954:  BRA    1958
1956:  MOVLW  01
1958:  ANDWF  x65,W
195A:  BZ    1966
195C:  BCF    FA3.0
195E:  CLRF   x64
1960:  CLRF   5A
1962:  GOTO   0E6C
....................       if ((100<demct)&(demct<150)) {disable_interrupts(int_timer5); i=0; demct=0; nhiemvu3x(); } 
1966:  MOVF   5A,W
1968:  SUBLW  64
196A:  BNC   1970
196C:  MOVLW  00
196E:  BRA    1972
1970:  MOVLW  01
1972:  MOVWF  x65
1974:  MOVF   5A,W
1976:  SUBLW  95
1978:  BC    197E
197A:  MOVLW  00
197C:  BRA    1980
197E:  MOVLW  01
1980:  ANDWF  x65,W
1982:  BZ    198C
1984:  BCF    FA3.0
1986:  CLRF   x64
1988:  CLRF   5A
198A:  BRA    128A
....................       if ((150<demct)&(demct<200)) {disable_interrupts(int_timer5); i=0; demct=0; nhiemvu4(); } 
198C:  MOVF   5A,W
198E:  SUBLW  96
1990:  BNC   1996
1992:  MOVLW  00
1994:  BRA    1998
1996:  MOVLW  01
1998:  MOVWF  x65
199A:  MOVF   5A,W
199C:  SUBLW  C7
199E:  BC    19A4
19A0:  MOVLW  00
19A2:  BRA    19A6
19A4:  MOVLW  01
19A6:  ANDWF  x65,W
19A8:  BZ    19B2
19AA:  BCF    FA3.0
19AC:  CLRF   x64
19AE:  CLRF   5A
19B0:  BRA    16BA
19B2:  BRA    192A
....................       } 
19B4:  BRA    1906
....................      
....................    } 
.................... } 
....................  
19B6:  SLEEP 
....................  

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 3E0C   PUT NOBROWNOUT BORV20 NOWDT WDT32768 NOWINEN
   Word  3: 9D3C   NOPWMPIN LPOL_HIGH HPOL_HIGH T1LOWPOWER FLTAC1 SSP_RC PWM4B5 EXCLKC3 MCLR
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
