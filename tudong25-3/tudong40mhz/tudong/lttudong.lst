CCS PCH C Compiler, Version 5.015, 41519               26-Mar-14 01:07

               Filename:   F:\Robocon 2014\Lap trinh design\LAP TRINH ROBOT TU DONG\tudong25-3\tudong40mhz\tudong\lttudong.lst

               ROM used:   4646 bytes (28%)
                           Largest free fragment is 11734
               RAM used:   92 (12%) at main() level
                           124 (16%) worst case
               Stack used: 6 locations (3 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   10F8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   014E
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   09C2
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   00C6
006C:  BTFSS  FF0.4
006E:  GOTO   0078
0072:  BTFSC  FF0.1
0074:  GOTO   010A
0078:  BTFSS  FA3.0
007A:  GOTO   0084
007E:  BTFSC  FA4.0
0080:  GOTO   0A44
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
....................  
.................... ///// CHUONG TRINH CHINH 
.................... #include <khoidong.c> 
....................  
.................... ///// KHOI DONG PIC 
....................  
.................... #include <18F4431.h> 
.................... //////////// Standard Header file for the PIC18F4431 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4431 
*
016E:  MOVLW  8E
0170:  MOVWF  00
0172:  MOVFF  6D,01
0176:  MOVFF  6C,02
017A:  CLRF   03
017C:  BTFSS  x6D.7
017E:  BRA    018A
0180:  COMF   01,F
0182:  COMF   02,F
0184:  INCF   02,F
0186:  BNZ   018A
0188:  INCF   01,F
018A:  MOVF   01,F
018C:  BNZ   01A0
018E:  MOVFF  02,01
0192:  CLRF   02
0194:  MOVLW  08
0196:  SUBWF  00,F
0198:  MOVF   01,F
019A:  BNZ   01A0
019C:  CLRF   00
019E:  BRA    01B4
01A0:  BCF    FD8.0
01A2:  BTFSC  01.7
01A4:  BRA    01AE
01A6:  RLCF   02,F
01A8:  RLCF   01,F
01AA:  DECF   00,F
01AC:  BRA    01A0
01AE:  BTFSC  x6D.7
01B0:  BRA    01B4
01B2:  BCF    01.7
01B4:  RETURN 0
01B6:  MOVF   x6C,W
01B8:  BTFSC  FD8.2
01BA:  BRA    029E
01BC:  MOVWF  00
01BE:  MOVF   x70,W
01C0:  BTFSC  FD8.2
01C2:  BRA    029E
01C4:  ADDWF  00,F
01C6:  BNC   01D0
01C8:  MOVLW  81
01CA:  ADDWF  00,F
01CC:  BC    029E
01CE:  BRA    01D8
01D0:  MOVLW  7F
01D2:  SUBWF  00,F
01D4:  BNC   029E
01D6:  BZ    029E
01D8:  MOVFF  6D,74
01DC:  MOVF   x71,W
01DE:  XORWF  x74,F
01E0:  BSF    x6D.7
01E2:  BSF    x71.7
01E4:  MOVF   x6F,W
01E6:  MULWF  x73
01E8:  MOVFF  FF4,76
01EC:  MOVF   x6E,W
01EE:  MULWF  x72
01F0:  MOVFF  FF4,03
01F4:  MOVFF  FF3,75
01F8:  MULWF  x73
01FA:  MOVF   FF3,W
01FC:  ADDWF  x76,F
01FE:  MOVF   FF4,W
0200:  ADDWFC x75,F
0202:  MOVLW  00
0204:  ADDWFC 03,F
0206:  MOVF   x6F,W
0208:  MULWF  x72
020A:  MOVF   FF3,W
020C:  ADDWF  x76,F
020E:  MOVF   FF4,W
0210:  ADDWFC x75,F
0212:  MOVLW  00
0214:  CLRF   02
0216:  ADDWFC 03,F
0218:  ADDWFC 02,F
021A:  MOVF   x6D,W
021C:  MULWF  x73
021E:  MOVF   FF3,W
0220:  ADDWF  x75,F
0222:  MOVF   FF4,W
0224:  ADDWFC 03,F
0226:  MOVLW  00
0228:  ADDWFC 02,F
022A:  MOVF   x6D,W
022C:  MULWF  x72
022E:  MOVF   FF3,W
0230:  ADDWF  03,F
0232:  MOVF   FF4,W
0234:  ADDWFC 02,F
0236:  MOVLW  00
0238:  CLRF   01
023A:  ADDWFC 01,F
023C:  MOVF   x6F,W
023E:  MULWF  x71
0240:  MOVF   FF3,W
0242:  ADDWF  x75,F
0244:  MOVF   FF4,W
0246:  ADDWFC 03,F
0248:  MOVLW  00
024A:  ADDWFC 02,F
024C:  ADDWFC 01,F
024E:  MOVF   x6E,W
0250:  MULWF  x71
0252:  MOVF   FF3,W
0254:  ADDWF  03,F
0256:  MOVF   FF4,W
0258:  ADDWFC 02,F
025A:  MOVLW  00
025C:  ADDWFC 01,F
025E:  MOVF   x6D,W
0260:  MULWF  x71
0262:  MOVF   FF3,W
0264:  ADDWF  02,F
0266:  MOVF   FF4,W
0268:  ADDWFC 01,F
026A:  INCF   00,F
026C:  BTFSC  01.7
026E:  BRA    027A
0270:  RLCF   x75,F
0272:  RLCF   03,F
0274:  RLCF   02,F
0276:  RLCF   01,F
0278:  DECF   00,F
027A:  MOVLW  00
027C:  BTFSS  x75.7
027E:  BRA    0294
0280:  INCF   03,F
0282:  ADDWFC 02,F
0284:  ADDWFC 01,F
0286:  MOVF   01,W
0288:  BNZ   0294
028A:  MOVF   02,W
028C:  BNZ   0294
028E:  MOVF   03,W
0290:  BNZ   0294
0292:  INCF   00,F
0294:  BTFSC  x74.7
0296:  BSF    01.7
0298:  BTFSS  x74.7
029A:  BCF    01.7
029C:  BRA    02A6
029E:  CLRF   00
02A0:  CLRF   01
02A2:  CLRF   02
02A4:  CLRF   03
02A6:  RETURN 0
02A8:  MOVLW  80
02AA:  BTFSC  FD8.1
02AC:  XORWF  x71,F
02AE:  CLRF   x76
02B0:  CLRF   x77
02B2:  MOVFF  6D,75
02B6:  MOVF   x71,W
02B8:  XORWF  x75,F
02BA:  MOVF   x6C,W
02BC:  BTFSC  FD8.2
02BE:  BRA    0478
02C0:  MOVWF  x74
02C2:  MOVWF  00
02C4:  MOVF   x70,W
02C6:  BTFSC  FD8.2
02C8:  BRA    048A
02CA:  SUBWF  x74,F
02CC:  BTFSC  FD8.2
02CE:  BRA    03D2
02D0:  BNC   034C
02D2:  MOVFF  71,7A
02D6:  BSF    x7A.7
02D8:  MOVFF  72,79
02DC:  MOVFF  73,78
02E0:  CLRF   x77
02E2:  BCF    FD8.0
02E4:  RRCF   x7A,F
02E6:  RRCF   x79,F
02E8:  RRCF   x78,F
02EA:  RRCF   x77,F
02EC:  DECFSZ x74,F
02EE:  BRA    02E0
02F0:  BTFSS  x75.7
02F2:  BRA    02FA
02F4:  BSF    x76.0
02F6:  BRA    04B2
02F8:  BCF    x76.0
02FA:  BCF    x74.0
02FC:  BSF    x76.4
02FE:  CLRF   FEA
0300:  MOVLW  6F
0302:  MOVWF  FE9
0304:  BRA    04D8
0306:  BCF    x76.4
0308:  BTFSC  x75.7
030A:  BRA    0320
030C:  BTFSS  x74.0
030E:  BRA    0336
0310:  RRCF   x7A,F
0312:  RRCF   x79,F
0314:  RRCF   x78,F
0316:  RRCF   x77,F
0318:  INCF   00,F
031A:  BTFSC  FD8.2
031C:  BRA    04A8
031E:  BRA    0336
0320:  BTFSC  x7A.7
0322:  BRA    033C
0324:  BCF    FD8.0
0326:  RLCF   x77,F
0328:  RLCF   x78,F
032A:  RLCF   x79,F
032C:  RLCF   x7A,F
032E:  DECF   00,F
0330:  BTFSC  FD8.2
0332:  BRA    04A8
0334:  BRA    0320
0336:  BSF    x76.6
0338:  BRA    0410
033A:  BCF    x76.6
033C:  MOVFF  6D,75
0340:  BTFSS  x6D.7
0342:  BRA    0348
0344:  BSF    x7A.7
0346:  BRA    049A
0348:  BCF    x7A.7
034A:  BRA    049A
034C:  MOVFF  70,74
0350:  MOVFF  70,00
0354:  MOVF   x6C,W
0356:  SUBWF  x74,F
0358:  MOVFF  6D,7A
035C:  BSF    x7A.7
035E:  MOVFF  6E,79
0362:  MOVFF  6F,78
0366:  CLRF   x77
0368:  BCF    FD8.0
036A:  RRCF   x7A,F
036C:  RRCF   x79,F
036E:  RRCF   x78,F
0370:  RRCF   x77,F
0372:  DECFSZ x74,F
0374:  BRA    0366
0376:  BTFSS  x75.7
0378:  BRA    0380
037A:  BSF    x76.1
037C:  BRA    04B2
037E:  BCF    x76.1
0380:  BCF    x74.0
0382:  BSF    x76.5
0384:  CLRF   FEA
0386:  MOVLW  73
0388:  MOVWF  FE9
038A:  BRA    04D8
038C:  BCF    x76.5
038E:  BTFSC  x75.7
0390:  BRA    03A6
0392:  BTFSS  x74.0
0394:  BRA    03BC
0396:  RRCF   x7A,F
0398:  RRCF   x79,F
039A:  RRCF   x78,F
039C:  RRCF   x77,F
039E:  INCF   00,F
03A0:  BTFSC  FD8.2
03A2:  BRA    04A8
03A4:  BRA    03BC
03A6:  BTFSC  x7A.7
03A8:  BRA    03C2
03AA:  BCF    FD8.0
03AC:  RLCF   x77,F
03AE:  RLCF   x78,F
03B0:  RLCF   x79,F
03B2:  RLCF   x7A,F
03B4:  DECF   00,F
03B6:  BTFSC  FD8.2
03B8:  BRA    04A8
03BA:  BRA    03A6
03BC:  BSF    x76.7
03BE:  BRA    0410
03C0:  BCF    x76.7
03C2:  MOVFF  71,75
03C6:  BTFSS  x71.7
03C8:  BRA    03CE
03CA:  BSF    x7A.7
03CC:  BRA    049A
03CE:  BCF    x7A.7
03D0:  BRA    049A
03D2:  MOVFF  71,7A
03D6:  BSF    x7A.7
03D8:  MOVFF  72,79
03DC:  MOVFF  73,78
03E0:  BTFSS  x75.7
03E2:  BRA    03EC
03E4:  BCF    x7A.7
03E6:  BSF    x76.2
03E8:  BRA    04B2
03EA:  BCF    x76.2
03EC:  CLRF   x77
03EE:  BCF    x74.0
03F0:  CLRF   FEA
03F2:  MOVLW  6F
03F4:  MOVWF  FE9
03F6:  BRA    04D8
03F8:  BTFSC  x75.7
03FA:  BRA    0434
03FC:  MOVFF  6D,75
0400:  BTFSS  x74.0
0402:  BRA    0410
0404:  RRCF   x7A,F
0406:  RRCF   x79,F
0408:  RRCF   x78,F
040A:  RRCF   x77,F
040C:  INCF   00,F
040E:  BZ    04A8
0410:  BTFSS  x77.7
0412:  BRA    042A
0414:  INCF   x78,F
0416:  BNZ   042A
0418:  INCF   x79,F
041A:  BNZ   042A
041C:  INCF   x7A,F
041E:  BNZ   042A
0420:  RRCF   x7A,F
0422:  RRCF   x79,F
0424:  RRCF   x78,F
0426:  INCF   00,F
0428:  BZ    04A8
042A:  BTFSC  x76.6
042C:  BRA    033A
042E:  BTFSC  x76.7
0430:  BRA    03C0
0432:  BRA    046C
0434:  MOVLW  80
0436:  XORWF  x7A,F
0438:  BTFSS  x7A.7
043A:  BRA    0444
043C:  BRA    04B2
043E:  MOVFF  71,75
0442:  BRA    0458
0444:  MOVFF  6D,75
0448:  MOVF   x7A,F
044A:  BNZ   0458
044C:  MOVF   x79,F
044E:  BNZ   0458
0450:  MOVF   x78,F
0452:  BNZ   0458
0454:  CLRF   00
0456:  BRA    049A
0458:  BTFSC  x7A.7
045A:  BRA    046C
045C:  BCF    FD8.0
045E:  RLCF   x77,F
0460:  RLCF   x78,F
0462:  RLCF   x79,F
0464:  RLCF   x7A,F
0466:  DECFSZ 00,F
0468:  BRA    0458
046A:  BRA    04A8
046C:  BTFSS  x75.7
046E:  BRA    0474
0470:  BSF    x7A.7
0472:  BRA    049A
0474:  BCF    x7A.7
0476:  BRA    049A
0478:  MOVFF  70,00
047C:  MOVFF  71,7A
0480:  MOVFF  72,79
0484:  MOVFF  73,78
0488:  BRA    049A
048A:  MOVFF  6C,00
048E:  MOVFF  6D,7A
0492:  MOVFF  6E,79
0496:  MOVFF  6F,78
049A:  MOVFF  7A,01
049E:  MOVFF  79,02
04A2:  MOVFF  78,03
04A6:  BRA    0510
04A8:  CLRF   00
04AA:  CLRF   01
04AC:  CLRF   02
04AE:  CLRF   03
04B0:  BRA    0510
04B2:  CLRF   x77
04B4:  COMF   x78,F
04B6:  COMF   x79,F
04B8:  COMF   x7A,F
04BA:  COMF   x77,F
04BC:  INCF   x77,F
04BE:  BNZ   04CA
04C0:  INCF   x78,F
04C2:  BNZ   04CA
04C4:  INCF   x79,F
04C6:  BNZ   04CA
04C8:  INCF   x7A,F
04CA:  BTFSC  x76.0
04CC:  BRA    02F8
04CE:  BTFSC  x76.1
04D0:  BRA    037E
04D2:  BTFSC  x76.2
04D4:  BRA    03EA
04D6:  BRA    043E
04D8:  MOVF   FEF,W
04DA:  ADDWF  x78,F
04DC:  BNC   04E8
04DE:  INCF   x79,F
04E0:  BNZ   04E8
04E2:  INCF   x7A,F
04E4:  BTFSC  FD8.2
04E6:  BSF    x74.0
04E8:  MOVF   FED,F
04EA:  MOVF   FEF,W
04EC:  ADDWF  x79,F
04EE:  BNC   04F6
04F0:  INCF   x7A,F
04F2:  BTFSC  FD8.2
04F4:  BSF    x74.0
04F6:  MOVF   FED,F
04F8:  MOVF   FEF,W
04FA:  BTFSC  FEF.7
04FC:  BRA    0500
04FE:  XORLW  80
0500:  ADDWF  x7A,F
0502:  BTFSC  FD8.0
0504:  BSF    x74.0
0506:  BTFSC  x76.4
0508:  BRA    0306
050A:  BTFSC  x76.5
050C:  BRA    038C
050E:  BRA    03F8
0510:  RETURN 0
0512:  MOVLW  8E
0514:  MOVWF  00
0516:  MOVF   x68,W
0518:  SUBWF  00,F
051A:  MOVFF  69,02
051E:  MOVFF  6A,01
0522:  BSF    02.7
0524:  MOVF   00,F
0526:  BZ    053A
0528:  BCF    FD8.0
052A:  MOVF   02,F
052C:  BNZ   0532
052E:  MOVF   01,F
0530:  BZ    053A
0532:  RRCF   02,F
0534:  RRCF   01,F
0536:  DECFSZ 00,F
0538:  BRA    0528
053A:  BTFSS  x69.7
053C:  BRA    0548
053E:  COMF   01,F
0540:  COMF   02,F
0542:  INCF   01,F
0544:  BTFSC  FD8.2
0546:  INCF   02,F
0548:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <PIC18F4431_registers.h> 
.................... #byte TOSU = 0xFFF 
.................... #word TOS = 0xFFE 
.................... #byte STKPTR = 0xFFC 
.................... #bit    STKOVF = STKPTR.7 
.................... #byte STKPTR = 0xFFC 
.................... #bit    STKPTR0 = STKPTR.0 
.................... #bit    STKPTR1 = STKPTR.1 
.................... #bit    STKPTR2 = STKPTR.2 
.................... #bit    STKPTR3 = STKPTR.3 
.................... #bit    STKPTR4 = STKPTR.4 
.................... #bit    STKUNF = STKPTR.6 
.................... #bit    STKFUL = STKPTR.7 
.................... #byte PCLATU = 0xFFB 
.................... #byte PCLATH = 0xFFA 
.................... #byte PCL = 0xFF9 
.................... #byte TBLPTRU = 0xFF8 
.................... #bit    TBLPTRU0 = TBLPTRU.0 
.................... #bit    TBLPTRU1 = TBLPTRU.1 
.................... #bit    TBLPTRU2 = TBLPTRU.2 
.................... #bit    TBLPTRU3 = TBLPTRU.3 
.................... #bit    TBLPTRU4 = TBLPTRU.4 
.................... #bit    ACSS = TBLPTRU.5 
.................... #word TBLPTR = 0xFF7 
.................... #byte TABLAT = 0xFF5 
.................... #word PROD = 0xFF4 
.................... #byte INTCON = 0xFF2 
.................... #bit    RBIF = INTCON.0 
.................... #bit    INT0IF = INTCON.1 
.................... #bit    TMR0IF = INTCON.2 
.................... #bit    RBIE = INTCON.3 
.................... #bit    INT0IE = INTCON.4 
.................... #bit    TMR0IE = INTCON.5 
.................... #bit    PEIE_GIEL = INTCON.6 
.................... #bit    GIE_GIEH = INTCON.7 
.................... #byte INTCON = 0xFF2 
.................... #bit    PEIE = INTCON.6 
.................... #bit    GIE = INTCON.7 
.................... #byte INTCON = 0xFF2 
.................... #bit    INT0F = INTCON.1 
.................... #bit    T0IF = INTCON.2 
.................... #bit    INT0E = INTCON.4 
.................... #bit    T0IE = INTCON.5 
.................... #bit    GIEL = INTCON.6 
.................... #bit    GIEH = INTCON.7 
.................... #byte INTCON2 = 0xFF1 
.................... #bit    T0IP = INTCON2.2 
.................... #byte INTCON2 = 0xFF1 
.................... #bit    RBIP = INTCON2.0 
.................... #bit    TMR0IP = INTCON2.2 
.................... #bit    INTEDG2 = INTCON2.4 
.................... #bit    INTEDG1 = INTCON2.5 
.................... #bit    INTEDG0 = INTCON2.6 
.................... #bit    RBPU = INTCON2.7 
.................... #byte INTCON3 = 0xFF0 
.................... #bit    INT1F = INTCON3.0 
.................... #bit    INT2F = INTCON3.1 
.................... #bit    INT1E = INTCON3.3 
.................... #bit    INT2E = INTCON3.4 
.................... #bit    INT1P = INTCON3.6 
.................... #bit    INT2P = INTCON3.7 
.................... #byte INTCON3 = 0xFF0 
.................... #bit    INT1IF = INTCON3.0 
.................... #bit    INT2IF = INTCON3.1 
.................... #bit    INT1IE = INTCON3.3 
.................... #bit    INT2IE = INTCON3.4 
.................... #bit    INT1IP = INTCON3.6 
.................... #bit    INT2IP = INTCON3.7 
.................... #byte INDF0 = 0xFEF 
.................... #byte POSTINC0 = 0xFEE 
.................... #byte POSTDEC0 = 0xFED 
.................... #byte PREINC0 = 0xFEC 
.................... #byte PLUSW0 = 0xFEB 
.................... #word FSR0 = 0xFEA 
.................... #byte WREG = 0xFE8 
.................... #byte INDF1 = 0xFE7 
.................... #byte POSTINC1 = 0xFE6 
.................... #byte POSTDEC1 = 0xFE5 
.................... #byte PREINC1 = 0xFE4 
.................... #byte PLUSW1 = 0xFE3 
.................... #word FSR1 = 0xFE2 
.................... #byte BSR = 0xFE0 
.................... #byte INDF2 = 0xFDF 
.................... #byte POSTINC2 = 0xFDE 
.................... #byte POSTDEC2 = 0xFDD 
.................... #byte PREINC2 = 0xFDC 
.................... #byte PLUSW2 = 0xFDB 
.................... #word FSR2 = 0xFDA 
.................... #byte STATUS = 0xFD8 
.................... #bit    C = STATUS.0 
.................... #bit    DC = STATUS.1 
.................... #bit    Z = STATUS.2 
.................... #bit    OV = STATUS.3 
.................... #bit    N = STATUS.4 
.................... #word TMR0 = 0xFD7 
.................... #byte T0CON = 0xFD5 
.................... #bit    T0PS0 = T0CON.0 
.................... #bit    T0PS1 = T0CON.1 
.................... #bit    T0PS2 = T0CON.2 
.................... #bit    PSA = T0CON.3 
.................... #bit    T0SE = T0CON.4 
.................... #bit    T0CS = T0CON.5 
.................... #bit    T016BIT = T0CON.6 
.................... #bit    TMR0ON = T0CON.7 
.................... #byte OSCCON = 0xFD3 
.................... #bit    FLTS = OSCCON.2 
.................... #byte OSCCON = 0xFD3 
.................... #bit    SCS0 = OSCCON.0 
.................... #bit    SCS1 = OSCCON.1 
.................... #bit    IOFS = OSCCON.2 
.................... #bit    OSTS = OSCCON.3 
.................... #bit    IRCF0 = OSCCON.4 
.................... #bit    IRCF1 = OSCCON.5 
.................... #bit    IRCF2 = OSCCON.6 
.................... #bit    IDLEN = OSCCON.7 
.................... #byte LVDCON = 0xFD2 
.................... #bit    IVRST = LVDCON.5 
.................... #byte LVDCON = 0xFD2 
.................... #bit    LVDL0 = LVDCON.0 
.................... #bit    LVDL1 = LVDCON.1 
.................... #bit    LVDL2 = LVDCON.2 
.................... #bit    LVDL3 = LVDCON.3 
.................... #bit    LVDEN = LVDCON.4 
.................... #bit    IRVST = LVDCON.5 
.................... #byte WDTCON = 0xFD1 
.................... #bit    SWDTEN = WDTCON.0 
.................... #bit    WDTW = WDTCON.7 
.................... #byte RCON = 0xFD0 
.................... #bit    BOR = RCON.0 
.................... #bit    POR = RCON.1 
.................... #bit    PD = RCON.2 
.................... #bit    TO = RCON.3 
.................... #bit    RI = RCON.4 
.................... #bit    IPEN = RCON.7 
.................... #word TMR1 = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... #bit    T1INSYNC = T1CON.2 
.................... #byte T1CON = 0xFCD 
.................... #bit    TMR1ON = T1CON.0 
.................... #bit    TMR1CS = T1CON.1 
.................... #bit    T1SYNC = T1CON.2 
.................... #bit    T1OSCEN = T1CON.3 
.................... #bit    T1CKPS0 = T1CON.4 
.................... #bit    T1CKPS1 = T1CON.5 
.................... #bit    T1RUN = T1CON.6 
.................... #bit    RD16 = T1CON.7 
.................... #byte TMR2 = 0xFCC 
.................... #byte PR2 = 0xFCB 
.................... #byte T2CON = 0xFCA 
.................... #bit    T2OUTPS0 = T2CON.3 
.................... #bit    T2OUTPS1 = T2CON.4 
.................... #bit    T2OUTPS2 = T2CON.5 
.................... #bit    T2OUTPS3 = T2CON.6 
.................... #byte T2CON = 0xFCA 
.................... #bit    T2CKPS0 = T2CON.0 
.................... #bit    T2CKPS1 = T2CON.1 
.................... #bit    TMR2ON = T2CON.2 
.................... #bit    TOUTPS0 = T2CON.3 
.................... #bit    TOUTPS1 = T2CON.4 
.................... #bit    TOUTPS2 = T2CON.5 
.................... #bit    TOUTPS3 = T2CON.6 
.................... #byte SSPBUF = 0xFC9 
.................... #byte SSPADD = 0xFC8 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    READ_WRITE = SSPSTAT.2 
.................... #bit    DATA_ADDRESS = SSPSTAT.5 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    WRITE = SSPSTAT.2 
.................... #bit    ADDRESS = SSPSTAT.5 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    BF = SSPSTAT.0 
.................... #bit    UA = SSPSTAT.1 
.................... #bit    R = SSPSTAT.2 
.................... #bit    S = SSPSTAT.3 
.................... #bit    P = SSPSTAT.4 
.................... #bit    D = SSPSTAT.5 
.................... #bit    CKE = SSPSTAT.6 
.................... #bit    SMP = SSPSTAT.7 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    R_W = SSPSTAT.2 
.................... #bit    D_A = SSPSTAT.5 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    W = SSPSTAT.2 
.................... #bit    A = SSPSTAT.5 
.................... #byte SSPCON = 0xFC6 
.................... #bit    SSPM0 = SSPCON.0 
.................... #bit    SSPM1 = SSPCON.1 
.................... #bit    SSPM2 = SSPCON.2 
.................... #bit    SSPM3 = SSPCON.3 
.................... #bit    CKP = SSPCON.4 
.................... #bit    SSPEN = SSPCON.5 
.................... #bit    SSPOV = SSPCON.6 
.................... #bit    WCOL = SSPCON.7 
.................... #word ADRES = 0xFC4 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    GO_DONE = ADCON0.1 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    ADON = ADCON0.0 
.................... #bit    GO = ADCON0.1 
.................... #bit    ACMOD0 = ADCON0.2 
.................... #bit    ACMOD1 = ADCON0.3 
.................... #bit    ACSCH = ADCON0.4 
.................... #bit    ACONV = ADCON0.5 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    GODONE = ADCON0.1 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    DONE = ADCON0.1 
.................... #byte ADCON1 = 0xFC1 
.................... #bit    FFOVFL = ADCON1.2 
.................... #byte ADCON1 = 0xFC1 
.................... #bit    ADPNT0 = ADCON1.0 
.................... #bit    ADPNT1 = ADCON1.1 
.................... #bit    BFOVFL = ADCON1.2 
.................... #bit    BFEMT = ADCON1.3 
.................... #bit    FIFOEN = ADCON1.4 
.................... #bit    VCFG0 = ADCON1.6 
.................... #bit    VCFG1 = ADCON1.7 
.................... #byte ADCON2 = 0xFC0 
.................... #bit    ADCS0 = ADCON2.0 
.................... #bit    ADCS1 = ADCON2.1 
.................... #bit    ADCS2 = ADCON2.2 
.................... #bit    ACQT0 = ADCON2.3 
.................... #bit    ACQT1 = ADCON2.4 
.................... #bit    ACQT2 = ADCON2.5 
.................... #bit    ACQT3 = ADCON2.6 
.................... #bit    ADFM = ADCON2.7 
.................... #word CCPR1 = 0xFBF 
.................... #byte CCP1CON = 0xFBD 
.................... #bit    CCP1Y = CCP1CON.4 
.................... #bit    CCP1X = CCP1CON.5 
.................... #byte CCP1CON = 0xFBD 
.................... #bit    CCP1M0 = CCP1CON.0 
.................... #bit    CCP1M1 = CCP1CON.1 
.................... #bit    CCP1M2 = CCP1CON.2 
.................... #bit    CCP1M3 = CCP1CON.3 
.................... #bit    DC1B0 = CCP1CON.4 
.................... #bit    DC1B1 = CCP1CON.5 
.................... #word CCPR2 = 0xFBC 
.................... #byte CCP2CON = 0xFBA 
.................... #bit    CCP2Y = CCP2CON.4 
.................... #bit    CCP2X = CCP2CON.5 
.................... #byte CCP2CON = 0xFBA 
.................... #bit    CCP2M0 = CCP2CON.0 
.................... #bit    CCP2M1 = CCP2CON.1 
.................... #bit    CCP2M2 = CCP2CON.2 
.................... #bit    CCP2M3 = CCP2CON.3 
.................... #bit    DC2B0 = CCP2CON.4 
.................... #bit    DC2B1 = CCP2CON.5 
.................... #byte ANSEL1 = 0xFB9 
.................... #bit    ANS8 = ANSEL1.0 
.................... #byte ANSEL0 = 0xFB8 
.................... #byte T5CON = 0xFB7 
.................... #bit    TMR5ON = T5CON.0 
.................... #bit    TMR5CS = T5CON.1 
.................... #bit    T5SYNC = T5CON.2 
.................... #bit    T5PS0 = T5CON.3 
.................... #bit    T5PS1 = T5CON.4 
.................... #bit    T5MOD = T5CON.5 
.................... #bit    RESEN = T5CON.6 
.................... #bit    T5SEN = T5CON.7 
.................... #byte QEICON = 0xFB6 
.................... #bit    UP_DOWN = QEICON.5 
.................... #byte QEICON = 0xFB6 
.................... #bit    PDEC0 = QEICON.0 
.................... #bit    PDEC1 = QEICON.1 
.................... #bit    QEIM0 = QEICON.2 
.................... #bit    QEIM1 = QEICON.3 
.................... #bit    QEIM2 = QEICON.4 
.................... #bit    UP = QEICON.5 
.................... #bit    QERR = QEICON.6 
.................... #bit    VELM = QEICON.7 
.................... #byte QEICON = 0xFB6 
.................... #bit    UPDOWN = QEICON.5 
.................... #byte QEICON = 0xFB6 
.................... #bit    DOWN = QEICON.5 
.................... #byte SPBRGH = 0xFB0 
.................... #byte SPBRG = 0xFAF 
.................... #byte RCREG = 0xFAE 
.................... #byte TXREG = 0xFAD 
.................... #byte TXSTA = 0xFAC 
.................... #bit    TX9D = TXSTA.0 
.................... #bit    TRMT = TXSTA.1 
.................... #bit    BRGH = TXSTA.2 
.................... #bit    SENDB = TXSTA.3 
.................... #bit    SYNC = TXSTA.4 
.................... #bit    TXEN = TXSTA.5 
.................... #bit    TX9 = TXSTA.6 
.................... #bit    CSRC = TXSTA.7 
.................... #byte RCSTA = 0xFAB 
.................... #bit    ADEN = RCSTA.3 
.................... #byte RCSTA = 0xFAB 
.................... #bit    RX9D = RCSTA.0 
.................... #bit    OERR = RCSTA.1 
.................... #bit    FERR = RCSTA.2 
.................... #bit    ADDEN = RCSTA.3 
.................... #bit    CREN = RCSTA.4 
.................... #bit    SREN = RCSTA.5 
.................... #bit    RX9 = RCSTA.6 
.................... #bit    SPEN = RCSTA.7 
.................... #byte BAUDCON = 0xFAA 
.................... #bit    SCKP = BAUDCON.4 
.................... #bit    RCMT = BAUDCON.6 
.................... #byte BAUDCON = 0xFAA 
.................... #bit    ABDEN = BAUDCON.0 
.................... #bit    WUE = BAUDCON.1 
.................... #bit    BRG16 = BAUDCON.3 
.................... #bit    TXCKP = BAUDCON.4 
.................... #bit    RXDTP = BAUDCON.5 
.................... #bit    RCIDL = BAUDCON.6 
.................... #bit    ABDOVF = BAUDCON.7 
.................... #byte EEADR = 0xFA9 
.................... #byte EEDATA = 0xFA8 
.................... #byte EECON2 = 0xFA7 
.................... #byte EECON1 = 0xFA6 
.................... #bit    RD = EECON1.0 
.................... #bit    WR = EECON1.1 
.................... #bit    WREN = EECON1.2 
.................... #bit    WRERR = EECON1.3 
.................... #bit    FREE = EECON1.4 
.................... #bit    CFGS = EECON1.6 
.................... #bit    EEPGD = EECON1.7 
.................... #byte IPR3 = 0xFA5 
.................... #bit    TMR5IP = IPR3.0 
.................... #bit    IC1IP = IPR3.1 
.................... #bit    IC2QEIP = IPR3.2 
.................... #bit    IC3DRIP = IPR3.3 
.................... #bit    PTIP = IPR3.4 
.................... #byte PIR3 = 0xFA4 
.................... #bit    TMR5IF = PIR3.0 
.................... #bit    IC1IF = PIR3.1 
.................... #bit    IC2QEIF = PIR3.2 
.................... #bit    IC3DRIF = PIR3.3 
.................... #bit    PTIF = PIR3.4 
.................... #byte PIE3 = 0xFA3 
.................... #bit    TMR5IE = PIE3.0 
.................... #bit    IC1IE = PIE3.1 
.................... #bit    IC2QEIE = PIE3.2 
.................... #bit    IC3DRIE = PIE3.3 
.................... #bit    PTIE = PIE3.4 
.................... #byte IPR2 = 0xFA2 
.................... #bit    CCP2IP = IPR2.0 
.................... #bit    LVDIP = IPR2.2 
.................... #bit    EEIP = IPR2.4 
.................... #bit    OSFIP = IPR2.7 
.................... #byte PIR2 = 0xFA1 
.................... #bit    CCP2IF = PIR2.0 
.................... #bit    LVDIF = PIR2.2 
.................... #bit    EEIF = PIR2.4 
.................... #bit    OSFIF = PIR2.7 
.................... #byte PIE2 = 0xFA0 
.................... #bit    CCP2IE = PIE2.0 
.................... #bit    LVDIE = PIE2.2 
.................... #bit    EEIE = PIE2.4 
.................... #bit    OSFIE = PIE2.7 
.................... #byte IPR1 = 0xF9F 
.................... #bit    TBIP = IPR1.4 
.................... #byte IPR1 = 0xF9F 
.................... #bit    TMR1IP = IPR1.0 
.................... #bit    TMR2IP = IPR1.1 
.................... #bit    CCP1IP = IPR1.2 
.................... #bit    SSPIP = IPR1.3 
.................... #bit    TXIP = IPR1.4 
.................... #bit    RCIP = IPR1.5 
.................... #bit    ADIP = IPR1.6 
.................... #byte PIR1 = 0xF9E 
.................... #bit    TBIF = PIR1.4 
.................... #byte PIR1 = 0xF9E 
.................... #bit    TMR1IF = PIR1.0 
.................... #bit    TMR2IF = PIR1.1 
.................... #bit    CCP1IF = PIR1.2 
.................... #bit    SSPIF = PIR1.3 
.................... #bit    TXIF = PIR1.4 
.................... #bit    RCIF = PIR1.5 
.................... #bit    ADIF = PIR1.6 
.................... #byte PIE1 = 0xF9D 
.................... #bit    TBIE = PIE1.4 
.................... #byte PIE1 = 0xF9D 
.................... #bit    TMR1IE = PIE1.0 
.................... #bit    TMR2IE = PIE1.1 
.................... #bit    CCP1IE = PIE1.2 
.................... #bit    SSPIE = PIE1.3 
.................... #bit    TXIE = PIE1.4 
.................... #bit    RCIE = PIE1.5 
.................... #bit    ADIE = PIE1.6 
.................... #byte OSCTUNE = 0xF9B 
.................... #byte ADCON3 = 0xF9A 
.................... #bit    SSRC0 = ADCON3.0 
.................... #bit    SSRC1 = ADCON3.1 
.................... #bit    SSRC2 = ADCON3.2 
.................... #bit    SSRC3 = ADCON3.3 
.................... #bit    SSRC4 = ADCON3.4 
.................... #bit    ADRS0 = ADCON3.6 
.................... #bit    ADRS1 = ADCON3.7 
.................... #byte ADCHS = 0xF99 
.................... #bit    GASEL0 = ADCHS.0 
.................... #bit    GASEL1 = ADCHS.1 
.................... #bit    GCSEL0 = ADCHS.2 
.................... #bit    GCSEL1 = ADCHS.3 
.................... #bit    GBSEL0 = ADCHS.4 
.................... #bit    GBSEL1 = ADCHS.5 
.................... #bit    GDSEL0 = ADCHS.6 
.................... #bit    GDSEL1 = ADCHS.7 
.................... #byte ADCHS = 0xF99 
.................... #bit    SASEL0 = ADCHS.0 
.................... #bit    SASEL1 = ADCHS.1 
.................... #bit    SCSEL0 = ADCHS.2 
.................... #bit    SCSEL1 = ADCHS.3 
.................... #bit    SBSEL0 = ADCHS.4 
.................... #bit    SBSEL1 = ADCHS.5 
.................... #bit    SDSEL0 = ADCHS.6 
.................... #bit    SDSEL1 = ADCHS.7 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
.................... #byte TRISA = 0xF92 
.................... #word PR5 = 0xF91 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
.................... #byte LATA = 0xF89 
.................... #word TMR5 = 0xF88 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #byte PTCON0 = 0xF7F 
.................... #bit    PTMOD0 = PTCON0.0 
.................... #bit    PTMOD1 = PTCON0.1 
.................... #bit    PTCKPS0 = PTCON0.2 
.................... #bit    PTCKPS1 = PTCON0.3 
.................... #bit    PTOPS0 = PTCON0.4 
.................... #bit    PTOPS1 = PTCON0.5 
.................... #bit    PTOPS2 = PTCON0.6 
.................... #bit    PTOPS3 = PTCON0.7 
.................... #byte PTCON1 = 0xF7E 
.................... #bit    PTDIR = PTCON1.6 
.................... #bit    PTEN = PTCON1.7 
.................... #byte PTMRL = 0xF7D 
.................... #byte PTMRH = 0xF7C 
.................... #byte PTPERL = 0xF7B 
.................... #byte PTPERH = 0xF7A 
.................... #byte PDC0L = 0xF79 
.................... #byte PDC0H = 0xF78 
.................... #byte PDC1L = 0xF77 
.................... #byte PDC1H = 0xF76 
.................... #byte PDC2L = 0xF75 
.................... #byte PDC2H = 0xF74 
.................... #byte PDC3L = 0xF73 
.................... #byte PDC3H = 0xF72 
.................... #byte SEVTCMPL = 0xF71 
.................... #byte SEVTCMPH = 0xF70 
.................... #byte PWMCON0 = 0xF6F 
.................... #bit    PMOD0 = PWMCON0.0 
.................... #bit    PMOD1 = PWMCON0.1 
.................... #bit    PMOD2 = PWMCON0.2 
.................... #bit    PMOD3 = PWMCON0.3 
.................... #bit    PWMEN0 = PWMCON0.4 
.................... #bit    PWMEN1 = PWMCON0.5 
.................... #bit    PWMEN2 = PWMCON0.6 
.................... #byte PWMCON1 = 0xF6E 
.................... #bit    OSYNC = PWMCON1.0 
.................... #bit    UDIS = PWMCON1.1 
.................... #bit    SEVTDIR = PWMCON1.3 
.................... #bit    SEVOPS0 = PWMCON1.4 
.................... #bit    SEVOPS1 = PWMCON1.5 
.................... #bit    SEVOPS2 = PWMCON1.6 
.................... #bit    SEVOPS3 = PWMCON1.7 
.................... #byte DTCON = 0xF6D 
.................... #bit    DT0 = DTCON.0 
.................... #bit    DT1 = DTCON.1 
.................... #bit    DT2 = DTCON.2 
.................... #bit    DT3 = DTCON.3 
.................... #bit    DT4 = DTCON.4 
.................... #bit    DT5 = DTCON.5 
.................... #bit    DTPS0 = DTCON.6 
.................... #bit    DTPS1 = DTCON.7 
.................... #byte DTCON = 0xF6D 
.................... #bit    DTA0 = DTCON.0 
.................... #bit    DTA1 = DTCON.1 
.................... #bit    DTA2 = DTCON.2 
.................... #bit    DTA3 = DTCON.3 
.................... #bit    DTA4 = DTCON.4 
.................... #bit    DTA5 = DTCON.5 
.................... #bit    DTAPS0 = DTCON.6 
.................... #bit    DTAPS1 = DTCON.7 
.................... #byte FLTCONFIG = 0xF6C 
.................... #bit    FLTAEN = FLTCONFIG.0 
.................... #bit    FLTAMOD = FLTCONFIG.1 
.................... #bit    FLTAS = FLTCONFIG.2 
.................... #bit    FLTCON = FLTCONFIG.3 
.................... #bit    FLTBEN = FLTCONFIG.4 
.................... #bit    FLTBMOD = FLTCONFIG.5 
.................... #bit    FLTBS = FLTCONFIG.6 
.................... #bit    BRFEN = FLTCONFIG.7 
.................... #byte OVDCOND = 0xF6B 
.................... #byte OVDCONS = 0xF6A 
.................... #word CAP1BUF = 0xF69 
.................... #word CAP2BUF = 0xF67 
.................... #word CAP3BUF = 0xF65 
.................... #byte CAP1CON = 0xF63 
.................... #bit    CAP1M0 = CAP1CON.0 
.................... #bit    CAP1M1 = CAP1CON.1 
.................... #bit    CAP1M2 = CAP1CON.2 
.................... #bit    CAP1M3 = CAP1CON.3 
.................... #bit    CAP1TMR = CAP1CON.5 
.................... #bit    CAP1REN = CAP1CON.6 
.................... #byte CAP2CON = 0xF62 
.................... #bit    CAP2M0 = CAP2CON.0 
.................... #bit    CAP2M1 = CAP2CON.1 
.................... #bit    CAP2M2 = CAP2CON.2 
.................... #bit    CAP2M3 = CAP2CON.3 
.................... #bit    CAP2TMR = CAP2CON.5 
.................... #bit    CAP2REN = CAP2CON.6 
.................... #byte CAP3CON = 0xF61 
.................... #bit    CAP3M0 = CAP3CON.0 
.................... #bit    CAP3M1 = CAP3CON.1 
.................... #bit    CAP3M2 = CAP3CON.2 
.................... #bit    CAP3M3 = CAP3CON.3 
.................... #bit    CAP3TMR = CAP3CON.5 
.................... #bit    CAP3REN = CAP3CON.6 
.................... #byte DFLTCON = 0xF60 
.................... #bit    FLTCK0 = DFLTCON.0 
.................... #bit    FLTCK1 = DFLTCON.1 
.................... #bit    FLTCK2 = DFLTCON.2 
.................... #bit    FLT1EN = DFLTCON.3 
.................... #bit    FLT2EN = DFLTCON.4 
.................... #bit    FLT3EN = DFLTCON.5 
.................... #bit    FLT4EN = DFLTCON.6 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, H4,PUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT, LPOL_HIGH//, SSP_RD 
.................... #use delay(clock=40000000) 
*
09F8:  CLRF   FEA
09FA:  MOVLW  68
09FC:  MOVWF  FE9
09FE:  MOVF   FEF,W
0A00:  BZ    0A1E
0A02:  MOVLW  0C
0A04:  MOVWF  01
0A06:  CLRF   00
0A08:  DECFSZ 00,F
0A0A:  BRA    0A08
0A0C:  DECFSZ 01,F
0A0E:  BRA    0A06
0A10:  MOVLW  F7
0A12:  MOVWF  00
0A14:  DECFSZ 00,F
0A16:  BRA    0A14
0A18:  BRA    0A1A
0A1A:  DECFSZ FEF,F
0A1C:  BRA    0A02
0A1E:  RETURN 0
....................  
.................... //#use spi(MASTER ,FORCE_HW, BITS=16) 
.................... //#bit ss1 = PORTD.0 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(d) 
.................... #use fast_io(c) 
.................... #use fast_io(e) 
....................  
.................... void khoidong() 
.................... { 
....................    trisa=0b00011000; /// DAU VAO QEI CUNG 
*
0A9E:  MOVLW  18
0AA0:  MOVWF  F92
....................    porta=0b11100111; 
0AA2:  MOVLW  E7
0AA4:  MOVWF  F80
....................    trisb=0b11111111; /// DAU VAO CONG TAC HANH TRINH 
0AA6:  SETF   F93
....................    port_b_pullups(0xff); 
0AA8:  BCF    FF1.7
....................    portb=0xff; 
0AAA:  SETF   F81
....................    trisc=0b00110000; /// DAU VAO QEI MEM 
0AAC:  MOVLW  30
0AAE:  MOVWF  F94
....................    portc=0b00000000; 
0AB0:  CLRF   F82
....................    trisd=0b00000000; /// DAU VAO SPI 0b00000100 
0AB2:  CLRF   F95
....................    portd=0b11110000; 
0AB4:  MOVLW  F0
0AB6:  MOVWF  F83
....................    trise=0b00000000; 
0AB8:  CLRF   F96
....................    porte=0b11111111; 
0ABA:  SETF   F84
....................     
....................    enable_interrupts(INT_EXT1); 
0ABC:  BSF    FF0.3
....................    enable_interrupts(INT_EXT2); 
0ABE:  BSF    FF0.4
....................     
....................    //enable_interrupts(int_timer0); 
....................    //enable_interrupts(int_timer1); 
....................    //enable_interrupts(int_timer5); 
....................     
....................    enable_interrupts(GLOBAL); 
0AC0:  MOVLW  C0
0AC2:  IORWF  FF2,F
....................    ext_int_edge(1,L_to_H); 
0AC4:  BSF    FF1.5
....................    ext_int_edge(2,L_to_H); 
0AC6:  BSF    FF1.4
....................     
....................    clear_interrupt(INT_EXT1); 
0AC8:  BCF    FF0.0
....................    clear_interrupt(INT_EXT2); 
0ACA:  BCF    FF0.1
....................    clear_interrupt(int_timer0); 
0ACC:  BCF    FF2.2
....................    clear_interrupt(int_timer1); 
0ACE:  BCF    F9E.0
....................    clear_interrupt(int_timer5); 
0AD0:  BCF    FA4.0
....................     
....................    setup_qei(QEI_MODE_X4_RESET_WITH_INDX,qei_filter_enable_qea|qei_filter_enable_qeb|qei_filter_div_2,65535); 
0AD2:  MOVLW  14
0AD4:  MOVWF  FB6
0AD6:  MOVLW  31
0AD8:  MOVWF  F60
0ADA:  SETF   F65
0ADC:  SETF   F64
0ADE:  CLRF   F67
0AE0:  CLRF   F66
....................    qei_set_count(0); 
0AE2:  CLRF   F67
0AE4:  CLRF   F66
....................     
....................    //setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1);      //6.5 ms overflow, 0.1us 
....................    //set_timer0(64535); 
....................     
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_4|RTCC_8_bit);      //102 us overflow, 0.4us 
0AE6:  MOVLW  C1
0AE8:  MOVWF  FD5
....................    set_timer0(5); 
0AEA:  CLRF   FD7
0AEC:  MOVLW  05
0AEE:  MOVWF  FD6
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);      //52.4 ms overflow, 0.8us 
0AF0:  MOVLW  B5
0AF2:  MOVWF  FCD
....................    set_timer1(59286); 
0AF4:  MOVLW  E7
0AF6:  MOVWF  FCF
0AF8:  MOVLW  96
0AFA:  MOVWF  FCE
....................    setup_timer_5(T5_INTERNAL|T5_DIV_BY_8);      //52.4 ms overflow, 0.8us 
0AFC:  MOVLW  19
0AFE:  MOVWF  FB7
....................    set_timer5(53035); 
0B00:  MOVLW  CF
0B02:  MOVWF  F88
0B04:  MOVLW  2B
0B06:  MOVWF  F87
0B08:  GOTO   1166 (RETURN)
....................     
....................    //setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_CLK_DIV_16); 
....................    //ss1=1; 
....................  
....................       
.................... } 
....................  
....................  
.................... #include <van-ctht.c> 
....................  
.................... ///// DEFINE VAN 
....................  
.................... #bit vantay1=porta.5 
.................... #bit vantay2=porte.0 
.................... #bit vancanh2=porta.0     
.................... #bit vancanh1=porta.1     
.................... #bit vanduoi=porta.2 
....................  
.................... ///// DEFINE CONG TAC HANH TRINH 
.................... #bit ctt2=portb.0 
.................... #bit ctc2=portb.1 
.................... #bit ctt1=portb.2 
.................... #bit ctc1=portb.3 
....................  
.................... #bit ctld=portb.4 
.................... #bit ctlt=portb.5 
....................  
.................... #bit ctsel=portb.7 
.................... #bit cten=portb.6 
....................  
.................... ///// CHUONG TRINH LOA TIN HIEU 
.................... #bit trisloa = trisd.7 
.................... #bit loa = portd.7 
.................... void beep(int8 solan,int8 time) 
.................... { 
.................... int8 i; 
.................... for (i=0; i<solan; i++) 
*
0A20:  CLRF   x66
0A22:  MOVF   x64,W
0A24:  SUBWF  x66,W
0A26:  BC    0A42
....................    { 
....................    trisloa = 0; 
0A28:  BCF    F95.7
....................    loa = 0; 
0A2A:  BCF    F83.7
....................    delay_ms(20); 
0A2C:  MOVLW  14
0A2E:  MOVWF  x68
0A30:  RCALL  09F8
....................    loa = 1; 
0A32:  BSF    F83.7
....................    delay_ms(time-20); 
0A34:  MOVLW  14
0A36:  SUBWF  x65,W
0A38:  MOVWF  x67
0A3A:  MOVWF  x68
0A3C:  RCALL  09F8
0A3E:  INCF   x66,F
0A40:  BRA    0A22
....................    } 
0A42:  RETURN 0
.................... } 
....................  
....................  
.................... #include <dongco.c> 
....................  
.................... ///// DEFINE CAC DONG CO 
....................  
.................... #bit br1=porte.2 
.................... #bit br2=porte.1 
.................... #bit trisbr1 = trise.2 
.................... #bit trisbr2 = trise.1 
.................... #bit dir1=portc.3 
.................... #bit dir2=portc.0 
.................... #bit trisdir1 = trisc.3 
.................... #bit trisdir2 = trisc.0 
.................... #bit pwm1=portc.2 
.................... #bit pwm2=portc.1 
.................... #bit trispwm1 = trisc.2 
.................... #bit trispwm2 = trisc.1 
....................  
.................... void dc1t(INT16 x) 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
*
0B0C:  BCF    F96.2
0B0E:  BCF    F94.3
0B10:  BCF    F94.2
....................    dir1 = 1; 
0B12:  BSF    F82.3
....................    br1 = 0; 
0B14:  BCF    F84.2
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0B16:  MOVLW  00
0B18:  IORLW  04
0B1A:  MOVWF  FCA
0B1C:  MOVLW  F9
0B1E:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
0B20:  BCF    F8B.2
0B22:  MOVLW  0C
0B24:  MOVWF  FBD
....................    set_pwm1_duty (x); 
0B26:  MOVFF  60,02
0B2A:  MOVFF  5F,01
0B2E:  RRCF   02,F
0B30:  RRCF   01,F
0B32:  RRCF   02,F
0B34:  RRCF   01,F
0B36:  RRCF   02,F
0B38:  MOVFF  01,FBE
0B3C:  RRCF   02,F
0B3E:  RRCF   02,W
0B40:  ANDLW  30
0B42:  MOVWF  00
0B44:  MOVF   FBD,W
0B46:  ANDLW  CF
0B48:  IORWF  00,W
0B4A:  MOVWF  FBD
0B4C:  RETURN 0
.................... } 
....................  
.................... void dc1n(INT16 x) 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
....................    dir1 = 0; 
....................    br1 = 0; 
....................    setup_timer_2 (t2_div_by_1, 249, 1); // 25us 
....................    setup_ccp1 (ccp_pwm); 
....................    set_pwm1_duty (x); 
.................... } 
....................  
.................... void resetdc1() 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
0B4E:  BCF    F96.2
0B50:  BCF    F94.3
0B52:  BCF    F94.2
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0B54:  MOVLW  00
0B56:  IORLW  04
0B58:  MOVWF  FCA
0B5A:  MOVLW  F9
0B5C:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
0B5E:  BCF    F8B.2
0B60:  MOVLW  0C
0B62:  MOVWF  FBD
....................    set_pwm1_duty (0); 
0B64:  CLRF   FBE
....................    br1 = 1; 
0B66:  BSF    F84.2
....................    dir1 = 0; 
0B68:  BCF    F82.3
0B6A:  RETURN 0
.................... } 
....................  
.................... void dc2n(INT16 x) 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
*
0CD2:  BCF    F96.1
0CD4:  BCF    F94.0
0CD6:  BCF    F94.1
....................    dir2 = 1; 
0CD8:  BSF    F82.0
....................    br2 = 0; 
0CDA:  BCF    F84.1
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0CDC:  MOVLW  00
0CDE:  IORLW  04
0CE0:  MOVWF  FCA
0CE2:  MOVLW  F9
0CE4:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
0CE6:  BCF    F8B.1
0CE8:  MOVLW  0C
0CEA:  MOVWF  FBA
....................    set_pwm2_duty (x); 
0CEC:  MOVFF  60,02
0CF0:  MOVFF  5F,01
0CF4:  RRCF   02,F
0CF6:  RRCF   01,F
0CF8:  RRCF   02,F
0CFA:  RRCF   01,F
0CFC:  RRCF   02,F
0CFE:  MOVFF  01,FBB
0D02:  RRCF   02,F
0D04:  RRCF   02,W
0D06:  ANDLW  30
0D08:  MOVWF  00
0D0A:  MOVF   FBA,W
0D0C:  ANDLW  CF
0D0E:  IORWF  00,W
0D10:  MOVWF  FBA
0D12:  RETURN 0
.................... } 
....................  
.................... void dc2t(INT16 x) 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
*
0B6C:  BCF    F96.1
0B6E:  BCF    F94.0
0B70:  BCF    F94.1
....................    br2 = 0; 
0B72:  BCF    F84.1
....................    dir2 = 0; 
0B74:  BCF    F82.0
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0B76:  MOVLW  00
0B78:  IORLW  04
0B7A:  MOVWF  FCA
0B7C:  MOVLW  F9
0B7E:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
0B80:  BCF    F8B.1
0B82:  MOVLW  0C
0B84:  MOVWF  FBA
....................    set_pwm2_duty (x); 
0B86:  MOVFF  5C,02
0B8A:  MOVFF  5B,01
0B8E:  RRCF   02,F
0B90:  RRCF   01,F
0B92:  RRCF   02,F
0B94:  RRCF   01,F
0B96:  RRCF   02,F
0B98:  MOVFF  01,FBB
0B9C:  RRCF   02,F
0B9E:  RRCF   02,W
0BA0:  ANDLW  30
0BA2:  MOVWF  00
0BA4:  MOVF   FBA,W
0BA6:  ANDLW  CF
0BA8:  IORWF  00,W
0BAA:  MOVWF  FBA
0BAC:  GOTO   0C62 (RETURN)
.................... } 
....................  
.................... void resetdc2() 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
0BB0:  BCF    F96.1
0BB2:  BCF    F94.0
0BB4:  BCF    F94.1
....................    br2 = 1; 
0BB6:  BSF    F84.1
....................    dir2 = 0; 
0BB8:  BCF    F82.0
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0BBA:  MOVLW  00
0BBC:  IORLW  04
0BBE:  MOVWF  FCA
0BC0:  MOVLW  F9
0BC2:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
0BC4:  BCF    F8B.1
0BC6:  MOVLW  0C
0BC8:  MOVWF  FBA
....................    set_pwm2_duty (0); 
0BCA:  CLRF   FBB
0BCC:  RETURN 0
.................... } 
....................  
....................  
.................... #bit pwm3 = portd.6 
.................... #bit dir3 = portd.5 
.................... #bit trispwm3 = trisd.6 
.................... #bit trisdir3 = trisd.5 
.................... /* 
.................... void dc3t(INT16 x) 
.................... { 
.................... trispwm3=trisdir3=0; 
.................... pwm3=dir3=1; 
.................... setup_power_pwm(pwm_clock_div_4|pwm_free_run,1,0,625,0,1,0); 
.................... setup_power_pwm_pins(1,1,1,1);    
....................     
.................... set_power_pwm6_duty(2500-x); 
....................  
....................  
.................... } 
.................... void dc3n(INT16 x) 
.................... { 
.................... trispwm3=trisdir3=0; 
.................... pwm3=1; 
.................... dir3=0; 
.................... setup_power_pwm(pwm_clock_div_4|pwm_free_run,1,0,625,0,1,0); 
.................... setup_power_pwm_pins(1,1,1,1);    
....................     
.................... set_power_pwm6_duty(2500-x); 
....................  
....................  
.................... } 
.................... void resetdc3() 
.................... { 
.................... trispwm3=trisdir3=0; 
.................... pwm3=dir3=1; 
.................... setup_power_pwm(pwm_clock_div_4|pwm_free_run,1,0,625,0,1,0); 
.................... setup_power_pwm_pins(1,1,1,1);    
....................     
.................... set_power_pwm6_duty(2500); 
....................  
.................... } 
.................... */ 
....................  
....................  
.................... #include <qei_piddc.c> 
....................  
.................... ///// QEI MEM + DU LIEU QEI 
.................... signed int16 En2; 
.................... #define ChanelA PIN_C4 
.................... #define ChanelB PIN_C5 
.................... #INT_EXT1 
.................... void  EXT1_L2H_isr(void)  
.................... { 
.................... INTEDG1^=1; 
*
00C6:  CLRF   00
00C8:  BTFSC  FF1.5
00CA:  INCF   00,F
00CC:  MOVLW  01
00CE:  XORWF  00,F
00D0:  BCF    FF1.5
00D2:  BTFSC  00.0
00D4:  BSF    FF1.5
.................... if (INTEDG1) 
00D6:  BTFSS  FF1.5
00D8:  BRA    00F0
....................    { 
....................    if (input(ChanelB)) {En2--;}  
00DA:  BTFSS  F82.5
00DC:  BRA    00E8
00DE:  MOVF   1D,W
00E0:  BTFSC  FD8.2
00E2:  DECF   1E,F
00E4:  DECF   1D,F
00E6:  BRA    00EE
....................    else {En2++;} 
00E8:  INCF   1D,F
00EA:  BTFSC  FD8.2
00EC:  INCF   1E,F
....................    } 
00EE:  BRA    0104
.................... else  
....................    {  
....................    if (input(ChanelB)) {En2++;} 
00F0:  BTFSS  F82.5
00F2:  BRA    00FC
00F4:  INCF   1D,F
00F6:  BTFSC  FD8.2
00F8:  INCF   1E,F
00FA:  BRA    0104
....................    else {En2--;} 
00FC:  MOVF   1D,W
00FE:  BTFSC  FD8.2
0100:  DECF   1E,F
0102:  DECF   1D,F
....................    } 
.................... } 
0104:  BCF    FF0.0
0106:  GOTO   0084
.................... #int_EXT2 
.................... void  EXT2_isr(void)  
.................... { 
.................... INTEDG2^=1; 
010A:  CLRF   00
010C:  BTFSC  FF1.4
010E:  INCF   00,F
0110:  MOVLW  01
0112:  XORWF  00,F
0114:  BCF    FF1.4
0116:  BTFSC  00.0
0118:  BSF    FF1.4
.................... if (INTEDG2) 
011A:  BTFSS  FF1.4
011C:  BRA    0134
....................    { 
....................    if (input(ChanelA)) {En2++;}  
011E:  BTFSS  F82.4
0120:  BRA    012A
0122:  INCF   1D,F
0124:  BTFSC  FD8.2
0126:  INCF   1E,F
0128:  BRA    0132
....................    else {En2--;} 
012A:  MOVF   1D,W
012C:  BTFSC  FD8.2
012E:  DECF   1E,F
0130:  DECF   1D,F
....................    } 
0132:  BRA    0148
.................... else  
....................    {  
....................    if (input(ChanelA)) {En2--;} 
0134:  BTFSS  F82.4
0136:  BRA    0142
0138:  MOVF   1D,W
013A:  BTFSC  FD8.2
013C:  DECF   1E,F
013E:  DECF   1D,F
0140:  BRA    0148
....................    else {En2++;} 
0142:  INCF   1D,F
0144:  BTFSC  FD8.2
0146:  INCF   1E,F
....................    } 
0148:  BCF    FF0.1
014A:  GOTO   0084
.................... } 
....................  
.................... /// PID DONG CO 1 ////////////////// 
.................... volatile float kp=2, ki=0.2,kd=0.7, pid1, pid2; 
.................... signed int16 realvt1, errs1=0, err1, delta1=0, epre1=0, duty1 ; 
.................... volatile unsigned int8 Ti1,Ti2; 
.................... volatile signed int16 setvt1,setvt2,vt1=370,vt2=400; 
....................  
.................... void piddc1(signed int16 setvt1, signed int16 vt1) 
....................      { 
....................      br1=0; 
*
054A:  BCF    F84.2
....................      realvt1 =  qei_get_count();  
054C:  MOVFF  F67,01
0550:  MOVFF  F66,00
0554:  MOVFF  F67,03
0558:  MOVF   03,W
055A:  SUBWF  01,W
055C:  BZ    0562
055E:  MOVFF  F66,00
0562:  MOVF   00,W
0564:  MOVWF  33
0566:  MOVFF  03,34
....................      err1 = setvt1 - realvt1; 
056A:  MOVF   33,W
056C:  SUBWF  x64,W
056E:  MOVWF  37
0570:  MOVF   34,W
0572:  SUBWFB x65,W
0574:  MOVWF  38
....................      if(Ti1>=2) 
0576:  MOVF   3F,W
0578:  SUBLW  01
057A:  BC    05DA
....................      { 
....................        delta1 = err1-epre1; 
057C:  MOVF   3B,W
057E:  SUBWF  37,W
0580:  MOVWF  39
0582:  MOVF   3C,W
0584:  SUBWFB 38,W
0586:  MOVWF  3A
....................        Ti1=0; 
0588:  CLRF   3F
....................        if(delta1>-10) errs1 += err1;//(err1>-20)&&(err1<20) 
058A:  BTFSS  3A.7
058C:  BRA    059E
058E:  MOVF   3A,W
0590:  SUBLW  FE
0592:  BC    05A6
0594:  XORLW  FF
0596:  BNZ   059E
0598:  MOVF   39,W
059A:  SUBLW  F6
059C:  BC    05A6
059E:  MOVF   37,W
05A0:  ADDWF  35,F
05A2:  MOVF   38,W
05A4:  ADDWFC 36,F
....................        if (errs1 > 200 ) errs1=200; 
05A6:  BTFSC  36.7
05A8:  BRA    05BA
05AA:  MOVF   36,F
05AC:  BNZ   05B4
05AE:  MOVF   35,W
05B0:  SUBLW  C8
05B2:  BC    05BA
05B4:  CLRF   36
05B6:  MOVLW  C8
05B8:  MOVWF  35
....................        if (errs1 < -200 ) errs1=-200; 
05BA:  BTFSS  36.7
05BC:  BRA    05D2
05BE:  MOVF   36,W
05C0:  SUBLW  FF
05C2:  BNC   05D2
05C4:  BNZ   05CC
05C6:  MOVF   35,W
05C8:  SUBLW  37
05CA:  BNC   05D2
05CC:  SETF   36
05CE:  MOVLW  38
05D0:  MOVWF  35
....................        epre1=err1; 
05D2:  MOVFF  38,3C
05D6:  MOVFF  37,3B
....................      } 
....................    
....................      pid1 =kp*err1 + ki*errs1+kd*delta1;  
05DA:  MOVFF  38,6D
05DE:  MOVFF  37,6C
05E2:  RCALL  016E
05E4:  MOVFF  22,6F
05E8:  MOVFF  21,6E
05EC:  MOVFF  20,6D
05F0:  MOVFF  1F,6C
05F4:  MOVFF  03,73
05F8:  MOVFF  02,72
05FC:  MOVFF  01,71
0600:  MOVFF  00,70
0604:  RCALL  01B6
0606:  MOVFF  03,6B
060A:  MOVFF  02,6A
060E:  MOVFF  01,69
0612:  MOVFF  00,68
0616:  MOVFF  36,6D
061A:  MOVFF  35,6C
061E:  RCALL  016E
0620:  MOVFF  26,6F
0624:  MOVFF  25,6E
0628:  MOVFF  24,6D
062C:  MOVFF  23,6C
0630:  MOVFF  03,73
0634:  MOVFF  02,72
0638:  MOVFF  01,71
063C:  MOVFF  00,70
0640:  RCALL  01B6
0642:  BCF    FD8.1
0644:  MOVFF  6B,6F
0648:  MOVFF  6A,6E
064C:  MOVFF  69,6D
0650:  MOVFF  68,6C
0654:  MOVFF  03,73
0658:  MOVFF  02,72
065C:  MOVFF  01,71
0660:  MOVFF  00,70
0664:  RCALL  02A8
0666:  MOVFF  03,6B
066A:  MOVFF  02,6A
066E:  MOVFF  01,69
0672:  MOVFF  00,68
0676:  MOVFF  3A,6D
067A:  MOVFF  39,6C
067E:  RCALL  016E
0680:  MOVFF  2A,6F
0684:  MOVFF  29,6E
0688:  MOVFF  28,6D
068C:  MOVFF  27,6C
0690:  MOVFF  03,73
0694:  MOVFF  02,72
0698:  MOVFF  01,71
069C:  MOVFF  00,70
06A0:  RCALL  01B6
06A2:  BCF    FD8.1
06A4:  MOVFF  6B,6F
06A8:  MOVFF  6A,6E
06AC:  MOVFF  69,6D
06B0:  MOVFF  68,6C
06B4:  MOVFF  03,73
06B8:  MOVFF  02,72
06BC:  MOVFF  01,71
06C0:  MOVFF  00,70
06C4:  RCALL  02A8
06C6:  MOVFF  03,2E
06CA:  MOVFF  02,2D
06CE:  MOVFF  01,2C
06D2:  MOVFF  00,2B
....................      duty1=pid1;    
06D6:  MOVFF  2E,6B
06DA:  MOVFF  2D,6A
06DE:  MOVFF  2C,69
06E2:  MOVFF  2B,68
06E6:  RCALL  0512
06E8:  MOVFF  02,3E
06EC:  MOVFF  01,3D
....................      if (duty1 > 0)   dir1 = 0; 
06F0:  BTFSC  3E.7
06F2:  BRA    0700
06F4:  MOVF   3E,F
06F6:  BNZ   06FE
06F8:  MOVF   3D,W
06FA:  SUBLW  00
06FC:  BC    0700
06FE:  BCF    F82.3
....................      if (duty1 <  0)    dir1 = 1; 
0700:  BTFSS  3E.7
0702:  BRA    0706
0704:  BSF    F82.3
....................      duty1= abs(duty1); 
0706:  MOVFF  3E,03
070A:  MOVF   3D,W
070C:  BTFSS  3E.7
070E:  BRA    0720
0710:  MOVLW  00
0712:  BSF    FD8.0
0714:  SUBFWB 3D,W
0716:  MOVWF  00
0718:  MOVLW  00
071A:  SUBFWB 3E,W
071C:  MOVWF  03
071E:  MOVF   00,W
0720:  MOVWF  3D
0722:  MOVFF  03,3E
....................      if(duty1>5) duty1+=200; 
0726:  BTFSC  3E.7
0728:  BRA    073C
072A:  MOVF   3E,F
072C:  BNZ   0734
072E:  MOVF   3D,W
0730:  SUBLW  05
0732:  BC    073C
0734:  MOVLW  C8
0736:  ADDWF  3D,F
0738:  MOVLW  00
073A:  ADDWFC 3E,F
....................      if(duty1>vt1) duty1=vt1; 
073C:  BTFSS  x67.7
073E:  BRA    0746
0740:  BTFSS  3E.7
0742:  BRA    0758
0744:  BRA    074A
0746:  BTFSC  3E.7
0748:  BRA    0760
074A:  MOVF   x67,W
074C:  SUBWF  3E,W
074E:  BNC   0760
0750:  BNZ   0758
0752:  MOVF   3D,W
0754:  SUBWF  x66,W
0756:  BC    0760
0758:  MOVFF  67,3E
075C:  MOVFF  66,3D
....................      set_pwm1_duty (duty1); 
0760:  MOVFF  3E,02
0764:  MOVFF  3D,01
0768:  RRCF   02,F
076A:  RRCF   01,F
076C:  RRCF   02,F
076E:  RRCF   01,F
0770:  RRCF   02,F
0772:  MOVFF  01,FBE
0776:  RRCF   02,F
0778:  RRCF   02,W
077A:  ANDLW  30
077C:  MOVWF  00
077E:  MOVF   FBD,W
0780:  ANDLW  CF
0782:  IORWF  00,W
0784:  MOVWF  FBD
0786:  GOTO   09E0 (RETURN)
....................      } 
....................       
.................... /// PID DONG CO 2 ////////////////// 
.................... signed int16 realvt2, errs2=0, err2, delta2=0, epre2=0, duty2 ; 
.................... void piddc2(signed int16 setvt2, signed int16 vt2) 
....................      { 
....................      br2=0; 
078A:  BCF    F84.1
....................      realvt2 =  En2;  
078C:  MOVFF  1E,4A
0790:  MOVFF  1D,49
....................      err2 = setvt2 - realvt2; 
0794:  MOVF   49,W
0796:  SUBWF  x64,W
0798:  MOVWF  4D
079A:  MOVF   4A,W
079C:  SUBWFB x65,W
079E:  MOVWF  4E
....................      if(Ti2>=2) 
07A0:  MOVF   40,W
07A2:  SUBLW  01
07A4:  BC    0812
....................      { 
....................        Ti2=0; 
07A6:  CLRF   40
....................        if((err2>-20)&&(err2<20)) errs2 += err2; 
07A8:  BTFSS  4E.7
07AA:  BRA    07BC
07AC:  MOVF   4E,W
07AE:  SUBLW  FE
07B0:  BC    07D2
07B2:  XORLW  FF
07B4:  BNZ   07BC
07B6:  MOVF   4D,W
07B8:  SUBLW  EC
07BA:  BC    07D2
07BC:  BTFSC  4E.7
07BE:  BRA    07CA
07C0:  MOVF   4E,F
07C2:  BNZ   07D2
07C4:  MOVF   4D,W
07C6:  SUBLW  13
07C8:  BNC   07D2
07CA:  MOVF   4D,W
07CC:  ADDWF  4B,F
07CE:  MOVF   4E,W
07D0:  ADDWFC 4C,F
....................        if (errs2 > 200 ) errs2=200; 
07D2:  BTFSC  4C.7
07D4:  BRA    07E6
07D6:  MOVF   4C,F
07D8:  BNZ   07E0
07DA:  MOVF   4B,W
07DC:  SUBLW  C8
07DE:  BC    07E6
07E0:  CLRF   4C
07E2:  MOVLW  C8
07E4:  MOVWF  4B
....................        if (errs2 < -200 ) errs2=-200; 
07E6:  BTFSS  4C.7
07E8:  BRA    07FE
07EA:  MOVF   4C,W
07EC:  SUBLW  FF
07EE:  BNC   07FE
07F0:  BNZ   07F8
07F2:  MOVF   4B,W
07F4:  SUBLW  37
07F6:  BNC   07FE
07F8:  SETF   4C
07FA:  MOVLW  38
07FC:  MOVWF  4B
....................        delta2 = err2-epre2; 
07FE:  MOVF   51,W
0800:  SUBWF  4D,W
0802:  MOVWF  4F
0804:  MOVF   52,W
0806:  SUBWFB 4E,W
0808:  MOVWF  50
....................        epre2=err2; 
080A:  MOVFF  4E,52
080E:  MOVFF  4D,51
....................      } 
....................    
....................      pid2 =kp*err2 + ki*errs2+kd*delta2;  
0812:  MOVFF  4E,6D
0816:  MOVFF  4D,6C
081A:  RCALL  016E
081C:  MOVFF  22,6F
0820:  MOVFF  21,6E
0824:  MOVFF  20,6D
0828:  MOVFF  1F,6C
082C:  MOVFF  03,73
0830:  MOVFF  02,72
0834:  MOVFF  01,71
0838:  MOVFF  00,70
083C:  RCALL  01B6
083E:  MOVFF  03,6B
0842:  MOVFF  02,6A
0846:  MOVFF  01,69
084A:  MOVFF  00,68
084E:  MOVFF  4C,6D
0852:  MOVFF  4B,6C
0856:  RCALL  016E
0858:  MOVFF  26,6F
085C:  MOVFF  25,6E
0860:  MOVFF  24,6D
0864:  MOVFF  23,6C
0868:  MOVFF  03,73
086C:  MOVFF  02,72
0870:  MOVFF  01,71
0874:  MOVFF  00,70
0878:  RCALL  01B6
087A:  BCF    FD8.1
087C:  MOVFF  6B,6F
0880:  MOVFF  6A,6E
0884:  MOVFF  69,6D
0888:  MOVFF  68,6C
088C:  MOVFF  03,73
0890:  MOVFF  02,72
0894:  MOVFF  01,71
0898:  MOVFF  00,70
089C:  RCALL  02A8
089E:  MOVFF  03,6B
08A2:  MOVFF  02,6A
08A6:  MOVFF  01,69
08AA:  MOVFF  00,68
08AE:  MOVFF  50,6D
08B2:  MOVFF  4F,6C
08B6:  RCALL  016E
08B8:  MOVFF  2A,6F
08BC:  MOVFF  29,6E
08C0:  MOVFF  28,6D
08C4:  MOVFF  27,6C
08C8:  MOVFF  03,73
08CC:  MOVFF  02,72
08D0:  MOVFF  01,71
08D4:  MOVFF  00,70
08D8:  RCALL  01B6
08DA:  BCF    FD8.1
08DC:  MOVFF  6B,6F
08E0:  MOVFF  6A,6E
08E4:  MOVFF  69,6D
08E8:  MOVFF  68,6C
08EC:  MOVFF  03,73
08F0:  MOVFF  02,72
08F4:  MOVFF  01,71
08F8:  MOVFF  00,70
08FC:  RCALL  02A8
08FE:  MOVFF  03,32
0902:  MOVFF  02,31
0906:  MOVFF  01,30
090A:  MOVFF  00,2F
....................      duty2=pid2;     
090E:  MOVFF  32,6B
0912:  MOVFF  31,6A
0916:  MOVFF  30,69
091A:  MOVFF  2F,68
091E:  RCALL  0512
0920:  MOVFF  02,54
0924:  MOVFF  01,53
....................      if (duty2 > 0)   dir2 = 1; 
0928:  BTFSC  54.7
092A:  BRA    0938
092C:  MOVF   54,F
092E:  BNZ   0936
0930:  MOVF   53,W
0932:  SUBLW  00
0934:  BC    0938
0936:  BSF    F82.0
....................      if (duty2 <  0)    dir2 = 0; 
0938:  BTFSS  54.7
093A:  BRA    093E
093C:  BCF    F82.0
....................      duty2= abs(duty2); 
093E:  MOVFF  54,03
0942:  MOVF   53,W
0944:  BTFSS  54.7
0946:  BRA    0958
0948:  MOVLW  00
094A:  BSF    FD8.0
094C:  SUBFWB 53,W
094E:  MOVWF  00
0950:  MOVLW  00
0952:  SUBFWB 54,W
0954:  MOVWF  03
0956:  MOVF   00,W
0958:  MOVWF  53
095A:  MOVFF  03,54
....................      if(duty2>5) duty2+=200; 
095E:  BTFSC  54.7
0960:  BRA    0974
0962:  MOVF   54,F
0964:  BNZ   096C
0966:  MOVF   53,W
0968:  SUBLW  05
096A:  BC    0974
096C:  MOVLW  C8
096E:  ADDWF  53,F
0970:  MOVLW  00
0972:  ADDWFC 54,F
....................      if(duty2>vt2) duty2=vt2; 
0974:  BTFSS  x67.7
0976:  BRA    097E
0978:  BTFSS  54.7
097A:  BRA    0990
097C:  BRA    0982
097E:  BTFSC  54.7
0980:  BRA    0998
0982:  MOVF   x67,W
0984:  SUBWF  54,W
0986:  BNC   0998
0988:  BNZ   0990
098A:  MOVF   53,W
098C:  SUBWF  x66,W
098E:  BC    0998
0990:  MOVFF  67,54
0994:  MOVFF  66,53
....................      set_pwm2_duty (duty2); 
0998:  MOVFF  54,02
099C:  MOVFF  53,01
09A0:  RRCF   02,F
09A2:  RRCF   01,F
09A4:  RRCF   02,F
09A6:  RRCF   01,F
09A8:  RRCF   02,F
09AA:  MOVFF  01,FBB
09AE:  RRCF   02,F
09B0:  RRCF   02,W
09B2:  ANDLW  30
09B4:  MOVWF  00
09B6:  MOVF   FBA,W
09B8:  ANDLW  CF
09BA:  IORWF  00,W
09BC:  MOVWF  FBA
09BE:  GOTO   09F2 (RETURN)
....................      } 
....................       
....................  
....................  
....................  
.................... ///// CHUONG TRINH QUET PHIM 
.................... int8 demct=0, chonct=0; 
....................  
.................... ///// NGAT TIMER0 
.................... volatile int8 demservo, xungleo=0; 
.................... #int_timer0 
.................... void ngat_timer0(void)  
....................    { 
....................    set_timer0(5); 
*
014E:  CLRF   FD7
0150:  MOVLW  05
0152:  MOVWF  FD6
....................    demservo++; 
0154:  INCF   57,F
....................    if (demservo>=200) 
0156:  MOVF   57,W
0158:  SUBLW  C7
015A:  BC    0160
....................       { 
....................       demservo=0; 
015C:  CLRF   57
....................       output_high(pin_d6); 
015E:  BSF    F8C.6
....................       } 
....................    if (demservo >=xungleo) output_low(pin_d6); 
0160:  MOVF   58,W
0162:  SUBWF  57,W
0164:  BNC   0168
0166:  BCF    F8C.6
....................        
....................    }    
....................       
.................... ///// NGAT TIMER1 PID 
0168:  BCF    FF2.2
016A:  GOTO   0084
.................... #int_timer1 
.................... void ngat_timer1(void)  
....................    { 
....................       set_timer1(59286); 
*
09C2:  MOVLW  E7
09C4:  MOVWF  FCF
09C6:  MOVLW  96
09C8:  MOVWF  FCE
....................       Ti1++; 
09CA:  INCF   3F,F
....................       Ti2++; 
09CC:  INCF   40,F
....................       piddc1(setvt1,vt1); 
09CE:  MOVFF  42,65
09D2:  MOVFF  41,64
09D6:  MOVFF  46,67
09DA:  MOVFF  45,66
09DE:  BRA    054A
....................       piddc2(setvt2,vt2); 
09E0:  MOVFF  44,65
09E4:  MOVFF  43,64
09E8:  MOVFF  48,67
09EC:  MOVFF  47,66
09F0:  BRA    078A
....................        
....................    } 
....................     
.................... ///// NGAT TIMER2 LEO THANG 
.................... /* 
.................... char demxleo, xungleo; 
.................... #int_timer2 
.................... void ngat_timer2(void)  
....................    { 
....................    demxleo++; 
....................    if (demxleo>=200) 
....................       { 
....................       demxleo=0; 
....................       output_high(pin_d6); 
....................       } 
....................    if (demxleo >=xungleo) output_low(pin_d6); 
....................    } 
....................  */  
.................... ///// NGAT TIMER5 QUET PHIM  
09F2:  BCF    F9E.0
09F4:  GOTO   0084
.................... #int_timer5 
.................... void ngat_timer5(void)  
....................    { 
....................       set_timer5(53035); 
*
0A44:  MOVLW  CF
0A46:  MOVWF  F88
0A48:  MOVLW  2B
0A4A:  MOVWF  F87
....................       demct++; 
0A4C:  INCF   55,F
....................       if (demct==2) { beep(1,50); } 
0A4E:  MOVF   55,W
0A50:  SUBLW  02
0A52:  BNZ   0A5E
0A54:  MOVLW  01
0A56:  MOVWF  x64
0A58:  MOVLW  32
0A5A:  MOVWF  x65
0A5C:  RCALL  0A20
....................       if (demct==50) { beep(1,50); } 
0A5E:  MOVF   55,W
0A60:  SUBLW  32
0A62:  BNZ   0A6E
0A64:  MOVLW  01
0A66:  MOVWF  x64
0A68:  MOVLW  32
0A6A:  MOVWF  x65
0A6C:  RCALL  0A20
....................       if (demct==100) { beep(1,50); } 
0A6E:  MOVF   55,W
0A70:  SUBLW  64
0A72:  BNZ   0A7E
0A74:  MOVLW  01
0A76:  MOVWF  x64
0A78:  MOVLW  32
0A7A:  MOVWF  x65
0A7C:  RCALL  0A20
....................       if (demct==150) { beep(1,50); } 
0A7E:  MOVF   55,W
0A80:  SUBLW  96
0A82:  BNZ   0A8E
0A84:  MOVLW  01
0A86:  MOVWF  x64
0A88:  MOVLW  32
0A8A:  MOVWF  x65
0A8C:  RCALL  0A20
....................       if (demct>200) {demct=0; disable_interrupts(int_timer5); } 
0A8E:  MOVF   55,W
0A90:  SUBLW  C8
0A92:  BC    0A98
0A94:  CLRF   55
0A96:  BCF    FA3.0
....................        
....................        
....................    }    
....................  
.................... ///// KHAI BAO NHIEM VU 
.................... //#include <resetall.c> 
0A98:  BCF    FA4.0
0A9A:  GOTO   0084
.................... #include <resetvan.c> 
....................  
....................  
....................  
.................... void resetvan() 
.................... { 
.................... disable_interrupts(int_timer5); 
*
0BCE:  BCF    FA3.0
.................... disable_interrupts(int_timer1); 
0BD0:  BCF    F9D.0
.................... demct=0;  
0BD2:  CLRF   55
.................... delay_ms(1000); 
0BD4:  MOVLW  04
0BD6:  MOVWF  5B
0BD8:  CLRF   16
0BDA:  BTFSC  FF2.7
0BDC:  BSF    16.7
0BDE:  BCF    FF2.7
0BE0:  MOVLW  FA
0BE2:  MOVWF  x68
0BE4:  RCALL  09F8
0BE6:  BTFSC  16.7
0BE8:  BSF    FF2.7
0BEA:  DECFSZ 5B,F
0BEC:  BRA    0BD8
0BEE:  CLRF   16
0BF0:  BTFSC  FF2.7
0BF2:  BSF    16.7
0BF4:  BCF    FF2.7
.................... beep(1,100); 
0BF6:  MOVLW  01
0BF8:  MOVWF  x64
0BFA:  MOVLW  64
0BFC:  MOVWF  x65
0BFE:  RCALL  0A20
0C00:  BTFSC  16.7
0C02:  BSF    FF2.7
.................... chonct=0; 
0C04:  CLRF   56
.................... Ti1=0; 
0C06:  CLRF   3F
.................... Ti2=0; 
0C08:  CLRF   40
.................... vantay1=vantay2=vancanh1=vancanh2=0; 
0C0A:  BCF    F80.0
0C0C:  BCF    F80.1
0C0E:  BCF    F84.0
0C10:  BCF    F80.5
.................... delay_ms(1000); 
0C12:  MOVLW  04
0C14:  MOVWF  5B
0C16:  CLRF   16
0C18:  BTFSC  FF2.7
0C1A:  BSF    16.7
0C1C:  BCF    FF2.7
0C1E:  MOVLW  FA
0C20:  MOVWF  x68
0C22:  RCALL  09F8
0C24:  BTFSC  16.7
0C26:  BSF    FF2.7
0C28:  DECFSZ 5B,F
0C2A:  BRA    0C16
.................... while (ctc1==1) { dc1t(370); } 
0C2C:  BTFSS  F81.3
0C2E:  BRA    0C3C
0C30:  MOVLW  01
0C32:  MOVWF  x60
0C34:  MOVLW  72
0C36:  MOVWF  5F
0C38:  RCALL  0B0C
0C3A:  BRA    0C2C
.................... resetdc1(); 
0C3C:  RCALL  0B4E
0C3E:  CLRF   16
0C40:  BTFSC  FF2.7
0C42:  BSF    16.7
0C44:  BCF    FF2.7
.................... beep(1,100); 
0C46:  MOVLW  01
0C48:  MOVWF  x64
0C4A:  MOVLW  64
0C4C:  MOVWF  x65
0C4E:  RCALL  0A20
0C50:  BTFSC  16.7
0C52:  BSF    FF2.7
.................... while (ctc2==1) { dc2t(400); } 
0C54:  BTFSS  F81.1
0C56:  BRA    0C64
0C58:  MOVLW  01
0C5A:  MOVWF  5C
0C5C:  MOVLW  90
0C5E:  MOVWF  5B
0C60:  BRA    0B6C
0C62:  BRA    0C54
.................... resetdc2(); 
0C64:  RCALL  0BB0
0C66:  CLRF   16
0C68:  BTFSC  FF2.7
0C6A:  BSF    16.7
0C6C:  BCF    FF2.7
.................... beep(1,100); 
0C6E:  MOVLW  01
0C70:  MOVWF  x64
0C72:  MOVLW  64
0C74:  MOVWF  x65
0C76:  RCALL  0A20
0C78:  BTFSC  16.7
0C7A:  BSF    FF2.7
.................... qei_set_count(0); 
0C7C:  CLRF   F67
0C7E:  CLRF   F66
.................... En2=0; 
0C80:  CLRF   1E
0C82:  CLRF   1D
.................... setvt1=0; 
0C84:  CLRF   42
0C86:  CLRF   41
.................... setvt2=0; 
0C88:  CLRF   44
0C8A:  CLRF   43
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
0C8C:  BSF    F80.2
0C8E:  BSF    F80.0
0C90:  BSF    F80.1
0C92:  BSF    F84.0
0C94:  BSF    F80.5
0C96:  GOTO   11BE (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... #include <nhiemvu2.c> 
....................  
.................... ///// NHIEM VU 2 
....................  
.................... void nhiemvu2() 
.................... { 
.................... disable_interrupts(int_timer5); 
0C9A:  BCF    FA3.0
.................... demct=0;  
0C9C:  CLRF   55
.................... delay_ms(2000); 
0C9E:  MOVLW  08
0CA0:  MOVWF  5B
0CA2:  CLRF   16
0CA4:  BTFSC  FF2.7
0CA6:  BSF    16.7
0CA8:  BCF    FF2.7
0CAA:  MOVLW  FA
0CAC:  MOVWF  x68
0CAE:  RCALL  09F8
0CB0:  BTFSC  16.7
0CB2:  BSF    FF2.7
0CB4:  DECFSZ 5B,F
0CB6:  BRA    0CA2
0CB8:  CLRF   16
0CBA:  BTFSC  FF2.7
0CBC:  BSF    16.7
0CBE:  BCF    FF2.7
.................... beep(2,100); 
0CC0:  MOVLW  02
0CC2:  MOVWF  x64
0CC4:  MOVLW  64
0CC6:  MOVWF  x65
0CC8:  RCALL  0A20
0CCA:  BTFSC  16.7
0CCC:  BSF    FF2.7
0CCE:  GOTO   11E0 (RETURN)
....................  
.................... /* 
.................... chonct=0; 
.................... while(cten==1){delay_ms(50);} 
....................  
.................... if(cten==0) 
....................    { 
....................    delay_ms(20); 
....................    if(cten==0) 
....................       { 
....................       vanduoi=0; 
....................       } 
....................    } 
.................... while(cten==0) {delay_ms(50);} 
....................  
.................... while(cten==1) {delay_ms(50);} 
.................... if(cten==0) 
....................    { 
....................    delay_ms(20); 
....................    if(cten==0) 
....................       { 
....................       vanduoi=0; 
....................       } 
....................    } 
....................  */   
....................  
.................... } 
....................  
....................  
.................... #include <nhiemvu3.c> 
....................  
.................... ///// NHIEM VU 3 
....................  
.................... void nhiemvu3() 
.................... { 
.................... disable_interrupts(int_timer5); 
.................... setup_timer_2 (t2_div_by_1, 249, 1); 
.................... setup_ccp1 (ccp_pwm); 
.................... setup_ccp2 (ccp_pwm); 
.................... enable_interrupts(int_timer1); 
.................... beep(3,100); 
.................... chonct=0; 
.................... qei_set_count(0); 
.................... En2=0; 
.................... Ti1=0; 
.................... Ti2=0; 
.................... setvt1=0; 
.................... setvt2=0; 
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
.................... vancanh1=vancanh2=0; 
.................... setvt1=250; 
.................... setvt2=280; 
.................... vantay1=vantay2=0; 
....................  
.................... while (ctsel==1) {delay_ms(50);} 
....................  
.................... if (ctsel==0) { vantay1=1; beep(1,100); } 
....................  
.................... while (cten==1) {delay_ms(50);} 
....................  
.................... if (cten==0) { setvt1=280; } 
....................  
.................... while (ctt2==1) {delay_ms(50);} 
....................  
.................... if (ctt2==0) {vantay2=1; beep(1,100); } 
....................  
.................... delay_ms(1000); 
....................  
.................... vantay1=0; 
....................  
.................... setvt2=250; 
.................... delay_ms(1500); 
.................... setvt1=0; 
.................... setvt2=0; 
.................... while (ctt1==1) {delay_ms(50);} 
....................  
.................... if (ctt1==0) {vantay1=1; beep(1,100); } 
.................... delay_ms(2000); 
.................... vantay2=0; 
.................... setvt1=30; 
.................... delay_ms(1500); 
.................... setvt1=280; 
.................... setvt2=280; 
....................  
.................... while (ctt2==1) {delay_ms(50);} 
.................... if (ctt2==0) {vantay2=1; beep(1,100); }  
.................... delay_ms(2000); 
....................  
.................... vantay1=0; 
.................... setvt2=240; 
.................... delay_ms(4000); 
.................... disable_interrupts(int_timer1); 
.................... resetdc1(); 
.................... resetdc2(); 
.................... while(cten==1) {delay_ms(50);} 
....................  
.................... disable_interrupts(int_timer1); 
.................... enable_interrupts(int_timer5); 
.................... clear_interrupt(int_timer5); 
.................... set_timer5(59286); 
.................... } 
....................  
....................  
.................... #include <nhiemvu3x.c> 
.................... ///// NHIEM VU 3X 
....................  
.................... void nhiemvu3x() 
.................... { 
.................... signed int16 temp1, temp2; 
.................... disable_interrupts(int_timer5); 
*
0D14:  BCF    FA3.0
.................... demct=0;  
0D16:  CLRF   55
.................... delay_ms(2000); 
0D18:  MOVLW  08
0D1A:  MOVWF  5F
0D1C:  CLRF   16
0D1E:  BTFSC  FF2.7
0D20:  BSF    16.7
0D22:  BCF    FF2.7
0D24:  MOVLW  FA
0D26:  MOVWF  x68
0D28:  RCALL  09F8
0D2A:  BTFSC  16.7
0D2C:  BSF    FF2.7
0D2E:  DECFSZ 5F,F
0D30:  BRA    0D1C
0D32:  CLRF   16
0D34:  BTFSC  FF2.7
0D36:  BSF    16.7
0D38:  BCF    FF2.7
.................... beep(3,100); 
0D3A:  MOVLW  03
0D3C:  MOVWF  x64
0D3E:  MOVLW  64
0D40:  MOVWF  x65
0D42:  RCALL  0A20
0D44:  BTFSC  16.7
0D46:  BSF    FF2.7
.................... setup_timer_2 (t2_div_by_1, 249, 1); 
0D48:  MOVLW  00
0D4A:  IORLW  04
0D4C:  MOVWF  FCA
0D4E:  MOVLW  F9
0D50:  MOVWF  FCB
.................... setup_ccp1 (ccp_pwm); 
0D52:  BCF    F8B.2
0D54:  MOVLW  0C
0D56:  MOVWF  FBD
.................... setup_ccp2 (ccp_pwm); 
0D58:  BCF    F8B.1
0D5A:  MOVWF  FBA
.................... enable_interrupts(int_timer1); 
0D5C:  BSF    F9D.0
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
0D5E:  BSF    F80.2
0D60:  BSF    F80.0
0D62:  BSF    F80.1
0D64:  BSF    F84.0
0D66:  BSF    F80.5
.................... vancanh1=vancanh2=0; 
0D68:  BCF    F80.0
0D6A:  BCF    F80.1
.................... setvt1=280; 
0D6C:  MOVLW  01
0D6E:  MOVWF  42
0D70:  MOVLW  18
0D72:  MOVWF  41
.................... setvt2=230; 
0D74:  CLRF   44
0D76:  MOVLW  E6
0D78:  MOVWF  43
.................... vantay1=vantay2=0; 
0D7A:  BCF    F84.0
0D7C:  BCF    F80.5
....................  
.................... while (ctsel==1) {} 
0D7E:  BTFSC  F81.7
0D80:  BRA    0D7E
....................  
.................... if (ctsel==0) { vantay2=1; beep(1,100); } 
0D82:  BTFSC  F81.7
0D84:  BRA    0D9E
0D86:  BSF    F84.0
0D88:  CLRF   16
0D8A:  BTFSC  FF2.7
0D8C:  BSF    16.7
0D8E:  BCF    FF2.7
0D90:  MOVLW  01
0D92:  MOVWF  x64
0D94:  MOVLW  64
0D96:  MOVWF  x65
0D98:  RCALL  0A20
0D9A:  BTFSC  16.7
0D9C:  BSF    FF2.7
.................... disable_interrupts(int_timer1); 
0D9E:  BCF    F9D.0
.................... resetdc1(); 
0DA0:  RCALL  0B4E
.................... resetdc2(); 
0DA2:  RCALL  0BB0
....................  
.................... while (cten==1) {} 
0DA4:  BTFSC  F81.6
0DA6:  BRA    0DA4
....................  
.................... if (cten==0) { dc2n(700); } 
0DA8:  BTFSC  F81.6
0DAA:  BRA    0DB6
0DAC:  MOVLW  02
0DAE:  MOVWF  x60
0DB0:  MOVLW  BC
0DB2:  MOVWF  5F
0DB4:  RCALL  0CD2
....................  
.................... while (ctt1==1) { if ( En2>285 ) {resetdc2(); beep(10,100);} } 
0DB6:  BTFSS  F81.2
0DB8:  BRA    0DE8
0DBA:  BTFSC  1E.7
0DBC:  BRA    0DE6
0DBE:  MOVF   1E,W
0DC0:  SUBLW  00
0DC2:  BC    0DE6
0DC4:  XORLW  FF
0DC6:  BNZ   0DCE
0DC8:  MOVF   1D,W
0DCA:  SUBLW  1D
0DCC:  BC    0DE6
0DCE:  RCALL  0BB0
0DD0:  CLRF   16
0DD2:  BTFSC  FF2.7
0DD4:  BSF    16.7
0DD6:  BCF    FF2.7
0DD8:  MOVLW  0A
0DDA:  MOVWF  x64
0DDC:  MOVLW  64
0DDE:  MOVWF  x65
0DE0:  RCALL  0A20
0DE2:  BTFSC  16.7
0DE4:  BSF    FF2.7
0DE6:  BRA    0DB6
....................  
.................... if (ctt1==0) {vantay1=1; resetdc2(); beep(1,100); } 
0DE8:  BTFSC  F81.2
0DEA:  BRA    0E06
0DEC:  BSF    F80.5
0DEE:  RCALL  0BB0
0DF0:  CLRF   16
0DF2:  BTFSC  FF2.7
0DF4:  BSF    16.7
0DF6:  BCF    FF2.7
0DF8:  MOVLW  01
0DFA:  MOVWF  x64
0DFC:  MOVLW  64
0DFE:  MOVWF  x65
0E00:  RCALL  0A20
0E02:  BTFSC  16.7
0E04:  BSF    FF2.7
....................  
.................... delay_ms(1000); 
0E06:  MOVLW  04
0E08:  MOVWF  5F
0E0A:  CLRF   16
0E0C:  BTFSC  FF2.7
0E0E:  BSF    16.7
0E10:  BCF    FF2.7
0E12:  MOVLW  FA
0E14:  MOVWF  x68
0E16:  RCALL  09F8
0E18:  BTFSC  16.7
0E1A:  BSF    FF2.7
0E1C:  DECFSZ 5F,F
0E1E:  BRA    0E0A
.................... temp2=En2; 
0E20:  MOVFF  1E,5E
0E24:  MOVFF  1D,5D
.................... vantay2=0; 
0E28:  BCF    F84.0
.................... enable_interrupts(int_timer1); 
0E2A:  BSF    F9D.0
.................... setvt2=temp2; 
0E2C:  MOVFF  5E,44
0E30:  MOVFF  5D,43
.................... setvt1=250; 
0E34:  CLRF   42
0E36:  MOVLW  FA
0E38:  MOVWF  41
.................... while ( qei_get_count() >252) {} 
0E3A:  MOVFF  F67,01
0E3E:  MOVFF  F66,00
0E42:  MOVFF  F67,03
0E46:  MOVF   03,W
0E48:  SUBWF  01,W
0E4A:  BZ    0E50
0E4C:  MOVFF  F66,00
0E50:  MOVF   00,W
0E52:  MOVWF  5F
0E54:  MOVFF  03,60
0E58:  MOVF   x60,F
0E5A:  BNZ   0E62
0E5C:  MOVF   5F,W
0E5E:  SUBLW  FC
0E60:  BC    0E64
0E62:  BRA    0E3A
....................  
.................... setvt1=50; 
0E64:  CLRF   42
0E66:  MOVLW  32
0E68:  MOVWF  41
.................... setvt2=0; 
0E6A:  CLRF   44
0E6C:  CLRF   43
.................... while ( qei_get_count() >50) {} 
0E6E:  MOVFF  F67,01
0E72:  MOVFF  F66,00
0E76:  MOVFF  F67,03
0E7A:  MOVF   03,W
0E7C:  SUBWF  01,W
0E7E:  BZ    0E84
0E80:  MOVFF  F66,00
0E84:  MOVF   00,W
0E86:  MOVWF  5F
0E88:  MOVFF  03,60
0E8C:  MOVF   x60,F
0E8E:  BNZ   0E96
0E90:  MOVF   5F,W
0E92:  SUBLW  32
0E94:  BC    0E98
0E96:  BRA    0E6E
....................  
.................... disable_interrupts(int_timer1); 
0E98:  BCF    F9D.0
.................... resetdc1(); 
0E9A:  RCALL  0B4E
.................... resetdc2(); 
0E9C:  RCALL  0BB0
.................... dc1t(700); 
0E9E:  MOVLW  02
0EA0:  MOVWF  x60
0EA2:  MOVLW  BC
0EA4:  MOVWF  5F
0EA6:  RCALL  0B0C
.................... while (ctt2==1) { if ( qei_get_count() <-5 ) {resetdc1(); beep(10,100);} } 
0EA8:  BTFSS  F81.0
0EAA:  BRA    0ECC
0EAC:  MOVFF  F67,01
0EB0:  MOVFF  F66,00
0EB4:  MOVFF  F67,03
0EB8:  MOVF   03,W
0EBA:  SUBWF  01,W
0EBC:  BZ    0EC2
0EBE:  MOVFF  F66,00
0EC2:  MOVF   00,W
0EC4:  MOVWF  5F
0EC6:  MOVFF  03,60
0ECA:  BRA    0EA8
....................  
.................... if (ctt2==0) {vantay2=1;resetdc1(); beep(1,100); } 
0ECC:  BTFSC  F81.0
0ECE:  BRA    0EEA
0ED0:  BSF    F84.0
0ED2:  RCALL  0B4E
0ED4:  CLRF   16
0ED6:  BTFSC  FF2.7
0ED8:  BSF    16.7
0EDA:  BCF    FF2.7
0EDC:  MOVLW  01
0EDE:  MOVWF  x64
0EE0:  MOVLW  64
0EE2:  MOVWF  x65
0EE4:  RCALL  0A20
0EE6:  BTFSC  16.7
0EE8:  BSF    FF2.7
....................  
.................... delay_ms(1000); 
0EEA:  MOVLW  04
0EEC:  MOVWF  5F
0EEE:  CLRF   16
0EF0:  BTFSC  FF2.7
0EF2:  BSF    16.7
0EF4:  BCF    FF2.7
0EF6:  MOVLW  FA
0EF8:  MOVWF  x68
0EFA:  RCALL  09F8
0EFC:  BTFSC  16.7
0EFE:  BSF    FF2.7
0F00:  DECFSZ 5F,F
0F02:  BRA    0EEE
.................... temp1=qei_get_count(); 
0F04:  MOVFF  F67,01
0F08:  MOVFF  F66,00
0F0C:  MOVFF  F67,03
0F10:  MOVF   03,W
0F12:  SUBWF  01,W
0F14:  BZ    0F1A
0F16:  MOVFF  F66,00
0F1A:  MOVF   00,W
0F1C:  MOVWF  5B
0F1E:  MOVFF  03,5C
.................... vantay1=0; 
0F22:  BCF    F80.5
.................... enable_interrupts(int_timer1); 
0F24:  BSF    F9D.0
.................... setvt1=temp1; 
0F26:  MOVFF  5C,42
0F2A:  MOVFF  5B,41
.................... setvt2=30; 
0F2E:  CLRF   44
0F30:  MOVLW  1E
0F32:  MOVWF  43
.................... while (En2 <30) {} 
0F34:  BTFSC  1E.7
0F36:  BRA    0F42
0F38:  MOVF   1E,F
0F3A:  BNZ   0F44
0F3C:  MOVF   1D,W
0F3E:  SUBLW  1D
0F40:  BTFSC  FD8.0
0F42:  BRA    0F34
....................  
.................... setvt1=280; 
0F44:  MOVLW  01
0F46:  MOVWF  42
0F48:  MOVLW  18
0F4A:  MOVWF  41
.................... setvt2=250; 
0F4C:  CLRF   44
0F4E:  MOVLW  FA
0F50:  MOVWF  43
....................  
.................... while (En2<250) {} 
0F52:  BTFSC  1E.7
0F54:  BRA    0F60
0F56:  MOVF   1E,F
0F58:  BNZ   0F62
0F5A:  MOVF   1D,W
0F5C:  SUBLW  F9
0F5E:  BTFSC  FD8.0
0F60:  BRA    0F52
.................... disable_interrupts(int_timer1); 
0F62:  BCF    F9D.0
.................... resetdc1(); 
0F64:  RCALL  0B4E
.................... resetdc2(); 
0F66:  RCALL  0BB0
.................... dc2n(700); 
0F68:  MOVLW  02
0F6A:  MOVWF  x60
0F6C:  MOVLW  BC
0F6E:  MOVWF  5F
0F70:  RCALL  0CD2
....................  
.................... while (ctt1==1) { if ( En2>295 ) {resetdc2(); beep(10,100);}} 
0F72:  BTFSS  F81.2
0F74:  BRA    0FA4
0F76:  BTFSC  1E.7
0F78:  BRA    0FA2
0F7A:  MOVF   1E,W
0F7C:  SUBLW  00
0F7E:  BC    0FA2
0F80:  XORLW  FF
0F82:  BNZ   0F8A
0F84:  MOVF   1D,W
0F86:  SUBLW  27
0F88:  BC    0FA2
0F8A:  RCALL  0BB0
0F8C:  CLRF   16
0F8E:  BTFSC  FF2.7
0F90:  BSF    16.7
0F92:  BCF    FF2.7
0F94:  MOVLW  0A
0F96:  MOVWF  x64
0F98:  MOVLW  64
0F9A:  MOVWF  x65
0F9C:  RCALL  0A20
0F9E:  BTFSC  16.7
0FA0:  BSF    FF2.7
0FA2:  BRA    0F72
....................  
.................... if (ctt1==0) {vantay1=1;resetdc2(); beep(1,100); }  
0FA4:  BTFSC  F81.2
0FA6:  BRA    0FC2
0FA8:  BSF    F80.5
0FAA:  RCALL  0BB0
0FAC:  CLRF   16
0FAE:  BTFSC  FF2.7
0FB0:  BSF    16.7
0FB2:  BCF    FF2.7
0FB4:  MOVLW  01
0FB6:  MOVWF  x64
0FB8:  MOVLW  64
0FBA:  MOVWF  x65
0FBC:  RCALL  0A20
0FBE:  BTFSC  16.7
0FC0:  BSF    FF2.7
....................  
.................... delay_ms(1000); 
0FC2:  MOVLW  04
0FC4:  MOVWF  5F
0FC6:  CLRF   16
0FC8:  BTFSC  FF2.7
0FCA:  BSF    16.7
0FCC:  BCF    FF2.7
0FCE:  MOVLW  FA
0FD0:  MOVWF  x68
0FD2:  RCALL  09F8
0FD4:  BTFSC  16.7
0FD6:  BSF    FF2.7
0FD8:  DECFSZ 5F,F
0FDA:  BRA    0FC6
.................... temp2=En2; 
0FDC:  MOVFF  1E,5E
0FE0:  MOVFF  1D,5D
.................... vantay2=0; 
0FE4:  BCF    F84.0
.................... enable_interrupts(int_timer1); 
0FE6:  BSF    F9D.0
.................... setvt2=temp2; 
0FE8:  MOVFF  5E,44
0FEC:  MOVFF  5D,43
.................... setvt1=240; 
0FF0:  CLRF   42
0FF2:  MOVLW  F0
0FF4:  MOVWF  41
.................... while ( qei_get_count() > 242) {} 
0FF6:  MOVFF  F67,01
0FFA:  MOVFF  F66,00
0FFE:  MOVFF  F67,03
1002:  MOVF   03,W
1004:  SUBWF  01,W
1006:  BZ    100C
1008:  MOVFF  F66,00
100C:  MOVF   00,W
100E:  MOVWF  5F
1010:  MOVFF  03,60
1014:  MOVF   x60,F
1016:  BNZ   101E
1018:  MOVF   5F,W
101A:  SUBLW  F2
101C:  BC    1020
101E:  BRA    0FF6
.................... disable_interrupts(int_timer1); 
1020:  BCF    F9D.0
.................... resetdc1(); 
1022:  RCALL  0B4E
.................... resetdc2(); 
1024:  RCALL  0BB0
....................  
.................... while (cten==1) {} 
1026:  BTFSC  F81.6
1028:  BRA    1026
102A:  GOTO   1202 (RETURN)
....................  
.................... } 
....................  
....................  
.................... #include <nhiemvu4.c> 
....................  
.................... ///// NHIEM VU 4 
.................... int8 deml=0; 
.................... void nhiemvu4() 
.................... { 
.................... disable_interrupts(int_timer5); 
102E:  BCF    FA3.0
.................... demct=0;  
1030:  CLRF   55
.................... delay_ms(1000); 
1032:  MOVLW  04
1034:  MOVWF  5B
1036:  CLRF   16
1038:  BTFSC  FF2.7
103A:  BSF    16.7
103C:  BCF    FF2.7
103E:  MOVLW  FA
1040:  MOVWF  x68
1042:  RCALL  09F8
1044:  BTFSC  16.7
1046:  BSF    FF2.7
1048:  DECFSZ 5B,F
104A:  BRA    1036
104C:  CLRF   16
104E:  BTFSC  FF2.7
1050:  BSF    16.7
1052:  BCF    FF2.7
.................... beep(4,100); 
1054:  MOVLW  04
1056:  MOVWF  x64
1058:  MOVLW  64
105A:  MOVWF  x65
105C:  RCALL  0A20
105E:  BTFSC  16.7
1060:  BSF    FF2.7
.................... trispwm3=trisdir3=0; 
1062:  BCF    F95.5
1064:  BCF    F95.6
.................... pwm3=dir3=1; 
1066:  BSF    F83.5
1068:  BSF    F83.6
.................... enable_interrupts(int_timer0); 
106A:  BSF    FF2.5
106C:  CLRF   16
106E:  BTFSC  FF2.7
1070:  BSF    16.7
1072:  BCF    FF2.7
.................... delay_ms(100); 
1074:  MOVLW  64
1076:  MOVWF  x68
1078:  RCALL  09F8
107A:  BTFSC  16.7
107C:  BSF    FF2.7
.................... dir3=1; 
107E:  BSF    F83.5
.................... xungleo=190; 
1080:  MOVLW  BE
1082:  MOVWF  58
.................... delay_ms(3000); 
1084:  MOVLW  0C
1086:  MOVWF  5B
1088:  CLRF   16
108A:  BTFSC  FF2.7
108C:  BSF    16.7
108E:  BCF    FF2.7
1090:  MOVLW  FA
1092:  MOVWF  x68
1094:  RCALL  09F8
1096:  BTFSC  16.7
1098:  BSF    FF2.7
109A:  DECFSZ 5B,F
109C:  BRA    1088
109E:  CLRF   16
10A0:  BTFSC  FF2.7
10A2:  BSF    16.7
10A4:  BCF    FF2.7
.................... beep(1,100); 
10A6:  MOVLW  01
10A8:  MOVWF  x64
10AA:  MOVLW  64
10AC:  MOVWF  x65
10AE:  RCALL  0A20
10B0:  BTFSC  16.7
10B2:  BSF    FF2.7
.................... xungleo=190; 
10B4:  MOVLW  BE
10B6:  MOVWF  58
.................... dir3=0; 
10B8:  BCF    F83.5
.................... delay_ms(3000); 
10BA:  MOVLW  0C
10BC:  MOVWF  5B
10BE:  CLRF   16
10C0:  BTFSC  FF2.7
10C2:  BSF    16.7
10C4:  BCF    FF2.7
10C6:  MOVLW  FA
10C8:  MOVWF  x68
10CA:  RCALL  09F8
10CC:  BTFSC  16.7
10CE:  BSF    FF2.7
10D0:  DECFSZ 5B,F
10D2:  BRA    10BE
10D4:  CLRF   16
10D6:  BTFSC  FF2.7
10D8:  BSF    16.7
10DA:  BCF    FF2.7
.................... beep(1,100); 
10DC:  MOVLW  01
10DE:  MOVWF  x64
10E0:  MOVLW  64
10E2:  MOVWF  x65
10E4:  RCALL  0A20
10E6:  BTFSC  16.7
10E8:  BSF    FF2.7
.................... xungleo=200; 
10EA:  MOVLW  C8
10EC:  MOVWF  58
.................... dir3=1; 
10EE:  BSF    F83.5
.................... while (cten==1) {} 
10F0:  BTFSC  F81.6
10F2:  BRA    10F0
10F4:  GOTO   1224 (RETURN)
.................... //while (ctlt==1) { beep(1,100); } //dc1n(600); 
....................  
....................  
....................  
.................... } 
....................  
....................  
....................  
.................... ///// MAIN ///// 
.................... int8 i=0; 
....................  
.................... void main() 
10F8:  CLRF   FF8
10FA:  BCF    FD0.7
10FC:  BSF    07.7
10FE:  CLRF   22
1100:  CLRF   21
1102:  CLRF   20
1104:  MOVLW  80
1106:  MOVWF  1F
1108:  MOVLW  CD
110A:  MOVWF  26
110C:  MOVLW  CC
110E:  MOVWF  25
1110:  MOVLW  4C
1112:  MOVWF  24
1114:  MOVLW  7C
1116:  MOVWF  23
1118:  MOVLW  33
111A:  MOVWF  2A
111C:  MOVWF  29
111E:  MOVWF  28
1120:  MOVLW  7E
1122:  MOVWF  27
1124:  CLRF   36
1126:  CLRF   35
1128:  CLRF   3A
112A:  CLRF   39
112C:  CLRF   3C
112E:  CLRF   3B
1130:  MOVLW  01
1132:  MOVWF  46
1134:  MOVLW  72
1136:  MOVWF  45
1138:  MOVLW  01
113A:  MOVWF  48
113C:  MOVLW  90
113E:  MOVWF  47
1140:  CLRF   4C
1142:  CLRF   4B
1144:  CLRF   50
1146:  CLRF   4F
1148:  CLRF   52
114A:  CLRF   51
114C:  CLRF   55
114E:  CLRF   56
1150:  CLRF   58
1152:  CLRF   59
1154:  CLRF   5A
1156:  BCF    FB9.0
1158:  BCF    FC1.6
115A:  BCF    FC1.7
115C:  MOVLW  00
115E:  MOVWF  FB8
1160:  CLRF   17
1162:  CLRF   18
.................... { 
....................    khoidong();  
1164:  BRA    0A9E
....................    En2=0; 
1166:  CLRF   1E
1168:  CLRF   1D
....................    Ti1=0; 
116A:  CLRF   3F
....................    Ti2=0; 
116C:  CLRF   40
....................    setvt1=0; 
116E:  CLRF   42
1170:  CLRF   41
....................    setvt2=0; 
1172:  CLRF   44
1174:  CLRF   43
....................    chonct=0; 
1176:  CLRF   56
1178:  CLRF   16
117A:  BTFSC  FF2.7
117C:  BSF    16.7
117E:  BCF    FF2.7
....................    beep(2,100);  
1180:  MOVLW  02
1182:  MOVWF  x64
1184:  MOVLW  64
1186:  MOVWF  x65
1188:  RCALL  0A20
118A:  BTFSC  16.7
118C:  BSF    FF2.7
....................         
.................... while(true) 
....................    { 
....................    if (ctsel==0)  
118E:  BTFSC  F81.7
1190:  BRA    11B0
....................       { 
....................       enable_interrupts(int_timer5); 
1192:  BSF    FA3.0
....................       demct=0; i=1; delay_ms(10);  
1194:  CLRF   55
1196:  MOVLW  01
1198:  MOVWF  5A
119A:  CLRF   16
119C:  BTFSC  FF2.7
119E:  BSF    16.7
11A0:  BCF    FF2.7
11A2:  MOVLW  0A
11A4:  MOVWF  x68
11A6:  RCALL  09F8
11A8:  BTFSC  16.7
11AA:  BSF    FF2.7
....................       while (ctsel==0) {} 
11AC:  BTFSS  F81.7
11AE:  BRA    11AC
....................       } 
....................        
....................    while (i==1)  
11B0:  DECFSZ 5A,W
11B2:  BRA    1226
....................       { 
....................       if ( demct<50 ) {i=0; resetvan(); } 
11B4:  MOVF   55,W
11B6:  SUBLW  31
11B8:  BNC   11BE
11BA:  CLRF   5A
11BC:  BRA    0BCE
....................       if ((50<demct)&(demct<100)) {i=0; nhiemvu2(); }  
11BE:  MOVF   55,W
11C0:  SUBLW  32
11C2:  BNC   11C8
11C4:  MOVLW  00
11C6:  BRA    11CA
11C8:  MOVLW  01
11CA:  MOVWF  5B
11CC:  MOVF   55,W
11CE:  SUBLW  63
11D0:  BC    11D6
11D2:  MOVLW  00
11D4:  BRA    11D8
11D6:  MOVLW  01
11D8:  ANDWF  5B,W
11DA:  BZ    11E0
11DC:  CLRF   5A
11DE:  BRA    0C9A
....................       if ((100<demct)&(demct<150)) {i=0; nhiemvu3x(); } 
11E0:  MOVF   55,W
11E2:  SUBLW  64
11E4:  BNC   11EA
11E6:  MOVLW  00
11E8:  BRA    11EC
11EA:  MOVLW  01
11EC:  MOVWF  5B
11EE:  MOVF   55,W
11F0:  SUBLW  95
11F2:  BC    11F8
11F4:  MOVLW  00
11F6:  BRA    11FA
11F8:  MOVLW  01
11FA:  ANDWF  5B,W
11FC:  BZ    1202
11FE:  CLRF   5A
1200:  BRA    0D14
....................       if ((150<demct)&(demct<200)) {i=0; nhiemvu4(); } 
1202:  MOVF   55,W
1204:  SUBLW  96
1206:  BNC   120C
1208:  MOVLW  00
120A:  BRA    120E
120C:  MOVLW  01
120E:  MOVWF  5B
1210:  MOVF   55,W
1212:  SUBLW  C7
1214:  BC    121A
1216:  MOVLW  00
1218:  BRA    121C
121A:  MOVLW  01
121C:  ANDWF  5B,W
121E:  BZ    1224
1220:  CLRF   5A
1222:  BRA    102E
1224:  BRA    11B0
....................       } 
1226:  BRA    118E
....................      
....................    } 
....................  
.................... } 
....................  
1228:  SLEEP 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 3E0C   PUT NOBROWNOUT BORV20 NOWDT WDT32768 NOWINEN
   Word  3: 9D3C   NOPWMPIN LPOL_HIGH HPOL_HIGH T1LOWPOWER FLTAC1 SSP_RC PWM4B5 EXCLKC3 MCLR
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
