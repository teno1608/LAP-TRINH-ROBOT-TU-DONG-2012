CCS PCH C Compiler, Version 5.015, 41519               02-Apr-14 11:14

               Filename:   F:\Robocon 2014\Lap trinh design\LAP TRINH ROBOT TU DONG\tudong2-4\tudong20mhz\lttudong20mhz.lst

               ROM used:   5594 bytes (34%)
                           Largest free fragment is 10786
               RAM used:   99 (13%) at main() level
                           128 (17%) worst case
               Stack used: 7 locations (4 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   147A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   014E
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   0A1E
0060:  BTFSS  FF0.3
0062:  GOTO   006C
0066:  BTFSC  FF0.0
0068:  GOTO   00C6
006C:  BTFSS  FF0.4
006E:  GOTO   0078
0072:  BTFSC  FF0.1
0074:  GOTO   010A
0078:  BTFSS  FA3.0
007A:  GOTO   0084
007E:  BTFSC  FA4.0
0080:  GOTO   0B10
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
.................... #include <lttudong20mhz.h> 
.................... #include <18F4431.h> 
.................... //////////// Standard Header file for the PIC18F4431 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4431 
*
01D0:  MOVLW  8E
01D2:  MOVWF  00
01D4:  MOVFF  71,01
01D8:  MOVFF  70,02
01DC:  CLRF   03
01DE:  BTFSS  x71.7
01E0:  BRA    01EC
01E2:  COMF   01,F
01E4:  COMF   02,F
01E6:  INCF   02,F
01E8:  BNZ   01EC
01EA:  INCF   01,F
01EC:  MOVF   01,F
01EE:  BNZ   0202
01F0:  MOVFF  02,01
01F4:  CLRF   02
01F6:  MOVLW  08
01F8:  SUBWF  00,F
01FA:  MOVF   01,F
01FC:  BNZ   0202
01FE:  CLRF   00
0200:  BRA    0216
0202:  BCF    FD8.0
0204:  BTFSC  01.7
0206:  BRA    0210
0208:  RLCF   02,F
020A:  RLCF   01,F
020C:  DECF   00,F
020E:  BRA    0202
0210:  BTFSC  x71.7
0212:  BRA    0216
0214:  BCF    01.7
0216:  RETURN 0
0218:  MOVF   x70,W
021A:  BTFSC  FD8.2
021C:  BRA    0300
021E:  MOVWF  00
0220:  MOVF   x74,W
0222:  BTFSC  FD8.2
0224:  BRA    0300
0226:  ADDWF  00,F
0228:  BNC   0232
022A:  MOVLW  81
022C:  ADDWF  00,F
022E:  BC    0300
0230:  BRA    023A
0232:  MOVLW  7F
0234:  SUBWF  00,F
0236:  BNC   0300
0238:  BZ    0300
023A:  MOVFF  71,78
023E:  MOVF   x75,W
0240:  XORWF  x78,F
0242:  BSF    x71.7
0244:  BSF    x75.7
0246:  MOVF   x73,W
0248:  MULWF  x77
024A:  MOVFF  FF4,7A
024E:  MOVF   x72,W
0250:  MULWF  x76
0252:  MOVFF  FF4,03
0256:  MOVFF  FF3,79
025A:  MULWF  x77
025C:  MOVF   FF3,W
025E:  ADDWF  x7A,F
0260:  MOVF   FF4,W
0262:  ADDWFC x79,F
0264:  MOVLW  00
0266:  ADDWFC 03,F
0268:  MOVF   x73,W
026A:  MULWF  x76
026C:  MOVF   FF3,W
026E:  ADDWF  x7A,F
0270:  MOVF   FF4,W
0272:  ADDWFC x79,F
0274:  MOVLW  00
0276:  CLRF   02
0278:  ADDWFC 03,F
027A:  ADDWFC 02,F
027C:  MOVF   x71,W
027E:  MULWF  x77
0280:  MOVF   FF3,W
0282:  ADDWF  x79,F
0284:  MOVF   FF4,W
0286:  ADDWFC 03,F
0288:  MOVLW  00
028A:  ADDWFC 02,F
028C:  MOVF   x71,W
028E:  MULWF  x76
0290:  MOVF   FF3,W
0292:  ADDWF  03,F
0294:  MOVF   FF4,W
0296:  ADDWFC 02,F
0298:  MOVLW  00
029A:  CLRF   01
029C:  ADDWFC 01,F
029E:  MOVF   x73,W
02A0:  MULWF  x75
02A2:  MOVF   FF3,W
02A4:  ADDWF  x79,F
02A6:  MOVF   FF4,W
02A8:  ADDWFC 03,F
02AA:  MOVLW  00
02AC:  ADDWFC 02,F
02AE:  ADDWFC 01,F
02B0:  MOVF   x72,W
02B2:  MULWF  x75
02B4:  MOVF   FF3,W
02B6:  ADDWF  03,F
02B8:  MOVF   FF4,W
02BA:  ADDWFC 02,F
02BC:  MOVLW  00
02BE:  ADDWFC 01,F
02C0:  MOVF   x71,W
02C2:  MULWF  x75
02C4:  MOVF   FF3,W
02C6:  ADDWF  02,F
02C8:  MOVF   FF4,W
02CA:  ADDWFC 01,F
02CC:  INCF   00,F
02CE:  BTFSC  01.7
02D0:  BRA    02DC
02D2:  RLCF   x79,F
02D4:  RLCF   03,F
02D6:  RLCF   02,F
02D8:  RLCF   01,F
02DA:  DECF   00,F
02DC:  MOVLW  00
02DE:  BTFSS  x79.7
02E0:  BRA    02F6
02E2:  INCF   03,F
02E4:  ADDWFC 02,F
02E6:  ADDWFC 01,F
02E8:  MOVF   01,W
02EA:  BNZ   02F6
02EC:  MOVF   02,W
02EE:  BNZ   02F6
02F0:  MOVF   03,W
02F2:  BNZ   02F6
02F4:  INCF   00,F
02F6:  BTFSC  x78.7
02F8:  BSF    01.7
02FA:  BTFSS  x78.7
02FC:  BCF    01.7
02FE:  BRA    0308
0300:  CLRF   00
0302:  CLRF   01
0304:  CLRF   02
0306:  CLRF   03
0308:  RETURN 0
030A:  MOVLW  80
030C:  BTFSC  FD8.1
030E:  XORWF  x75,F
0310:  CLRF   x7A
0312:  CLRF   x7B
0314:  MOVFF  71,79
0318:  MOVF   x75,W
031A:  XORWF  x79,F
031C:  MOVF   x70,W
031E:  BTFSC  FD8.2
0320:  BRA    04DA
0322:  MOVWF  x78
0324:  MOVWF  00
0326:  MOVF   x74,W
0328:  BTFSC  FD8.2
032A:  BRA    04EC
032C:  SUBWF  x78,F
032E:  BTFSC  FD8.2
0330:  BRA    0434
0332:  BNC   03AE
0334:  MOVFF  75,7E
0338:  BSF    x7E.7
033A:  MOVFF  76,7D
033E:  MOVFF  77,7C
0342:  CLRF   x7B
0344:  BCF    FD8.0
0346:  RRCF   x7E,F
0348:  RRCF   x7D,F
034A:  RRCF   x7C,F
034C:  RRCF   x7B,F
034E:  DECFSZ x78,F
0350:  BRA    0342
0352:  BTFSS  x79.7
0354:  BRA    035C
0356:  BSF    x7A.0
0358:  BRA    0514
035A:  BCF    x7A.0
035C:  BCF    x78.0
035E:  BSF    x7A.4
0360:  CLRF   FEA
0362:  MOVLW  73
0364:  MOVWF  FE9
0366:  BRA    053A
0368:  BCF    x7A.4
036A:  BTFSC  x79.7
036C:  BRA    0382
036E:  BTFSS  x78.0
0370:  BRA    0398
0372:  RRCF   x7E,F
0374:  RRCF   x7D,F
0376:  RRCF   x7C,F
0378:  RRCF   x7B,F
037A:  INCF   00,F
037C:  BTFSC  FD8.2
037E:  BRA    050A
0380:  BRA    0398
0382:  BTFSC  x7E.7
0384:  BRA    039E
0386:  BCF    FD8.0
0388:  RLCF   x7B,F
038A:  RLCF   x7C,F
038C:  RLCF   x7D,F
038E:  RLCF   x7E,F
0390:  DECF   00,F
0392:  BTFSC  FD8.2
0394:  BRA    050A
0396:  BRA    0382
0398:  BSF    x7A.6
039A:  BRA    0472
039C:  BCF    x7A.6
039E:  MOVFF  71,79
03A2:  BTFSS  x71.7
03A4:  BRA    03AA
03A6:  BSF    x7E.7
03A8:  BRA    04FC
03AA:  BCF    x7E.7
03AC:  BRA    04FC
03AE:  MOVFF  74,78
03B2:  MOVFF  74,00
03B6:  MOVF   x70,W
03B8:  SUBWF  x78,F
03BA:  MOVFF  71,7E
03BE:  BSF    x7E.7
03C0:  MOVFF  72,7D
03C4:  MOVFF  73,7C
03C8:  CLRF   x7B
03CA:  BCF    FD8.0
03CC:  RRCF   x7E,F
03CE:  RRCF   x7D,F
03D0:  RRCF   x7C,F
03D2:  RRCF   x7B,F
03D4:  DECFSZ x78,F
03D6:  BRA    03C8
03D8:  BTFSS  x79.7
03DA:  BRA    03E2
03DC:  BSF    x7A.1
03DE:  BRA    0514
03E0:  BCF    x7A.1
03E2:  BCF    x78.0
03E4:  BSF    x7A.5
03E6:  CLRF   FEA
03E8:  MOVLW  77
03EA:  MOVWF  FE9
03EC:  BRA    053A
03EE:  BCF    x7A.5
03F0:  BTFSC  x79.7
03F2:  BRA    0408
03F4:  BTFSS  x78.0
03F6:  BRA    041E
03F8:  RRCF   x7E,F
03FA:  RRCF   x7D,F
03FC:  RRCF   x7C,F
03FE:  RRCF   x7B,F
0400:  INCF   00,F
0402:  BTFSC  FD8.2
0404:  BRA    050A
0406:  BRA    041E
0408:  BTFSC  x7E.7
040A:  BRA    0424
040C:  BCF    FD8.0
040E:  RLCF   x7B,F
0410:  RLCF   x7C,F
0412:  RLCF   x7D,F
0414:  RLCF   x7E,F
0416:  DECF   00,F
0418:  BTFSC  FD8.2
041A:  BRA    050A
041C:  BRA    0408
041E:  BSF    x7A.7
0420:  BRA    0472
0422:  BCF    x7A.7
0424:  MOVFF  75,79
0428:  BTFSS  x75.7
042A:  BRA    0430
042C:  BSF    x7E.7
042E:  BRA    04FC
0430:  BCF    x7E.7
0432:  BRA    04FC
0434:  MOVFF  75,7E
0438:  BSF    x7E.7
043A:  MOVFF  76,7D
043E:  MOVFF  77,7C
0442:  BTFSS  x79.7
0444:  BRA    044E
0446:  BCF    x7E.7
0448:  BSF    x7A.2
044A:  BRA    0514
044C:  BCF    x7A.2
044E:  CLRF   x7B
0450:  BCF    x78.0
0452:  CLRF   FEA
0454:  MOVLW  73
0456:  MOVWF  FE9
0458:  BRA    053A
045A:  BTFSC  x79.7
045C:  BRA    0496
045E:  MOVFF  71,79
0462:  BTFSS  x78.0
0464:  BRA    0472
0466:  RRCF   x7E,F
0468:  RRCF   x7D,F
046A:  RRCF   x7C,F
046C:  RRCF   x7B,F
046E:  INCF   00,F
0470:  BZ    050A
0472:  BTFSS  x7B.7
0474:  BRA    048C
0476:  INCF   x7C,F
0478:  BNZ   048C
047A:  INCF   x7D,F
047C:  BNZ   048C
047E:  INCF   x7E,F
0480:  BNZ   048C
0482:  RRCF   x7E,F
0484:  RRCF   x7D,F
0486:  RRCF   x7C,F
0488:  INCF   00,F
048A:  BZ    050A
048C:  BTFSC  x7A.6
048E:  BRA    039C
0490:  BTFSC  x7A.7
0492:  BRA    0422
0494:  BRA    04CE
0496:  MOVLW  80
0498:  XORWF  x7E,F
049A:  BTFSS  x7E.7
049C:  BRA    04A6
049E:  BRA    0514
04A0:  MOVFF  75,79
04A4:  BRA    04BA
04A6:  MOVFF  71,79
04AA:  MOVF   x7E,F
04AC:  BNZ   04BA
04AE:  MOVF   x7D,F
04B0:  BNZ   04BA
04B2:  MOVF   x7C,F
04B4:  BNZ   04BA
04B6:  CLRF   00
04B8:  BRA    04FC
04BA:  BTFSC  x7E.7
04BC:  BRA    04CE
04BE:  BCF    FD8.0
04C0:  RLCF   x7B,F
04C2:  RLCF   x7C,F
04C4:  RLCF   x7D,F
04C6:  RLCF   x7E,F
04C8:  DECFSZ 00,F
04CA:  BRA    04BA
04CC:  BRA    050A
04CE:  BTFSS  x79.7
04D0:  BRA    04D6
04D2:  BSF    x7E.7
04D4:  BRA    04FC
04D6:  BCF    x7E.7
04D8:  BRA    04FC
04DA:  MOVFF  74,00
04DE:  MOVFF  75,7E
04E2:  MOVFF  76,7D
04E6:  MOVFF  77,7C
04EA:  BRA    04FC
04EC:  MOVFF  70,00
04F0:  MOVFF  71,7E
04F4:  MOVFF  72,7D
04F8:  MOVFF  73,7C
04FC:  MOVFF  7E,01
0500:  MOVFF  7D,02
0504:  MOVFF  7C,03
0508:  BRA    0572
050A:  CLRF   00
050C:  CLRF   01
050E:  CLRF   02
0510:  CLRF   03
0512:  BRA    0572
0514:  CLRF   x7B
0516:  COMF   x7C,F
0518:  COMF   x7D,F
051A:  COMF   x7E,F
051C:  COMF   x7B,F
051E:  INCF   x7B,F
0520:  BNZ   052C
0522:  INCF   x7C,F
0524:  BNZ   052C
0526:  INCF   x7D,F
0528:  BNZ   052C
052A:  INCF   x7E,F
052C:  BTFSC  x7A.0
052E:  BRA    035A
0530:  BTFSC  x7A.1
0532:  BRA    03E0
0534:  BTFSC  x7A.2
0536:  BRA    044C
0538:  BRA    04A0
053A:  MOVF   FEF,W
053C:  ADDWF  x7C,F
053E:  BNC   054A
0540:  INCF   x7D,F
0542:  BNZ   054A
0544:  INCF   x7E,F
0546:  BTFSC  FD8.2
0548:  BSF    x78.0
054A:  MOVF   FED,F
054C:  MOVF   FEF,W
054E:  ADDWF  x7D,F
0550:  BNC   0558
0552:  INCF   x7E,F
0554:  BTFSC  FD8.2
0556:  BSF    x78.0
0558:  MOVF   FED,F
055A:  MOVF   FEF,W
055C:  BTFSC  FEF.7
055E:  BRA    0562
0560:  XORLW  80
0562:  ADDWF  x7E,F
0564:  BTFSC  FD8.0
0566:  BSF    x78.0
0568:  BTFSC  x7A.4
056A:  BRA    0368
056C:  BTFSC  x7A.5
056E:  BRA    03EE
0570:  BRA    045A
0572:  RETURN 0
0574:  MOVLW  8E
0576:  MOVWF  00
0578:  MOVF   x6C,W
057A:  SUBWF  00,F
057C:  MOVFF  6D,02
0580:  MOVFF  6E,01
0584:  BSF    02.7
0586:  MOVF   00,F
0588:  BZ    059C
058A:  BCF    FD8.0
058C:  MOVF   02,F
058E:  BNZ   0594
0590:  MOVF   01,F
0592:  BZ    059C
0594:  RRCF   02,F
0596:  RRCF   01,F
0598:  DECFSZ 00,F
059A:  BRA    058A
059C:  BTFSS  x6D.7
059E:  BRA    05AA
05A0:  COMF   01,F
05A2:  COMF   02,F
05A4:  INCF   01,F
05A6:  BTFSC  FD8.2
05A8:  INCF   02,F
05AA:  RETURN 0
*
0AA4:  ADDWF  FE8,W
0AA6:  CLRF   FF7
0AA8:  RLCF   FF7,F
0AAA:  ADDLW  BF
0AAC:  MOVWF  FF6
0AAE:  MOVLW  0A
0AB0:  ADDWFC FF7,F
0AB2:  TBLRD*-
0AB4:  MOVF   FF5,W
0AB6:  MOVWF  FFA
0AB8:  TBLRD*
0ABA:  MOVF   FF5,W
0ABC:  MOVWF  FF9
0ABE:  DATA 36,0A
0AC0:  DATA 42,0A
0AC2:  DATA 5A,0A
0AC4:  DATA 72,0A
....................  
.................... #list 
....................  
.................... #include <PIC18F4431_registers.h> 
.................... #byte TOSU = 0xFFF 
.................... #word TOS = 0xFFE 
.................... #byte STKPTR = 0xFFC 
.................... #bit    STKOVF = STKPTR.7 
.................... #byte STKPTR = 0xFFC 
.................... #bit    STKPTR0 = STKPTR.0 
.................... #bit    STKPTR1 = STKPTR.1 
.................... #bit    STKPTR2 = STKPTR.2 
.................... #bit    STKPTR3 = STKPTR.3 
.................... #bit    STKPTR4 = STKPTR.4 
.................... #bit    STKUNF = STKPTR.6 
.................... #bit    STKFUL = STKPTR.7 
.................... #byte PCLATU = 0xFFB 
.................... #byte PCLATH = 0xFFA 
.................... #byte PCL = 0xFF9 
.................... #byte TBLPTRU = 0xFF8 
.................... #bit    TBLPTRU0 = TBLPTRU.0 
.................... #bit    TBLPTRU1 = TBLPTRU.1 
.................... #bit    TBLPTRU2 = TBLPTRU.2 
.................... #bit    TBLPTRU3 = TBLPTRU.3 
.................... #bit    TBLPTRU4 = TBLPTRU.4 
.................... #bit    ACSS = TBLPTRU.5 
.................... #word TBLPTR = 0xFF7 
.................... #byte TABLAT = 0xFF5 
.................... #word PROD = 0xFF4 
.................... #byte INTCON = 0xFF2 
.................... #bit    RBIF = INTCON.0 
.................... #bit    INT0IF = INTCON.1 
.................... #bit    TMR0IF = INTCON.2 
.................... #bit    RBIE = INTCON.3 
.................... #bit    INT0IE = INTCON.4 
.................... #bit    TMR0IE = INTCON.5 
.................... #bit    PEIE_GIEL = INTCON.6 
.................... #bit    GIE_GIEH = INTCON.7 
.................... #byte INTCON = 0xFF2 
.................... #bit    PEIE = INTCON.6 
.................... #bit    GIE = INTCON.7 
.................... #byte INTCON = 0xFF2 
.................... #bit    INT0F = INTCON.1 
.................... #bit    T0IF = INTCON.2 
.................... #bit    INT0E = INTCON.4 
.................... #bit    T0IE = INTCON.5 
.................... #bit    GIEL = INTCON.6 
.................... #bit    GIEH = INTCON.7 
.................... #byte INTCON2 = 0xFF1 
.................... #bit    T0IP = INTCON2.2 
.................... #byte INTCON2 = 0xFF1 
.................... #bit    RBIP = INTCON2.0 
.................... #bit    TMR0IP = INTCON2.2 
.................... #bit    INTEDG2 = INTCON2.4 
.................... #bit    INTEDG1 = INTCON2.5 
.................... #bit    INTEDG0 = INTCON2.6 
.................... #bit    RBPU = INTCON2.7 
.................... #byte INTCON3 = 0xFF0 
.................... #bit    INT1F = INTCON3.0 
.................... #bit    INT2F = INTCON3.1 
.................... #bit    INT1E = INTCON3.3 
.................... #bit    INT2E = INTCON3.4 
.................... #bit    INT1P = INTCON3.6 
.................... #bit    INT2P = INTCON3.7 
.................... #byte INTCON3 = 0xFF0 
.................... #bit    INT1IF = INTCON3.0 
.................... #bit    INT2IF = INTCON3.1 
.................... #bit    INT1IE = INTCON3.3 
.................... #bit    INT2IE = INTCON3.4 
.................... #bit    INT1IP = INTCON3.6 
.................... #bit    INT2IP = INTCON3.7 
.................... #byte INDF0 = 0xFEF 
.................... #byte POSTINC0 = 0xFEE 
.................... #byte POSTDEC0 = 0xFED 
.................... #byte PREINC0 = 0xFEC 
.................... #byte PLUSW0 = 0xFEB 
.................... #word FSR0 = 0xFEA 
.................... #byte WREG = 0xFE8 
.................... #byte INDF1 = 0xFE7 
.................... #byte POSTINC1 = 0xFE6 
.................... #byte POSTDEC1 = 0xFE5 
.................... #byte PREINC1 = 0xFE4 
.................... #byte PLUSW1 = 0xFE3 
.................... #word FSR1 = 0xFE2 
.................... #byte BSR = 0xFE0 
.................... #byte INDF2 = 0xFDF 
.................... #byte POSTINC2 = 0xFDE 
.................... #byte POSTDEC2 = 0xFDD 
.................... #byte PREINC2 = 0xFDC 
.................... #byte PLUSW2 = 0xFDB 
.................... #word FSR2 = 0xFDA 
.................... #byte STATUS = 0xFD8 
.................... #bit    C = STATUS.0 
.................... #bit    DC = STATUS.1 
.................... #bit    Z = STATUS.2 
.................... #bit    OV = STATUS.3 
.................... #bit    N = STATUS.4 
.................... #word TMR0 = 0xFD7 
.................... #byte T0CON = 0xFD5 
.................... #bit    T0PS0 = T0CON.0 
.................... #bit    T0PS1 = T0CON.1 
.................... #bit    T0PS2 = T0CON.2 
.................... #bit    PSA = T0CON.3 
.................... #bit    T0SE = T0CON.4 
.................... #bit    T0CS = T0CON.5 
.................... #bit    T016BIT = T0CON.6 
.................... #bit    TMR0ON = T0CON.7 
.................... #byte OSCCON = 0xFD3 
.................... #bit    FLTS = OSCCON.2 
.................... #byte OSCCON = 0xFD3 
.................... #bit    SCS0 = OSCCON.0 
.................... #bit    SCS1 = OSCCON.1 
.................... #bit    IOFS = OSCCON.2 
.................... #bit    OSTS = OSCCON.3 
.................... #bit    IRCF0 = OSCCON.4 
.................... #bit    IRCF1 = OSCCON.5 
.................... #bit    IRCF2 = OSCCON.6 
.................... #bit    IDLEN = OSCCON.7 
.................... #byte LVDCON = 0xFD2 
.................... #bit    IVRST = LVDCON.5 
.................... #byte LVDCON = 0xFD2 
.................... #bit    LVDL0 = LVDCON.0 
.................... #bit    LVDL1 = LVDCON.1 
.................... #bit    LVDL2 = LVDCON.2 
.................... #bit    LVDL3 = LVDCON.3 
.................... #bit    LVDEN = LVDCON.4 
.................... #bit    IRVST = LVDCON.5 
.................... #byte WDTCON = 0xFD1 
.................... #bit    SWDTEN = WDTCON.0 
.................... #bit    WDTW = WDTCON.7 
.................... #byte RCON = 0xFD0 
.................... #bit    BOR = RCON.0 
.................... #bit    POR = RCON.1 
.................... #bit    PD = RCON.2 
.................... #bit    TO = RCON.3 
.................... #bit    RI = RCON.4 
.................... #bit    IPEN = RCON.7 
.................... #word TMR1 = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... #bit    T1INSYNC = T1CON.2 
.................... #byte T1CON = 0xFCD 
.................... #bit    TMR1ON = T1CON.0 
.................... #bit    TMR1CS = T1CON.1 
.................... #bit    T1SYNC = T1CON.2 
.................... #bit    T1OSCEN = T1CON.3 
.................... #bit    T1CKPS0 = T1CON.4 
.................... #bit    T1CKPS1 = T1CON.5 
.................... #bit    T1RUN = T1CON.6 
.................... #bit    RD16 = T1CON.7 
.................... #byte TMR2 = 0xFCC 
.................... #byte PR2 = 0xFCB 
.................... #byte T2CON = 0xFCA 
.................... #bit    T2OUTPS0 = T2CON.3 
.................... #bit    T2OUTPS1 = T2CON.4 
.................... #bit    T2OUTPS2 = T2CON.5 
.................... #bit    T2OUTPS3 = T2CON.6 
.................... #byte T2CON = 0xFCA 
.................... #bit    T2CKPS0 = T2CON.0 
.................... #bit    T2CKPS1 = T2CON.1 
.................... #bit    TMR2ON = T2CON.2 
.................... #bit    TOUTPS0 = T2CON.3 
.................... #bit    TOUTPS1 = T2CON.4 
.................... #bit    TOUTPS2 = T2CON.5 
.................... #bit    TOUTPS3 = T2CON.6 
.................... #byte SSPBUF = 0xFC9 
.................... #byte SSPADD = 0xFC8 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    READ_WRITE = SSPSTAT.2 
.................... #bit    DATA_ADDRESS = SSPSTAT.5 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    WRITE = SSPSTAT.2 
.................... #bit    ADDRESS = SSPSTAT.5 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    BF = SSPSTAT.0 
.................... #bit    UA = SSPSTAT.1 
.................... #bit    R = SSPSTAT.2 
.................... #bit    S = SSPSTAT.3 
.................... #bit    P = SSPSTAT.4 
.................... #bit    D = SSPSTAT.5 
.................... #bit    CKE = SSPSTAT.6 
.................... #bit    SMP = SSPSTAT.7 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    R_W = SSPSTAT.2 
.................... #bit    D_A = SSPSTAT.5 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    W = SSPSTAT.2 
.................... #bit    A = SSPSTAT.5 
.................... #byte SSPCON = 0xFC6 
.................... #bit    SSPM0 = SSPCON.0 
.................... #bit    SSPM1 = SSPCON.1 
.................... #bit    SSPM2 = SSPCON.2 
.................... #bit    SSPM3 = SSPCON.3 
.................... #bit    CKP = SSPCON.4 
.................... #bit    SSPEN = SSPCON.5 
.................... #bit    SSPOV = SSPCON.6 
.................... #bit    WCOL = SSPCON.7 
.................... #word ADRES = 0xFC4 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    GO_DONE = ADCON0.1 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    ADON = ADCON0.0 
.................... #bit    GO = ADCON0.1 
.................... #bit    ACMOD0 = ADCON0.2 
.................... #bit    ACMOD1 = ADCON0.3 
.................... #bit    ACSCH = ADCON0.4 
.................... #bit    ACONV = ADCON0.5 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    GODONE = ADCON0.1 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    DONE = ADCON0.1 
.................... #byte ADCON1 = 0xFC1 
.................... #bit    FFOVFL = ADCON1.2 
.................... #byte ADCON1 = 0xFC1 
.................... #bit    ADPNT0 = ADCON1.0 
.................... #bit    ADPNT1 = ADCON1.1 
.................... #bit    BFOVFL = ADCON1.2 
.................... #bit    BFEMT = ADCON1.3 
.................... #bit    FIFOEN = ADCON1.4 
.................... #bit    VCFG0 = ADCON1.6 
.................... #bit    VCFG1 = ADCON1.7 
.................... #byte ADCON2 = 0xFC0 
.................... #bit    ADCS0 = ADCON2.0 
.................... #bit    ADCS1 = ADCON2.1 
.................... #bit    ADCS2 = ADCON2.2 
.................... #bit    ACQT0 = ADCON2.3 
.................... #bit    ACQT1 = ADCON2.4 
.................... #bit    ACQT2 = ADCON2.5 
.................... #bit    ACQT3 = ADCON2.6 
.................... #bit    ADFM = ADCON2.7 
.................... #word CCPR1 = 0xFBF 
.................... #byte CCP1CON = 0xFBD 
.................... #bit    CCP1Y = CCP1CON.4 
.................... #bit    CCP1X = CCP1CON.5 
.................... #byte CCP1CON = 0xFBD 
.................... #bit    CCP1M0 = CCP1CON.0 
.................... #bit    CCP1M1 = CCP1CON.1 
.................... #bit    CCP1M2 = CCP1CON.2 
.................... #bit    CCP1M3 = CCP1CON.3 
.................... #bit    DC1B0 = CCP1CON.4 
.................... #bit    DC1B1 = CCP1CON.5 
.................... #word CCPR2 = 0xFBC 
.................... #byte CCP2CON = 0xFBA 
.................... #bit    CCP2Y = CCP2CON.4 
.................... #bit    CCP2X = CCP2CON.5 
.................... #byte CCP2CON = 0xFBA 
.................... #bit    CCP2M0 = CCP2CON.0 
.................... #bit    CCP2M1 = CCP2CON.1 
.................... #bit    CCP2M2 = CCP2CON.2 
.................... #bit    CCP2M3 = CCP2CON.3 
.................... #bit    DC2B0 = CCP2CON.4 
.................... #bit    DC2B1 = CCP2CON.5 
.................... #byte ANSEL1 = 0xFB9 
.................... #bit    ANS8 = ANSEL1.0 
.................... #byte ANSEL0 = 0xFB8 
.................... #byte T5CON = 0xFB7 
.................... #bit    TMR5ON = T5CON.0 
.................... #bit    TMR5CS = T5CON.1 
.................... #bit    T5SYNC = T5CON.2 
.................... #bit    T5PS0 = T5CON.3 
.................... #bit    T5PS1 = T5CON.4 
.................... #bit    T5MOD = T5CON.5 
.................... #bit    RESEN = T5CON.6 
.................... #bit    T5SEN = T5CON.7 
.................... #byte QEICON = 0xFB6 
.................... #bit    UP_DOWN = QEICON.5 
.................... #byte QEICON = 0xFB6 
.................... #bit    PDEC0 = QEICON.0 
.................... #bit    PDEC1 = QEICON.1 
.................... #bit    QEIM0 = QEICON.2 
.................... #bit    QEIM1 = QEICON.3 
.................... #bit    QEIM2 = QEICON.4 
.................... #bit    UP = QEICON.5 
.................... #bit    QERR = QEICON.6 
.................... #bit    VELM = QEICON.7 
.................... #byte QEICON = 0xFB6 
.................... #bit    UPDOWN = QEICON.5 
.................... #byte QEICON = 0xFB6 
.................... #bit    DOWN = QEICON.5 
.................... #byte SPBRGH = 0xFB0 
.................... #byte SPBRG = 0xFAF 
.................... #byte RCREG = 0xFAE 
.................... #byte TXREG = 0xFAD 
.................... #byte TXSTA = 0xFAC 
.................... #bit    TX9D = TXSTA.0 
.................... #bit    TRMT = TXSTA.1 
.................... #bit    BRGH = TXSTA.2 
.................... #bit    SENDB = TXSTA.3 
.................... #bit    SYNC = TXSTA.4 
.................... #bit    TXEN = TXSTA.5 
.................... #bit    TX9 = TXSTA.6 
.................... #bit    CSRC = TXSTA.7 
.................... #byte RCSTA = 0xFAB 
.................... #bit    ADEN = RCSTA.3 
.................... #byte RCSTA = 0xFAB 
.................... #bit    RX9D = RCSTA.0 
.................... #bit    OERR = RCSTA.1 
.................... #bit    FERR = RCSTA.2 
.................... #bit    ADDEN = RCSTA.3 
.................... #bit    CREN = RCSTA.4 
.................... #bit    SREN = RCSTA.5 
.................... #bit    RX9 = RCSTA.6 
.................... #bit    SPEN = RCSTA.7 
.................... #byte BAUDCON = 0xFAA 
.................... #bit    SCKP = BAUDCON.4 
.................... #bit    RCMT = BAUDCON.6 
.................... #byte BAUDCON = 0xFAA 
.................... #bit    ABDEN = BAUDCON.0 
.................... #bit    WUE = BAUDCON.1 
.................... #bit    BRG16 = BAUDCON.3 
.................... #bit    TXCKP = BAUDCON.4 
.................... #bit    RXDTP = BAUDCON.5 
.................... #bit    RCIDL = BAUDCON.6 
.................... #bit    ABDOVF = BAUDCON.7 
.................... #byte EEADR = 0xFA9 
.................... #byte EEDATA = 0xFA8 
.................... #byte EECON2 = 0xFA7 
.................... #byte EECON1 = 0xFA6 
.................... #bit    RD = EECON1.0 
.................... #bit    WR = EECON1.1 
.................... #bit    WREN = EECON1.2 
.................... #bit    WRERR = EECON1.3 
.................... #bit    FREE = EECON1.4 
.................... #bit    CFGS = EECON1.6 
.................... #bit    EEPGD = EECON1.7 
.................... #byte IPR3 = 0xFA5 
.................... #bit    TMR5IP = IPR3.0 
.................... #bit    IC1IP = IPR3.1 
.................... #bit    IC2QEIP = IPR3.2 
.................... #bit    IC3DRIP = IPR3.3 
.................... #bit    PTIP = IPR3.4 
.................... #byte PIR3 = 0xFA4 
.................... #bit    TMR5IF = PIR3.0 
.................... #bit    IC1IF = PIR3.1 
.................... #bit    IC2QEIF = PIR3.2 
.................... #bit    IC3DRIF = PIR3.3 
.................... #bit    PTIF = PIR3.4 
.................... #byte PIE3 = 0xFA3 
.................... #bit    TMR5IE = PIE3.0 
.................... #bit    IC1IE = PIE3.1 
.................... #bit    IC2QEIE = PIE3.2 
.................... #bit    IC3DRIE = PIE3.3 
.................... #bit    PTIE = PIE3.4 
.................... #byte IPR2 = 0xFA2 
.................... #bit    CCP2IP = IPR2.0 
.................... #bit    LVDIP = IPR2.2 
.................... #bit    EEIP = IPR2.4 
.................... #bit    OSFIP = IPR2.7 
.................... #byte PIR2 = 0xFA1 
.................... #bit    CCP2IF = PIR2.0 
.................... #bit    LVDIF = PIR2.2 
.................... #bit    EEIF = PIR2.4 
.................... #bit    OSFIF = PIR2.7 
.................... #byte PIE2 = 0xFA0 
.................... #bit    CCP2IE = PIE2.0 
.................... #bit    LVDIE = PIE2.2 
.................... #bit    EEIE = PIE2.4 
.................... #bit    OSFIE = PIE2.7 
.................... #byte IPR1 = 0xF9F 
.................... #bit    TBIP = IPR1.4 
.................... #byte IPR1 = 0xF9F 
.................... #bit    TMR1IP = IPR1.0 
.................... #bit    TMR2IP = IPR1.1 
.................... #bit    CCP1IP = IPR1.2 
.................... #bit    SSPIP = IPR1.3 
.................... #bit    TXIP = IPR1.4 
.................... #bit    RCIP = IPR1.5 
.................... #bit    ADIP = IPR1.6 
.................... #byte PIR1 = 0xF9E 
.................... #bit    TBIF = PIR1.4 
.................... #byte PIR1 = 0xF9E 
.................... #bit    TMR1IF = PIR1.0 
.................... #bit    TMR2IF = PIR1.1 
.................... #bit    CCP1IF = PIR1.2 
.................... #bit    SSPIF = PIR1.3 
.................... #bit    TXIF = PIR1.4 
.................... #bit    RCIF = PIR1.5 
.................... #bit    ADIF = PIR1.6 
.................... #byte PIE1 = 0xF9D 
.................... #bit    TBIE = PIE1.4 
.................... #byte PIE1 = 0xF9D 
.................... #bit    TMR1IE = PIE1.0 
.................... #bit    TMR2IE = PIE1.1 
.................... #bit    CCP1IE = PIE1.2 
.................... #bit    SSPIE = PIE1.3 
.................... #bit    TXIE = PIE1.4 
.................... #bit    RCIE = PIE1.5 
.................... #bit    ADIE = PIE1.6 
.................... #byte OSCTUNE = 0xF9B 
.................... #byte ADCON3 = 0xF9A 
.................... #bit    SSRC0 = ADCON3.0 
.................... #bit    SSRC1 = ADCON3.1 
.................... #bit    SSRC2 = ADCON3.2 
.................... #bit    SSRC3 = ADCON3.3 
.................... #bit    SSRC4 = ADCON3.4 
.................... #bit    ADRS0 = ADCON3.6 
.................... #bit    ADRS1 = ADCON3.7 
.................... #byte ADCHS = 0xF99 
.................... #bit    GASEL0 = ADCHS.0 
.................... #bit    GASEL1 = ADCHS.1 
.................... #bit    GCSEL0 = ADCHS.2 
.................... #bit    GCSEL1 = ADCHS.3 
.................... #bit    GBSEL0 = ADCHS.4 
.................... #bit    GBSEL1 = ADCHS.5 
.................... #bit    GDSEL0 = ADCHS.6 
.................... #bit    GDSEL1 = ADCHS.7 
.................... #byte ADCHS = 0xF99 
.................... #bit    SASEL0 = ADCHS.0 
.................... #bit    SASEL1 = ADCHS.1 
.................... #bit    SCSEL0 = ADCHS.2 
.................... #bit    SCSEL1 = ADCHS.3 
.................... #bit    SBSEL0 = ADCHS.4 
.................... #bit    SBSEL1 = ADCHS.5 
.................... #bit    SDSEL0 = ADCHS.6 
.................... #bit    SDSEL1 = ADCHS.7 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
.................... #byte TRISA = 0xF92 
.................... #word PR5 = 0xF91 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
.................... #byte LATA = 0xF89 
.................... #word TMR5 = 0xF88 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #byte PTCON0 = 0xF7F 
.................... #bit    PTMOD0 = PTCON0.0 
.................... #bit    PTMOD1 = PTCON0.1 
.................... #bit    PTCKPS0 = PTCON0.2 
.................... #bit    PTCKPS1 = PTCON0.3 
.................... #bit    PTOPS0 = PTCON0.4 
.................... #bit    PTOPS1 = PTCON0.5 
.................... #bit    PTOPS2 = PTCON0.6 
.................... #bit    PTOPS3 = PTCON0.7 
.................... #byte PTCON1 = 0xF7E 
.................... #bit    PTDIR = PTCON1.6 
.................... #bit    PTEN = PTCON1.7 
.................... #byte PTMRL = 0xF7D 
.................... #byte PTMRH = 0xF7C 
.................... #byte PTPERL = 0xF7B 
.................... #byte PTPERH = 0xF7A 
.................... #byte PDC0L = 0xF79 
.................... #byte PDC0H = 0xF78 
.................... #byte PDC1L = 0xF77 
.................... #byte PDC1H = 0xF76 
.................... #byte PDC2L = 0xF75 
.................... #byte PDC2H = 0xF74 
.................... #byte PDC3L = 0xF73 
.................... #byte PDC3H = 0xF72 
.................... #byte SEVTCMPL = 0xF71 
.................... #byte SEVTCMPH = 0xF70 
.................... #byte PWMCON0 = 0xF6F 
.................... #bit    PMOD0 = PWMCON0.0 
.................... #bit    PMOD1 = PWMCON0.1 
.................... #bit    PMOD2 = PWMCON0.2 
.................... #bit    PMOD3 = PWMCON0.3 
.................... #bit    PWMEN0 = PWMCON0.4 
.................... #bit    PWMEN1 = PWMCON0.5 
.................... #bit    PWMEN2 = PWMCON0.6 
.................... #byte PWMCON1 = 0xF6E 
.................... #bit    OSYNC = PWMCON1.0 
.................... #bit    UDIS = PWMCON1.1 
.................... #bit    SEVTDIR = PWMCON1.3 
.................... #bit    SEVOPS0 = PWMCON1.4 
.................... #bit    SEVOPS1 = PWMCON1.5 
.................... #bit    SEVOPS2 = PWMCON1.6 
.................... #bit    SEVOPS3 = PWMCON1.7 
.................... #byte DTCON = 0xF6D 
.................... #bit    DT0 = DTCON.0 
.................... #bit    DT1 = DTCON.1 
.................... #bit    DT2 = DTCON.2 
.................... #bit    DT3 = DTCON.3 
.................... #bit    DT4 = DTCON.4 
.................... #bit    DT5 = DTCON.5 
.................... #bit    DTPS0 = DTCON.6 
.................... #bit    DTPS1 = DTCON.7 
.................... #byte DTCON = 0xF6D 
.................... #bit    DTA0 = DTCON.0 
.................... #bit    DTA1 = DTCON.1 
.................... #bit    DTA2 = DTCON.2 
.................... #bit    DTA3 = DTCON.3 
.................... #bit    DTA4 = DTCON.4 
.................... #bit    DTA5 = DTCON.5 
.................... #bit    DTAPS0 = DTCON.6 
.................... #bit    DTAPS1 = DTCON.7 
.................... #byte FLTCONFIG = 0xF6C 
.................... #bit    FLTAEN = FLTCONFIG.0 
.................... #bit    FLTAMOD = FLTCONFIG.1 
.................... #bit    FLTAS = FLTCONFIG.2 
.................... #bit    FLTCON = FLTCONFIG.3 
.................... #bit    FLTBEN = FLTCONFIG.4 
.................... #bit    FLTBMOD = FLTCONFIG.5 
.................... #bit    FLTBS = FLTCONFIG.6 
.................... #bit    BRFEN = FLTCONFIG.7 
.................... #byte OVDCOND = 0xF6B 
.................... #byte OVDCONS = 0xF6A 
.................... #word CAP1BUF = 0xF69 
.................... #word CAP2BUF = 0xF67 
.................... #word CAP3BUF = 0xF65 
.................... #byte CAP1CON = 0xF63 
.................... #bit    CAP1M0 = CAP1CON.0 
.................... #bit    CAP1M1 = CAP1CON.1 
.................... #bit    CAP1M2 = CAP1CON.2 
.................... #bit    CAP1M3 = CAP1CON.3 
.................... #bit    CAP1TMR = CAP1CON.5 
.................... #bit    CAP1REN = CAP1CON.6 
.................... #byte CAP2CON = 0xF62 
.................... #bit    CAP2M0 = CAP2CON.0 
.................... #bit    CAP2M1 = CAP2CON.1 
.................... #bit    CAP2M2 = CAP2CON.2 
.................... #bit    CAP2M3 = CAP2CON.3 
.................... #bit    CAP2TMR = CAP2CON.5 
.................... #bit    CAP2REN = CAP2CON.6 
.................... #byte CAP3CON = 0xF61 
.................... #bit    CAP3M0 = CAP3CON.0 
.................... #bit    CAP3M1 = CAP3CON.1 
.................... #bit    CAP3M2 = CAP3CON.2 
.................... #bit    CAP3M3 = CAP3CON.3 
.................... #bit    CAP3TMR = CAP3CON.5 
.................... #bit    CAP3REN = CAP3CON.6 
.................... #byte DFLTCON = 0xF60 
.................... #bit    FLTCK0 = DFLTCON.0 
.................... #bit    FLTCK1 = DFLTCON.1 
.................... #bit    FLTCK2 = DFLTCON.2 
.................... #bit    FLT1EN = DFLTCON.3 
.................... #bit    FLT2EN = DFLTCON.4 
.................... #bit    FLT3EN = DFLTCON.5 
.................... #bit    FLT4EN = DFLTCON.6 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... //#device ADC=16 
.................... #FUSES HS    
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... //#FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... //#FUSES SSP_RD 
....................  
.................... #use delay(crystal=20000000) 
0AC6:  CLRF   FEA
0AC8:  MOVLW  6C
0ACA:  MOVWF  FE9
0ACC:  MOVF   FEF,W
0ACE:  BZ    0AEA
0AD0:  MOVLW  06
0AD2:  MOVWF  01
0AD4:  CLRF   00
0AD6:  DECFSZ 00,F
0AD8:  BRA    0AD6
0ADA:  DECFSZ 01,F
0ADC:  BRA    0AD4
0ADE:  MOVLW  7B
0AE0:  MOVWF  00
0AE2:  DECFSZ 00,F
0AE4:  BRA    0AE2
0AE6:  DECFSZ FEF,F
0AE8:  BRA    0AD0
0AEA:  RETURN 0
.................... #use fast_io(a) 
.................... #use fast_io(d) 
.................... #use fast_io(c) 
.................... #use fast_io(e) 
....................  
.................... //#bit ss1 = PORTD.0 
....................  
.................... #include <khoidong.c> 
.................... ///// KHOI DONG PIC 
.................... /* 
.................... #include <18F4431.h> 
.................... #include <PIC18F4431_registers.h> 
.................... //#device ADC=16 
.................... #include <stdlib.h> 
.................... #include <stdio.h> 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... //#FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... //#FUSES H4 
.................... #use delay(clock=40000000,crystal=10000000) 
.................... //#use spi(MASTER ,FORCE_HW, BITS=16) 
.................... //#bit ss1 = PORTD.0 
.................... #use fast_io(a) 
.................... #use fast_io(d) 
.................... #use fast_io(c) 
.................... #use fast_io(e) 
.................... */ 
.................... void khoidong() 
.................... { 
....................    trisa=0b00011000; /// DAU VAO QEI CUNG 
*
0B6A:  MOVLW  18
0B6C:  MOVWF  F92
....................    porta=0b11100111; 
0B6E:  MOVLW  E7
0B70:  MOVWF  F80
....................    trisb=0b11111111; /// DAU VAO CONG TAC HANH TRINH 
0B72:  SETF   F93
....................    port_b_pullups(0xff); 
0B74:  BCF    FF1.7
....................    portb=0xff; 
0B76:  SETF   F81
....................    trisc=0b00110000; /// DAU VAO QEI MEM 
0B78:  MOVLW  30
0B7A:  MOVWF  F94
....................    portc=0b00000000; 
0B7C:  CLRF   F82
....................    trisd=0b00000100; /// DAU VAO SPI 0b00000100 
0B7E:  MOVLW  04
0B80:  MOVWF  F95
....................    portd=0b11110100; 
0B82:  MOVLW  F4
0B84:  MOVWF  F83
....................    trise=0b00000000; 
0B86:  CLRF   F96
....................    porte=0b11111111; 
0B88:  SETF   F84
....................     
....................    enable_interrupts(INT_EXT1); 
0B8A:  BSF    FF0.3
....................    enable_interrupts(INT_EXT2); 
0B8C:  BSF    FF0.4
....................     
....................    //enable_interrupts(int_timer0); 
....................    //enable_interrupts(int_timer1); 
....................    //enable_interrupts(int_timer5); 
....................     
....................    enable_interrupts(GLOBAL); 
0B8E:  MOVLW  C0
0B90:  IORWF  FF2,F
....................    ext_int_edge(1,L_to_H); 
0B92:  BSF    FF1.5
....................    ext_int_edge(2,L_to_H); 
0B94:  BSF    FF1.4
....................     
....................    clear_interrupt(INT_EXT1); 
0B96:  BCF    FF0.0
....................    clear_interrupt(INT_EXT2); 
0B98:  BCF    FF0.1
....................    clear_interrupt(int_timer0); 
0B9A:  BCF    FF2.2
....................    clear_interrupt(int_timer1); 
0B9C:  BCF    F9E.0
....................    clear_interrupt(int_timer5); 
0B9E:  BCF    FA4.0
....................     
....................    setup_qei(QEI_MODE_X4_RESET_WITH_INDX,qei_filter_enable_qea|qei_filter_enable_qeb|qei_filter_div_2,65535); 
0BA0:  MOVLW  14
0BA2:  MOVWF  FB6
0BA4:  MOVLW  31
0BA6:  MOVWF  F60
0BA8:  SETF   F65
0BAA:  SETF   F64
0BAC:  CLRF   F67
0BAE:  CLRF   F66
....................    qei_set_count(0); 
0BB0:  CLRF   F67
0BB2:  CLRF   F66
....................     
....................    //setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1);      //6.5 ms overflow, 0.1us 
....................    //set_timer0(64535); 
....................     
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_2|RTCC_8_bit);      //102 us overflow, 0.4us 
0BB4:  MOVLW  C0
0BB6:  MOVWF  FD5
....................    set_timer0(5); 
0BB8:  CLRF   FD7
0BBA:  MOVLW  05
0BBC:  MOVWF  FD6
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_4);      //52.4 ms overflow, 0.8us 
0BBE:  MOVLW  A5
0BC0:  MOVWF  FCD
....................    set_timer1(50286); 
0BC2:  MOVLW  C4
0BC4:  MOVWF  FCF
0BC6:  MOVLW  6E
0BC8:  MOVWF  FCE
....................    setup_timer_5(T5_INTERNAL|T5_DIV_BY_4);      //52.4 ms overflow, 0.8us 
0BCA:  MOVLW  11
0BCC:  MOVWF  FB7
....................    set_timer5(53035); 
0BCE:  MOVLW  CF
0BD0:  MOVWF  F88
0BD2:  MOVLW  2B
0BD4:  MOVWF  F87
0BD6:  GOTO   1502 (RETURN)
....................     
....................    //setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_CLK_DIV_16); 
....................    //ss1=1; 
....................  
....................       
.................... } 
....................  
....................  
....................  
.................... #include <van-ctht.c> 
....................  
.................... ///// DEFINE CHON CT 
.................... #bit chon_nv=portd.2 
....................  
.................... ///// DEFINE VAN 
....................  
.................... #bit vantay1=porta.5 
.................... #bit vantay2=porte.0 
.................... #bit vancanh2=porta.0     
.................... #bit vancanh1=porta.1     
.................... #bit vanduoi=porta.2 
....................  
.................... ///// DEFINE CONG TAC HANH TRINH 
.................... #bit ctt2=portb.0 
.................... #bit ctc2=portb.1 
.................... #bit ctt1=portb.2 
.................... #bit ctc1=portb.3 
....................  
.................... #bit ctld=portb.4 
.................... #bit ctlt=portb.5 
....................  
.................... #bit ctsel=portb.7 
.................... #bit cten=portb.6 
....................  
.................... ///// CHUONG TRINH LOA TIN HIEU 
.................... #bit trisloa = trisd.7 
.................... #bit loa = portd.7 
.................... void beep(int8 solan,int8 time) 
.................... { 
.................... int8 i; 
.................... for (i=0; i<solan; i++) 
*
0AEC:  CLRF   x6A
0AEE:  MOVF   x68,W
0AF0:  SUBWF  x6A,W
0AF2:  BC    0B0E
....................    { 
....................    trisloa = 0; 
0AF4:  BCF    F95.7
....................    loa = 0; 
0AF6:  BCF    F83.7
....................    delay_ms(20); 
0AF8:  MOVLW  14
0AFA:  MOVWF  x6C
0AFC:  RCALL  0AC6
....................    loa = 1; 
0AFE:  BSF    F83.7
....................    delay_ms(time-20); 
0B00:  MOVLW  14
0B02:  SUBWF  x69,W
0B04:  MOVWF  x6B
0B06:  MOVWF  x6C
0B08:  RCALL  0AC6
0B0A:  INCF   x6A,F
0B0C:  BRA    0AEE
....................    } 
0B0E:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include <dongco.c> 
....................  
.................... ///// DEFINE CAC DONG CO 
....................  
.................... #bit br1=porte.2 
.................... #bit br2=porte.1 
.................... #bit trisbr1 = trise.2 
.................... #bit trisbr2 = trise.1 
.................... #bit dir1=portc.3 
.................... #bit dir2=portc.0 
.................... #bit trisdir1 = trisc.3 
.................... #bit trisdir2 = trisc.0 
.................... #bit pwm1=portc.2 
.................... #bit pwm2=portc.1 
.................... #bit trispwm1 = trisc.2 
.................... #bit trispwm2 = trisc.1 
....................  
.................... void dc1t(INT16 x) 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
*
0BDA:  BCF    F96.2
0BDC:  BCF    F94.3
0BDE:  BCF    F94.2
....................    dir1 = 1; 
0BE0:  BSF    F82.3
....................    br1 = 0; 
0BE2:  BCF    F84.2
....................    setup_timer_2(T2_DIV_BY_4,250,1);      //401 us overflow, 401 us interrupt 
0BE4:  MOVLW  00
0BE6:  IORLW  05
0BE8:  MOVWF  FCA
0BEA:  MOVLW  FA
0BEC:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
0BEE:  BCF    F8B.2
0BF0:  MOVLW  0C
0BF2:  MOVWF  FBD
....................    set_pwm1_duty (x); 
0BF4:  MOVFF  63,02
0BF8:  MOVFF  62,01
0BFC:  RRCF   02,F
0BFE:  RRCF   01,F
0C00:  RRCF   02,F
0C02:  RRCF   01,F
0C04:  RRCF   02,F
0C06:  MOVFF  01,FBE
0C0A:  RRCF   02,F
0C0C:  RRCF   02,W
0C0E:  ANDLW  30
0C10:  MOVWF  00
0C12:  MOVF   FBD,W
0C14:  ANDLW  CF
0C16:  IORWF  00,W
0C18:  MOVWF  FBD
0C1A:  RETURN 0
.................... } 
....................  
.................... void dc1n(INT16 x) 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
*
0E68:  BCF    F96.2
0E6A:  BCF    F94.3
0E6C:  BCF    F94.2
....................    dir1 = 0; 
0E6E:  BCF    F82.3
....................    br1 = 0; 
0E70:  BCF    F84.2
....................    setup_timer_2(T2_DIV_BY_4,250,1);      //401 us overflow, 401 us interrupt 
0E72:  MOVLW  00
0E74:  IORLW  05
0E76:  MOVWF  FCA
0E78:  MOVLW  FA
0E7A:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
0E7C:  BCF    F8B.2
0E7E:  MOVLW  0C
0E80:  MOVWF  FBD
....................    set_pwm1_duty (x); 
0E82:  MOVFF  63,02
0E86:  MOVFF  62,01
0E8A:  RRCF   02,F
0E8C:  RRCF   01,F
0E8E:  RRCF   02,F
0E90:  RRCF   01,F
0E92:  RRCF   02,F
0E94:  MOVFF  01,FBE
0E98:  RRCF   02,F
0E9A:  RRCF   02,W
0E9C:  ANDLW  30
0E9E:  MOVWF  00
0EA0:  MOVF   FBD,W
0EA2:  ANDLW  CF
0EA4:  IORWF  00,W
0EA6:  MOVWF  FBD
0EA8:  RETURN 0
.................... } 
....................  
.................... void resetdc1() 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
*
0194:  BCF    F96.2
0196:  BCF    F94.3
0198:  BCF    F94.2
....................    setup_timer_2(T2_DIV_BY_4,250,1);      //401 us overflow, 401 us interrupt 
019A:  MOVLW  00
019C:  IORLW  05
019E:  MOVWF  FCA
01A0:  MOVLW  FA
01A2:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
01A4:  BCF    F8B.2
01A6:  MOVLW  0C
01A8:  MOVWF  FBD
....................    set_pwm1_duty (0); 
01AA:  CLRF   FBE
....................    br1 = 1; 
01AC:  BSF    F84.2
....................    dir1 = 0; 
01AE:  BCF    F82.3
01B0:  RETURN 0
.................... } 
....................  
.................... void dc2n(INT16 x) 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
*
0EAA:  BCF    F96.1
0EAC:  BCF    F94.0
0EAE:  BCF    F94.1
....................    dir2 = 1; 
0EB0:  BSF    F82.0
....................    br2 = 0; 
0EB2:  BCF    F84.1
....................    setup_timer_2(T2_DIV_BY_4,250,1);      //401 us overflow, 401 us interrupt 
0EB4:  MOVLW  00
0EB6:  IORLW  05
0EB8:  MOVWF  FCA
0EBA:  MOVLW  FA
0EBC:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
0EBE:  BCF    F8B.1
0EC0:  MOVLW  0C
0EC2:  MOVWF  FBA
....................    set_pwm2_duty (x); 
0EC4:  MOVFF  63,02
0EC8:  MOVFF  62,01
0ECC:  RRCF   02,F
0ECE:  RRCF   01,F
0ED0:  RRCF   02,F
0ED2:  RRCF   01,F
0ED4:  RRCF   02,F
0ED6:  MOVFF  01,FBB
0EDA:  RRCF   02,F
0EDC:  RRCF   02,W
0EDE:  ANDLW  30
0EE0:  MOVWF  00
0EE2:  MOVF   FBA,W
0EE4:  ANDLW  CF
0EE6:  IORWF  00,W
0EE8:  MOVWF  FBA
0EEA:  GOTO   111A (RETURN)
.................... } 
....................  
.................... void dc2t(INT16 x) 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
*
0C1C:  BCF    F96.1
0C1E:  BCF    F94.0
0C20:  BCF    F94.1
....................    br2 = 0; 
0C22:  BCF    F84.1
....................    dir2 = 0; 
0C24:  BCF    F82.0
....................    setup_timer_2(T2_DIV_BY_4,250,1);      //401 us overflow, 401 us interrupt 
0C26:  MOVLW  00
0C28:  IORLW  05
0C2A:  MOVWF  FCA
0C2C:  MOVLW  FA
0C2E:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
0C30:  BCF    F8B.1
0C32:  MOVLW  0C
0C34:  MOVWF  FBA
....................    set_pwm2_duty (x); 
0C36:  MOVFF  63,02
0C3A:  MOVFF  62,01
0C3E:  RRCF   02,F
0C40:  RRCF   01,F
0C42:  RRCF   02,F
0C44:  RRCF   01,F
0C46:  RRCF   02,F
0C48:  MOVFF  01,FBB
0C4C:  RRCF   02,F
0C4E:  RRCF   02,W
0C50:  ANDLW  30
0C52:  MOVWF  00
0C54:  MOVF   FBA,W
0C56:  ANDLW  CF
0C58:  IORWF  00,W
0C5A:  MOVWF  FBA
0C5C:  RETURN 0
.................... } 
....................  
.................... void resetdc2() 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
*
01B2:  BCF    F96.1
01B4:  BCF    F94.0
01B6:  BCF    F94.1
....................    br2 = 1; 
01B8:  BSF    F84.1
....................    dir2 = 0; 
01BA:  BCF    F82.0
....................    setup_timer_2(T2_DIV_BY_4,250,1);      //401 us overflow, 401 us interrupt 
01BC:  MOVLW  00
01BE:  IORLW  05
01C0:  MOVWF  FCA
01C2:  MOVLW  FA
01C4:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
01C6:  BCF    F8B.1
01C8:  MOVLW  0C
01CA:  MOVWF  FBA
....................    set_pwm2_duty (0); 
01CC:  CLRF   FBB
01CE:  RETURN 0
.................... } 
....................  
....................  
.................... #bit pwm3 = portd.6 
.................... #bit dir3 = portd.5 
.................... #bit trispwm3 = trisd.6 
.................... #bit trisdir3 = trisd.5 
....................  
....................  
.................... #include <qei_piddc.c> 
....................  
.................... ///// QEI MEM + DU LIEU QEI 
.................... signed int16 En2; 
.................... #define ChanelA PIN_C4 
.................... #define ChanelB PIN_C5 
.................... #INT_EXT1 
.................... void  EXT1_L2H_isr(void)  
.................... { 
.................... INTEDG1^=1; 
*
00C6:  CLRF   00
00C8:  BTFSC  FF1.5
00CA:  INCF   00,F
00CC:  MOVLW  01
00CE:  XORWF  00,F
00D0:  BCF    FF1.5
00D2:  BTFSC  00.0
00D4:  BSF    FF1.5
.................... if (INTEDG1) 
00D6:  BTFSS  FF1.5
00D8:  BRA    00F0
....................    { 
....................    if (input(ChanelB)) {En2--;}  
00DA:  BTFSS  F82.5
00DC:  BRA    00E8
00DE:  MOVF   1D,W
00E0:  BTFSC  FD8.2
00E2:  DECF   1E,F
00E4:  DECF   1D,F
00E6:  BRA    00EE
....................    else {En2++;} 
00E8:  INCF   1D,F
00EA:  BTFSC  FD8.2
00EC:  INCF   1E,F
....................    } 
00EE:  BRA    0104
.................... else  
....................    {  
....................    if (input(ChanelB)) {En2++;} 
00F0:  BTFSS  F82.5
00F2:  BRA    00FC
00F4:  INCF   1D,F
00F6:  BTFSC  FD8.2
00F8:  INCF   1E,F
00FA:  BRA    0104
....................    else {En2--;} 
00FC:  MOVF   1D,W
00FE:  BTFSC  FD8.2
0100:  DECF   1E,F
0102:  DECF   1D,F
....................    } 
.................... } 
0104:  BCF    FF0.0
0106:  GOTO   0084
.................... #int_EXT2 
.................... void  EXT2_isr(void)  
.................... { 
.................... INTEDG2^=1; 
010A:  CLRF   00
010C:  BTFSC  FF1.4
010E:  INCF   00,F
0110:  MOVLW  01
0112:  XORWF  00,F
0114:  BCF    FF1.4
0116:  BTFSC  00.0
0118:  BSF    FF1.4
.................... if (INTEDG2) 
011A:  BTFSS  FF1.4
011C:  BRA    0134
....................    { 
....................    if (input(ChanelA)) {En2++;}  
011E:  BTFSS  F82.4
0120:  BRA    012A
0122:  INCF   1D,F
0124:  BTFSC  FD8.2
0126:  INCF   1E,F
0128:  BRA    0132
....................    else {En2--;} 
012A:  MOVF   1D,W
012C:  BTFSC  FD8.2
012E:  DECF   1E,F
0130:  DECF   1D,F
....................    } 
0132:  BRA    0148
.................... else  
....................    {  
....................    if (input(ChanelA)) {En2--;} 
0134:  BTFSS  F82.4
0136:  BRA    0142
0138:  MOVF   1D,W
013A:  BTFSC  FD8.2
013C:  DECF   1E,F
013E:  DECF   1D,F
0140:  BRA    0148
....................    else {En2++;} 
0142:  INCF   1D,F
0144:  BTFSC  FD8.2
0146:  INCF   1E,F
....................    } 
0148:  BCF    FF0.1
014A:  GOTO   0084
.................... } 
....................  
.................... /// PID DONG CO 1 ////////////////// 
.................... volatile float kp=2, ki=0.2,kd=0.7, pid1, pid2; 
.................... signed int16 realvt1, errs1=0, err1=0, delta1=0, epre1=0, duty1 ; 
.................... signed int16 realvt2, errs2=0, err2=0, delta2=0, epre2=0, duty2 ; 
.................... volatile unsigned int16 Ti1,Ti2; 
.................... volatile signed int16 setvt1,setvt2,vt1=900,vt2=900; 
....................  
.................... void piddc1(signed int16 setvt1, signed int16 vt1) 
....................      { 
....................      br1=0; 
*
05AC:  BCF    F84.2
....................      realvt1 =  qei_get_count();  
05AE:  MOVFF  F67,01
05B2:  MOVFF  F66,00
05B6:  MOVFF  F67,03
05BA:  MOVF   03,W
05BC:  SUBWF  01,W
05BE:  BZ    05C4
05C0:  MOVFF  F66,00
05C4:  MOVF   00,W
05C6:  MOVWF  33
05C8:  MOVFF  03,34
....................      err1 = setvt1 - realvt1; 
05CC:  MOVF   33,W
05CE:  SUBWF  x68,W
05D0:  MOVWF  37
05D2:  MOVF   34,W
05D4:  SUBWFB x69,W
05D6:  MOVWF  38
....................      if(Ti1>=2) 
05D8:  MOVF   4C,F
05DA:  BNZ   05E2
05DC:  MOVF   4B,W
05DE:  SUBLW  01
05E0:  BC    0642
....................      { 
....................        delta1 = err1-epre1; 
05E2:  MOVF   3B,W
05E4:  SUBWF  37,W
05E6:  MOVWF  39
05E8:  MOVF   3C,W
05EA:  SUBWFB 38,W
05EC:  MOVWF  3A
....................        Ti1=0; 
05EE:  CLRF   4C
05F0:  CLRF   4B
....................        if(delta1>-10) errs1 += err1;//(err1>-20)&&(err1<20) 
05F2:  BTFSS  3A.7
05F4:  BRA    0606
05F6:  MOVF   3A,W
05F8:  SUBLW  FE
05FA:  BC    060E
05FC:  XORLW  FF
05FE:  BNZ   0606
0600:  MOVF   39,W
0602:  SUBLW  F6
0604:  BC    060E
0606:  MOVF   37,W
0608:  ADDWF  35,F
060A:  MOVF   38,W
060C:  ADDWFC 36,F
....................        if (errs1 > 200 ) errs1=200; 
060E:  BTFSC  36.7
0610:  BRA    0622
0612:  MOVF   36,F
0614:  BNZ   061C
0616:  MOVF   35,W
0618:  SUBLW  C8
061A:  BC    0622
061C:  CLRF   36
061E:  MOVLW  C8
0620:  MOVWF  35
....................        if (errs1 < -200 ) errs1=-200; 
0622:  BTFSS  36.7
0624:  BRA    063A
0626:  MOVF   36,W
0628:  SUBLW  FF
062A:  BNC   063A
062C:  BNZ   0634
062E:  MOVF   35,W
0630:  SUBLW  37
0632:  BNC   063A
0634:  SETF   36
0636:  MOVLW  38
0638:  MOVWF  35
....................        epre1=err1; 
063A:  MOVFF  38,3C
063E:  MOVFF  37,3B
....................      } 
....................    
....................      pid1 =kp*err1 + ki*errs1+kd*delta1;  
0642:  MOVFF  38,71
0646:  MOVFF  37,70
064A:  RCALL  01D0
064C:  MOVFF  22,73
0650:  MOVFF  21,72
0654:  MOVFF  20,71
0658:  MOVFF  1F,70
065C:  MOVFF  03,77
0660:  MOVFF  02,76
0664:  MOVFF  01,75
0668:  MOVFF  00,74
066C:  RCALL  0218
066E:  MOVFF  03,6F
0672:  MOVFF  02,6E
0676:  MOVFF  01,6D
067A:  MOVFF  00,6C
067E:  MOVFF  36,71
0682:  MOVFF  35,70
0686:  RCALL  01D0
0688:  MOVFF  26,73
068C:  MOVFF  25,72
0690:  MOVFF  24,71
0694:  MOVFF  23,70
0698:  MOVFF  03,77
069C:  MOVFF  02,76
06A0:  MOVFF  01,75
06A4:  MOVFF  00,74
06A8:  RCALL  0218
06AA:  BCF    FD8.1
06AC:  MOVFF  6F,73
06B0:  MOVFF  6E,72
06B4:  MOVFF  6D,71
06B8:  MOVFF  6C,70
06BC:  MOVFF  03,77
06C0:  MOVFF  02,76
06C4:  MOVFF  01,75
06C8:  MOVFF  00,74
06CC:  RCALL  030A
06CE:  MOVFF  03,6F
06D2:  MOVFF  02,6E
06D6:  MOVFF  01,6D
06DA:  MOVFF  00,6C
06DE:  MOVFF  3A,71
06E2:  MOVFF  39,70
06E6:  RCALL  01D0
06E8:  MOVFF  2A,73
06EC:  MOVFF  29,72
06F0:  MOVFF  28,71
06F4:  MOVFF  27,70
06F8:  MOVFF  03,77
06FC:  MOVFF  02,76
0700:  MOVFF  01,75
0704:  MOVFF  00,74
0708:  RCALL  0218
070A:  BCF    FD8.1
070C:  MOVFF  6F,73
0710:  MOVFF  6E,72
0714:  MOVFF  6D,71
0718:  MOVFF  6C,70
071C:  MOVFF  03,77
0720:  MOVFF  02,76
0724:  MOVFF  01,75
0728:  MOVFF  00,74
072C:  RCALL  030A
072E:  MOVFF  03,2E
0732:  MOVFF  02,2D
0736:  MOVFF  01,2C
073A:  MOVFF  00,2B
....................      duty1=pid1;    
073E:  MOVFF  2E,6F
0742:  MOVFF  2D,6E
0746:  MOVFF  2C,6D
074A:  MOVFF  2B,6C
074E:  RCALL  0574
0750:  MOVFF  02,3E
0754:  MOVFF  01,3D
....................      if (duty1 > 0)   dir1 = 0; 
0758:  BTFSC  3E.7
075A:  BRA    0768
075C:  MOVF   3E,F
075E:  BNZ   0766
0760:  MOVF   3D,W
0762:  SUBLW  00
0764:  BC    0768
0766:  BCF    F82.3
....................      if (duty1 <  0)    dir1 = 1; 
0768:  BTFSS  3E.7
076A:  BRA    076E
076C:  BSF    F82.3
....................      duty1= abs(duty1); 
076E:  MOVFF  3E,03
0772:  MOVF   3D,W
0774:  BTFSS  3E.7
0776:  BRA    0788
0778:  MOVLW  00
077A:  BSF    FD8.0
077C:  SUBFWB 3D,W
077E:  MOVWF  00
0780:  MOVLW  00
0782:  SUBFWB 3E,W
0784:  MOVWF  03
0786:  MOVF   00,W
0788:  MOVWF  3D
078A:  MOVFF  03,3E
....................      if(duty1>5) duty1+=230; 
078E:  BTFSC  3E.7
0790:  BRA    07A4
0792:  MOVF   3E,F
0794:  BNZ   079C
0796:  MOVF   3D,W
0798:  SUBLW  05
079A:  BC    07A4
079C:  MOVLW  E6
079E:  ADDWF  3D,F
07A0:  MOVLW  00
07A2:  ADDWFC 3E,F
....................      if(duty1>vt1) duty1=vt1; 
07A4:  BTFSS  x6B.7
07A6:  BRA    07AE
07A8:  BTFSS  3E.7
07AA:  BRA    07C0
07AC:  BRA    07B2
07AE:  BTFSC  3E.7
07B0:  BRA    07C8
07B2:  MOVF   x6B,W
07B4:  SUBWF  3E,W
07B6:  BNC   07C8
07B8:  BNZ   07C0
07BA:  MOVF   3D,W
07BC:  SUBWF  x6A,W
07BE:  BC    07C8
07C0:  MOVFF  6B,3E
07C4:  MOVFF  6A,3D
....................      set_pwm1_duty (duty1); 
07C8:  MOVFF  3E,02
07CC:  MOVFF  3D,01
07D0:  RRCF   02,F
07D2:  RRCF   01,F
07D4:  RRCF   02,F
07D6:  RRCF   01,F
07D8:  RRCF   02,F
07DA:  MOVFF  01,FBE
07DE:  RRCF   02,F
07E0:  RRCF   02,W
07E2:  ANDLW  30
07E4:  MOVWF  00
07E6:  MOVF   FBD,W
07E8:  ANDLW  CF
07EA:  IORWF  00,W
07EC:  MOVWF  FBD
07EE:  RETURN 0
....................      } 
....................       
.................... /// PID DONG CO 2 ////////////////// 
....................  
.................... void piddc2(signed int16 setvt2, signed int16 vt2) 
....................      { 
....................      br2=0; 
07F0:  BCF    F84.1
....................      realvt2 =  En2;  
07F2:  MOVFF  1E,40
07F6:  MOVFF  1D,3F
....................      err2 = setvt2 - realvt2; 
07FA:  MOVF   3F,W
07FC:  SUBWF  x68,W
07FE:  MOVWF  43
0800:  MOVF   40,W
0802:  SUBWFB x69,W
0804:  MOVWF  44
....................      if(Ti2>=2) 
0806:  MOVF   4E,F
0808:  BNZ   0810
080A:  MOVF   4D,W
080C:  SUBLW  01
080E:  BC    0870
....................      { 
....................        delta2 = err2-epre2; 
0810:  MOVF   47,W
0812:  SUBWF  43,W
0814:  MOVWF  45
0816:  MOVF   48,W
0818:  SUBWFB 44,W
081A:  MOVWF  46
....................        Ti2=0; 
081C:  CLRF   4E
081E:  CLRF   4D
....................        if(delta2>-10) errs2 += err2; /// (err2>-20)&&(err2<20) 
0820:  BTFSS  46.7
0822:  BRA    0834
0824:  MOVF   46,W
0826:  SUBLW  FE
0828:  BC    083C
082A:  XORLW  FF
082C:  BNZ   0834
082E:  MOVF   45,W
0830:  SUBLW  F6
0832:  BC    083C
0834:  MOVF   43,W
0836:  ADDWF  41,F
0838:  MOVF   44,W
083A:  ADDWFC 42,F
....................        if (errs2 > 200 ) errs2=200; 
083C:  BTFSC  42.7
083E:  BRA    0850
0840:  MOVF   42,F
0842:  BNZ   084A
0844:  MOVF   41,W
0846:  SUBLW  C8
0848:  BC    0850
084A:  CLRF   42
084C:  MOVLW  C8
084E:  MOVWF  41
....................        if (errs2 < -200 ) errs2=-200; 
0850:  BTFSS  42.7
0852:  BRA    0868
0854:  MOVF   42,W
0856:  SUBLW  FF
0858:  BNC   0868
085A:  BNZ   0862
085C:  MOVF   41,W
085E:  SUBLW  37
0860:  BNC   0868
0862:  SETF   42
0864:  MOVLW  38
0866:  MOVWF  41
....................        epre2=err2; 
0868:  MOVFF  44,48
086C:  MOVFF  43,47
....................      } 
....................    
....................      pid2 =kp*err2 + ki*errs2+kd*delta2;  
0870:  MOVFF  44,71
0874:  MOVFF  43,70
0878:  RCALL  01D0
087A:  MOVFF  22,73
087E:  MOVFF  21,72
0882:  MOVFF  20,71
0886:  MOVFF  1F,70
088A:  MOVFF  03,77
088E:  MOVFF  02,76
0892:  MOVFF  01,75
0896:  MOVFF  00,74
089A:  RCALL  0218
089C:  MOVFF  03,6F
08A0:  MOVFF  02,6E
08A4:  MOVFF  01,6D
08A8:  MOVFF  00,6C
08AC:  MOVFF  42,71
08B0:  MOVFF  41,70
08B4:  RCALL  01D0
08B6:  MOVFF  26,73
08BA:  MOVFF  25,72
08BE:  MOVFF  24,71
08C2:  MOVFF  23,70
08C6:  MOVFF  03,77
08CA:  MOVFF  02,76
08CE:  MOVFF  01,75
08D2:  MOVFF  00,74
08D6:  RCALL  0218
08D8:  BCF    FD8.1
08DA:  MOVFF  6F,73
08DE:  MOVFF  6E,72
08E2:  MOVFF  6D,71
08E6:  MOVFF  6C,70
08EA:  MOVFF  03,77
08EE:  MOVFF  02,76
08F2:  MOVFF  01,75
08F6:  MOVFF  00,74
08FA:  RCALL  030A
08FC:  MOVFF  03,6F
0900:  MOVFF  02,6E
0904:  MOVFF  01,6D
0908:  MOVFF  00,6C
090C:  MOVFF  46,71
0910:  MOVFF  45,70
0914:  RCALL  01D0
0916:  MOVFF  2A,73
091A:  MOVFF  29,72
091E:  MOVFF  28,71
0922:  MOVFF  27,70
0926:  MOVFF  03,77
092A:  MOVFF  02,76
092E:  MOVFF  01,75
0932:  MOVFF  00,74
0936:  RCALL  0218
0938:  BCF    FD8.1
093A:  MOVFF  6F,73
093E:  MOVFF  6E,72
0942:  MOVFF  6D,71
0946:  MOVFF  6C,70
094A:  MOVFF  03,77
094E:  MOVFF  02,76
0952:  MOVFF  01,75
0956:  MOVFF  00,74
095A:  RCALL  030A
095C:  MOVFF  03,32
0960:  MOVFF  02,31
0964:  MOVFF  01,30
0968:  MOVFF  00,2F
....................      duty2=pid2;     
096C:  MOVFF  32,6F
0970:  MOVFF  31,6E
0974:  MOVFF  30,6D
0978:  MOVFF  2F,6C
097C:  RCALL  0574
097E:  MOVFF  02,4A
0982:  MOVFF  01,49
....................      if (duty2 > 0)   dir2 = 1; 
0986:  BTFSC  4A.7
0988:  BRA    0996
098A:  MOVF   4A,F
098C:  BNZ   0994
098E:  MOVF   49,W
0990:  SUBLW  00
0992:  BC    0996
0994:  BSF    F82.0
....................      if (duty2 <  0)    dir2 = 0; 
0996:  BTFSS  4A.7
0998:  BRA    099C
099A:  BCF    F82.0
....................      duty2= abs(duty2); 
099C:  MOVFF  4A,03
09A0:  MOVF   49,W
09A2:  BTFSS  4A.7
09A4:  BRA    09B6
09A6:  MOVLW  00
09A8:  BSF    FD8.0
09AA:  SUBFWB 49,W
09AC:  MOVWF  00
09AE:  MOVLW  00
09B0:  SUBFWB 4A,W
09B2:  MOVWF  03
09B4:  MOVF   00,W
09B6:  MOVWF  49
09B8:  MOVFF  03,4A
....................      if(duty2>5) duty2+=230; 
09BC:  BTFSC  4A.7
09BE:  BRA    09D2
09C0:  MOVF   4A,F
09C2:  BNZ   09CA
09C4:  MOVF   49,W
09C6:  SUBLW  05
09C8:  BC    09D2
09CA:  MOVLW  E6
09CC:  ADDWF  49,F
09CE:  MOVLW  00
09D0:  ADDWFC 4A,F
....................      if(duty2>vt2) duty2=vt2; 
09D2:  BTFSS  x6B.7
09D4:  BRA    09DC
09D6:  BTFSS  4A.7
09D8:  BRA    09EE
09DA:  BRA    09E0
09DC:  BTFSC  4A.7
09DE:  BRA    09F6
09E0:  MOVF   x6B,W
09E2:  SUBWF  4A,W
09E4:  BNC   09F6
09E6:  BNZ   09EE
09E8:  MOVF   49,W
09EA:  SUBWF  x6A,W
09EC:  BC    09F6
09EE:  MOVFF  6B,4A
09F2:  MOVFF  6A,49
....................      set_pwm2_duty (duty2); 
09F6:  MOVFF  4A,02
09FA:  MOVFF  49,01
09FE:  RRCF   02,F
0A00:  RRCF   01,F
0A02:  RRCF   02,F
0A04:  RRCF   01,F
0A06:  RRCF   02,F
0A08:  MOVFF  01,FBB
0A0C:  RRCF   02,F
0A0E:  RRCF   02,W
0A10:  ANDLW  30
0A12:  MOVWF  00
0A14:  MOVF   FBA,W
0A16:  ANDLW  CF
0A18:  IORWF  00,W
0A1A:  MOVWF  FBA
0A1C:  RETURN 0
....................      } 
....................       
....................  
....................  
....................  
....................  
....................  
.................... ///// CHUONG TRINH QUET PHIM 
.................... int8 demct=0; 
....................  
.................... ///// NGAT TIMER0 LEO THANG, SERVO 
.................... volatile char demservo=0, xungleo=100; 
.................... volatile int1 dclep=0 ; 
.................... int16 demvanduoi=0; 
.................... #int_timer0 
.................... void ngat_timer0(void)  
....................    { 
....................    demvanduoi++; 
*
014E:  INCF   5B,F
0150:  BTFSC  FD8.2
0152:  INCF   5C,F
....................    if (dclep==1) 
0154:  BTFSS  5A.0
0156:  BRA    0174
....................    { 
....................       set_timer0(5); 
0158:  CLRF   FD7
015A:  MOVLW  05
015C:  MOVWF  FD6
....................       demservo++; 
015E:  INCF   58,F
....................       if (demservo>100) 
0160:  MOVF   58,W
0162:  SUBLW  64
0164:  BC    016A
....................          { 
....................          demservo=0; 
0166:  CLRF   58
....................          pwm3=0; 
0168:  BCF    F83.6
....................          } 
....................       if (demservo >=xungleo) pwm3=1; 
016A:  MOVF   59,W
016C:  SUBWF  58,W
016E:  BNC   0172
0170:  BSF    F83.6
....................    } 
0172:  BRA    018E
....................    else 
....................       { 
....................       set_timer0(5); 
0174:  CLRF   FD7
0176:  MOVLW  05
0178:  MOVWF  FD6
....................       demservo++; 
017A:  INCF   58,F
....................       if (demservo>=200) 
017C:  MOVF   58,W
017E:  SUBLW  C7
0180:  BC    0186
....................          { 
....................          demservo=0; 
0182:  CLRF   58
....................          output_high(pin_c7); 
0184:  BSF    F8B.7
....................          } 
....................       if (demservo >=xungleo) output_low(pin_c7); 
0186:  MOVF   59,W
0188:  SUBWF  58,W
018A:  BNC   018E
018C:  BCF    F8B.7
....................       } 
018E:  BCF    FF2.2
0190:  GOTO   0084
....................    }    
....................       
.................... ///// NGAT TIMER1 PID 
.................... volatile int8 chonpid=4; 
.................... #int_timer1 
.................... void ngat_timer1(void)  
....................    { 
....................       Ti1++; 
*
0A1E:  INCF   4B,F
0A20:  BTFSC  FD8.2
0A22:  INCF   4C,F
....................       Ti2++; 
0A24:  INCF   4D,F
0A26:  BTFSC  FD8.2
0A28:  INCF   4E,F
....................       switch (chonpid)   
0A2A:  MOVF   5D,W
0A2C:  ADDLW  FC
0A2E:  BC    0A96
0A30:  ADDLW  04
0A32:  GOTO   0AA4
....................          { 
....................           case 0 : disable_interrupts(int_timer1); resetdc1(); resetdc2(); break; 
0A36:  BCF    F9D.0
0A38:  CALL   0194
0A3C:  CALL   01B2
0A40:  BRA    0A96
....................           case 1 : resetdc2(); piddc1(setvt1,vt1); break; 
0A42:  CALL   01B2
0A46:  MOVFF  50,69
0A4A:  MOVFF  4F,68
0A4E:  MOVFF  54,6B
0A52:  MOVFF  53,6A
0A56:  RCALL  05AC
0A58:  BRA    0A96
....................           case 2 : resetdc1(); piddc2(setvt2,vt2); break; 
0A5A:  CALL   0194
0A5E:  MOVFF  52,69
0A62:  MOVFF  51,68
0A66:  MOVFF  56,6B
0A6A:  MOVFF  55,6A
0A6E:  RCALL  07F0
0A70:  BRA    0A96
....................           case 3 : piddc1(setvt1,vt1); piddc2(setvt2,vt2);  break; 
0A72:  MOVFF  50,69
0A76:  MOVFF  4F,68
0A7A:  MOVFF  54,6B
0A7E:  MOVFF  53,6A
0A82:  RCALL  05AC
0A84:  MOVFF  52,69
0A88:  MOVFF  51,68
0A8C:  MOVFF  56,6B
0A90:  MOVFF  55,6A
0A94:  RCALL  07F0
....................          } 
....................         
....................       set_timer1(50286);    
0A96:  MOVLW  C4
0A98:  MOVWF  FCF
0A9A:  MOVLW  6E
0A9C:  MOVWF  FCE
....................        
....................    } 
....................     
.................... ///// NGAT TIMER5 QUET PHIM  
0A9E:  BCF    F9E.0
0AA0:  GOTO   0084
.................... #int_timer5 
.................... void ngat_timer5(void)  
....................    { 
....................       
....................       set_timer5(53035); 
*
0B10:  MOVLW  CF
0B12:  MOVWF  F88
0B14:  MOVLW  2B
0B16:  MOVWF  F87
....................       demct++; 
0B18:  INCF   57,F
....................        
....................       if (demct==2) { beep(1,50); } 
0B1A:  MOVF   57,W
0B1C:  SUBLW  02
0B1E:  BNZ   0B2A
0B20:  MOVLW  01
0B22:  MOVWF  x68
0B24:  MOVLW  32
0B26:  MOVWF  x69
0B28:  RCALL  0AEC
....................       if (demct==50) { beep(1,50); } 
0B2A:  MOVF   57,W
0B2C:  SUBLW  32
0B2E:  BNZ   0B3A
0B30:  MOVLW  01
0B32:  MOVWF  x68
0B34:  MOVLW  32
0B36:  MOVWF  x69
0B38:  RCALL  0AEC
....................       if (demct==100) { beep(1,50); } 
0B3A:  MOVF   57,W
0B3C:  SUBLW  64
0B3E:  BNZ   0B4A
0B40:  MOVLW  01
0B42:  MOVWF  x68
0B44:  MOVLW  32
0B46:  MOVWF  x69
0B48:  RCALL  0AEC
....................       if (demct==150) { beep(1,50); } 
0B4A:  MOVF   57,W
0B4C:  SUBLW  96
0B4E:  BNZ   0B5A
0B50:  MOVLW  01
0B52:  MOVWF  x68
0B54:  MOVLW  32
0B56:  MOVWF  x69
0B58:  RCALL  0AEC
....................        
....................       if (demct>200) {demct=0; disable_interrupts(int_timer5); } 
0B5A:  MOVF   57,W
0B5C:  SUBLW  C8
0B5E:  BC    0B64
0B60:  CLRF   57
0B62:  BCF    FA3.0
....................        
....................        
....................    }    
....................  
.................... ///// KHAI BAO NHIEM VU 
.................... //#include <resetall.c> 
0B64:  BCF    FA4.0
0B66:  GOTO   0084
.................... #include <resetvan.c> 
....................  
.................... ///// RESET TAT CA 
.................... int8 ire=0; 
....................  
.................... void resetvan() 
.................... { 
....................  
.................... disable_interrupts(int_timer1); 
*
0C5E:  BCF    F9D.0
.................... disable_interrupts(int_timer0); 
0C60:  BCF    FF2.5
....................  
.................... delay_ms(500); 
0C62:  MOVLW  02
0C64:  MOVWF  x62
0C66:  CLRF   16
0C68:  BTFSC  FF2.7
0C6A:  BSF    16.7
0C6C:  BCF    FF2.7
0C6E:  MOVLW  FA
0C70:  MOVWF  x6C
0C72:  RCALL  0AC6
0C74:  BTFSC  16.7
0C76:  BSF    FF2.7
0C78:  DECFSZ x62,F
0C7A:  BRA    0C66
0C7C:  CLRF   16
0C7E:  BTFSC  FF2.7
0C80:  BSF    16.7
0C82:  BCF    FF2.7
.................... beep(1,100); 
0C84:  MOVLW  01
0C86:  MOVWF  x68
0C88:  MOVLW  64
0C8A:  MOVWF  x69
0C8C:  RCALL  0AEC
0C8E:  BTFSC  16.7
0C90:  BSF    FF2.7
....................  
.................... for (ire=0; ire<50; ire++) 
0C92:  CLRF   5E
0C94:  MOVF   5E,W
0C96:  SUBLW  31
0C98:  BNC   0CDA
....................    { 
....................    if (ctsel==0) {vancanh1=vancanh2=0; delay_ms(1000); vantay1=vantay2=0; ire=100; } 
0C9A:  BTFSC  F81.7
0C9C:  BRA    0CC4
0C9E:  BCF    F80.0
0CA0:  BCF    F80.1
0CA2:  MOVLW  04
0CA4:  MOVWF  x62
0CA6:  CLRF   16
0CA8:  BTFSC  FF2.7
0CAA:  BSF    16.7
0CAC:  BCF    FF2.7
0CAE:  MOVLW  FA
0CB0:  MOVWF  x6C
0CB2:  RCALL  0AC6
0CB4:  BTFSC  16.7
0CB6:  BSF    FF2.7
0CB8:  DECFSZ x62,F
0CBA:  BRA    0CA6
0CBC:  BCF    F84.0
0CBE:  BCF    F80.5
0CC0:  MOVLW  64
0CC2:  MOVWF  5E
0CC4:  CLRF   16
0CC6:  BTFSC  FF2.7
0CC8:  BSF    16.7
0CCA:  BCF    FF2.7
....................    delay_ms(10); 
0CCC:  MOVLW  0A
0CCE:  MOVWF  x6C
0CD0:  RCALL  0AC6
0CD2:  BTFSC  16.7
0CD4:  BSF    FF2.7
0CD6:  INCF   5E,F
0CD8:  BRA    0C94
....................    } 
.................... delay_ms(500);    
0CDA:  MOVLW  02
0CDC:  MOVWF  x62
0CDE:  CLRF   16
0CE0:  BTFSC  FF2.7
0CE2:  BSF    16.7
0CE4:  BCF    FF2.7
0CE6:  MOVLW  FA
0CE8:  MOVWF  x6C
0CEA:  RCALL  0AC6
0CEC:  BTFSC  16.7
0CEE:  BSF    FF2.7
0CF0:  DECFSZ x62,F
0CF2:  BRA    0CDE
.................... while (ctc1==1) { dc1t(430); } 
0CF4:  BTFSS  F81.3
0CF6:  BRA    0D04
0CF8:  MOVLW  01
0CFA:  MOVWF  x63
0CFC:  MOVLW  AE
0CFE:  MOVWF  x62
0D00:  RCALL  0BDA
0D02:  BRA    0CF4
.................... resetdc1(); 
0D04:  CALL   0194
.................... while (ctc2==1) { dc2t(600); } 
0D08:  BTFSS  F81.1
0D0A:  BRA    0D18
0D0C:  MOVLW  02
0D0E:  MOVWF  x63
0D10:  MOVLW  58
0D12:  MOVWF  x62
0D14:  RCALL  0C1C
0D16:  BRA    0D08
.................... resetdc2(); 
0D18:  CALL   01B2
0D1C:  CLRF   16
0D1E:  BTFSC  FF2.7
0D20:  BSF    16.7
0D22:  BCF    FF2.7
.................... beep(1,100); 
0D24:  MOVLW  01
0D26:  MOVWF  x68
0D28:  MOVLW  64
0D2A:  MOVWF  x69
0D2C:  RCALL  0AEC
0D2E:  BTFSC  16.7
0D30:  BSF    FF2.7
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
0D32:  BSF    F80.2
0D34:  BSF    F80.0
0D36:  BSF    F80.1
0D38:  BSF    F84.0
0D3A:  BSF    F80.5
....................  
.................... trispwm3=trisdir3=0; 
0D3C:  BCF    F95.5
0D3E:  BCF    F95.6
.................... pwm3=dir3=1; 
0D40:  BSF    F83.5
0D42:  BSF    F83.6
.................... enable_interrupts(int_timer0); 
0D44:  BSF    FF2.5
.................... dclep=1; 
0D46:  BSF    5A.0
.................... while (ctlt==1) 
0D48:  BTFSS  F81.5
0D4A:  BRA    0D54
....................    { 
....................    dir3=1; 
0D4C:  BSF    F83.5
....................    xungleo=30; 
0D4E:  MOVLW  1E
0D50:  MOVWF  59
0D52:  BRA    0D48
....................    } 
....................    xungleo=0;   
0D54:  CLRF   59
....................    delay_ms(300); 
0D56:  MOVLW  02
0D58:  MOVWF  x62
0D5A:  CLRF   16
0D5C:  BTFSC  FF2.7
0D5E:  BSF    16.7
0D60:  BCF    FF2.7
0D62:  MOVLW  96
0D64:  MOVWF  x6C
0D66:  RCALL  0AC6
0D68:  BTFSC  16.7
0D6A:  BSF    FF2.7
0D6C:  DECFSZ x62,F
0D6E:  BRA    0D5A
.................... while (ctlt==0) 
0D70:  BTFSC  F81.5
0D72:  BRA    0D7C
....................    { 
....................    dir3=0;  
0D74:  BCF    F83.5
....................    xungleo=60; 
0D76:  MOVLW  3C
0D78:  MOVWF  59
0D7A:  BRA    0D70
....................    } 
....................    xungleo=0; 
0D7C:  CLRF   59
0D7E:  CLRF   16
0D80:  BTFSC  FF2.7
0D82:  BSF    16.7
0D84:  BCF    FF2.7
....................    beep(1,100);    
0D86:  MOVLW  01
0D88:  MOVWF  x68
0D8A:  MOVLW  64
0D8C:  MOVWF  x69
0D8E:  RCALL  0AEC
0D90:  BTFSC  16.7
0D92:  BSF    FF2.7
.................... disable_interrupts(int_timer0); 
0D94:  BCF    FF2.5
.................... pwm3=1; 
0D96:  BSF    F83.6
.................... dir3=1; 
0D98:  BSF    F83.5
0D9A:  CLRF   16
0D9C:  BTFSC  FF2.7
0D9E:  BSF    16.7
0DA0:  BCF    FF2.7
.................... beep(1,100); 
0DA2:  MOVLW  01
0DA4:  MOVWF  x68
0DA6:  MOVLW  64
0DA8:  MOVWF  x69
0DAA:  RCALL  0AEC
0DAC:  BTFSC  16.7
0DAE:  BSF    FF2.7
....................  
.................... qei_set_count(0); 
0DB0:  CLRF   F67
0DB2:  CLRF   F66
.................... En2=0; 
0DB4:  CLRF   1E
0DB6:  CLRF   1D
.................... Ti1=0; 
0DB8:  CLRF   4C
0DBA:  CLRF   4B
.................... Ti2=0; 
0DBC:  CLRF   4E
0DBE:  CLRF   4D
.................... setvt1=0; 
0DC0:  CLRF   50
0DC2:  CLRF   4F
.................... setvt2=0; 
0DC4:  CLRF   52
0DC6:  CLRF   51
.................... chonpid=4; 
0DC8:  MOVLW  04
0DCA:  MOVWF  5D
....................  
.................... demct=200; 
0DCC:  MOVLW  C8
0DCE:  MOVWF  57
.................... enable_interrupts(int_timer5); 
0DD0:  BSF    FA3.0
0DD2:  RETURN 0
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #include <nhiemvu2.c> 
....................  
.................... ///// NHIEM VU 2 
....................  
.................... void nhiemvu2() 
.................... { 
....................  
.................... delay_ms(1000); 
0DD4:  MOVLW  04
0DD6:  MOVWF  x62
0DD8:  CLRF   16
0DDA:  BTFSC  FF2.7
0DDC:  BSF    16.7
0DDE:  BCF    FF2.7
0DE0:  MOVLW  FA
0DE2:  MOVWF  x6C
0DE4:  RCALL  0AC6
0DE6:  BTFSC  16.7
0DE8:  BSF    FF2.7
0DEA:  DECFSZ x62,F
0DEC:  BRA    0DD8
0DEE:  CLRF   16
0DF0:  BTFSC  FF2.7
0DF2:  BSF    16.7
0DF4:  BCF    FF2.7
.................... beep(2,100); 
0DF6:  MOVLW  02
0DF8:  MOVWF  x68
0DFA:  MOVLW  64
0DFC:  MOVWF  x69
0DFE:  RCALL  0AEC
0E00:  BTFSC  16.7
0E02:  BSF    FF2.7
....................  
.................... while(cten==0){} 
0E04:  BTFSS  F81.6
0E06:  BRA    0E04
.................... delay_ms(1000); 
0E08:  MOVLW  04
0E0A:  MOVWF  x62
0E0C:  CLRF   16
0E0E:  BTFSC  FF2.7
0E10:  BSF    16.7
0E12:  BCF    FF2.7
0E14:  MOVLW  FA
0E16:  MOVWF  x6C
0E18:  RCALL  0AC6
0E1A:  BTFSC  16.7
0E1C:  BSF    FF2.7
0E1E:  DECFSZ x62,F
0E20:  BRA    0E0C
....................  
.................... vanduoi=0;  
0E22:  BCF    F80.2
.................... delay_ms(500); 
0E24:  MOVLW  02
0E26:  MOVWF  x62
0E28:  CLRF   16
0E2A:  BTFSC  FF2.7
0E2C:  BSF    16.7
0E2E:  BCF    FF2.7
0E30:  MOVLW  FA
0E32:  MOVWF  x6C
0E34:  RCALL  0AC6
0E36:  BTFSC  16.7
0E38:  BSF    FF2.7
0E3A:  DECFSZ x62,F
0E3C:  BRA    0E28
....................  
.................... while(cten==1) {} 
0E3E:  BTFSC  F81.6
0E40:  BRA    0E3E
....................  
.................... delay_ms(1000); 
0E42:  MOVLW  04
0E44:  MOVWF  x62
0E46:  CLRF   16
0E48:  BTFSC  FF2.7
0E4A:  BSF    16.7
0E4C:  BCF    FF2.7
0E4E:  MOVLW  FA
0E50:  MOVWF  x6C
0E52:  RCALL  0AC6
0E54:  BTFSC  16.7
0E56:  BSF    FF2.7
0E58:  DECFSZ x62,F
0E5A:  BRA    0E46
....................  
.................... vanduoi=1;  
0E5C:  BSF    F80.2
....................  
.................... demct=200; 
0E5E:  MOVLW  C8
0E60:  MOVWF  57
.................... enable_interrupts(int_timer5); 
0E62:  BSF    FA3.0
0E64:  GOTO   158C (RETURN)
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... #include <nhiemvu3.c> 
....................  
.................... ///// NHIEM VU 3 
.................... int8 inv3=0;  
.................... void nhiemvu3() 
.................... { 
....................  
.................... delay_ms(1000); 
*
0EEE:  MOVLW  04
0EF0:  MOVWF  x62
0EF2:  CLRF   16
0EF4:  BTFSC  FF2.7
0EF6:  BSF    16.7
0EF8:  BCF    FF2.7
0EFA:  MOVLW  FA
0EFC:  MOVWF  x6C
0EFE:  RCALL  0AC6
0F00:  BTFSC  16.7
0F02:  BSF    FF2.7
0F04:  DECFSZ x62,F
0F06:  BRA    0EF2
0F08:  CLRF   16
0F0A:  BTFSC  FF2.7
0F0C:  BSF    16.7
0F0E:  BCF    FF2.7
.................... beep(3,100); 
0F10:  MOVLW  03
0F12:  MOVWF  x68
0F14:  MOVLW  64
0F16:  MOVWF  x69
0F18:  RCALL  0AEC
0F1A:  BTFSC  16.7
0F1C:  BSF    FF2.7
....................  
.................... setup_timer_2(T2_DIV_BY_4,250,1);      //401 us overflow, 401 us interrupt 
0F1E:  MOVLW  00
0F20:  IORLW  05
0F22:  MOVWF  FCA
0F24:  MOVLW  FA
0F26:  MOVWF  FCB
.................... setup_ccp1 (ccp_pwm); 
0F28:  BCF    F8B.2
0F2A:  MOVLW  0C
0F2C:  MOVWF  FBD
.................... setup_ccp2 (ccp_pwm); 
0F2E:  BCF    F8B.1
0F30:  MOVWF  FBA
....................  
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
0F32:  BSF    F80.2
0F34:  BSF    F80.0
0F36:  BSF    F80.1
0F38:  BSF    F84.0
0F3A:  BSF    F80.5
.................... vancanh1=vancanh2=0; 
0F3C:  BCF    F80.0
0F3E:  BCF    F80.1
....................  
.................... chonpid=2; 
0F40:  MOVLW  02
0F42:  MOVWF  5D
.................... setvt2=280; 
0F44:  MOVLW  01
0F46:  MOVWF  52
0F48:  MOVLW  18
0F4A:  MOVWF  51
.................... enable_interrupts(int_timer1); 
0F4C:  BSF    F9D.0
.................... while (En2<280) {} 
0F4E:  BTFSC  1E.7
0F50:  BRA    0F60
0F52:  MOVF   1E,W
0F54:  SUBLW  01
0F56:  BNC   0F62
0F58:  BNZ   0F60
0F5A:  MOVF   1D,W
0F5C:  SUBLW  17
0F5E:  BTFSC  FD8.0
0F60:  BRA    0F4E
....................  
.................... chonpid=1; 
0F62:  MOVLW  01
0F64:  MOVWF  5D
.................... setvt1=227; 
0F66:  CLRF   50
0F68:  MOVLW  E3
0F6A:  MOVWF  4F
.................... while (qei_get_count() <227) {} 
0F6C:  MOVFF  F67,01
0F70:  MOVFF  F66,00
0F74:  MOVFF  F67,03
0F78:  MOVF   03,W
0F7A:  SUBWF  01,W
0F7C:  BZ    0F82
0F7E:  MOVFF  F66,00
0F82:  MOVF   00,W
0F84:  MOVWF  x62
0F86:  MOVFF  03,63
0F8A:  MOVF   x63,F
0F8C:  BNZ   0F96
0F8E:  MOVF   x62,W
0F90:  SUBLW  E2
0F92:  BNC   0F96
0F94:  BRA    0F6C
....................  
.................... vantay1=vantay2=0; 
0F96:  BCF    F84.0
0F98:  BCF    F80.5
....................  
.................... while (ctsel==1) {} 
0F9A:  BTFSC  F81.7
0F9C:  BRA    0F9A
.................... if (ctsel==0) { vantay1=1; beep(1,100); delay_ms(500); } 
0F9E:  BTFSC  F81.7
0FA0:  BRA    0FD4
0FA2:  BSF    F80.5
0FA4:  CLRF   16
0FA6:  BTFSC  FF2.7
0FA8:  BSF    16.7
0FAA:  BCF    FF2.7
0FAC:  MOVLW  01
0FAE:  MOVWF  x68
0FB0:  MOVLW  64
0FB2:  MOVWF  x69
0FB4:  RCALL  0AEC
0FB6:  BTFSC  16.7
0FB8:  BSF    FF2.7
0FBA:  MOVLW  02
0FBC:  MOVWF  x62
0FBE:  CLRF   16
0FC0:  BTFSC  FF2.7
0FC2:  BSF    16.7
0FC4:  BCF    FF2.7
0FC6:  MOVLW  FA
0FC8:  MOVWF  x6C
0FCA:  RCALL  0AC6
0FCC:  BTFSC  16.7
0FCE:  BSF    FF2.7
0FD0:  DECFSZ x62,F
0FD2:  BRA    0FBE
.................... while (ctsel==0) {} 
0FD4:  BTFSS  F81.7
0FD6:  BRA    0FD4
....................  
.................... while (cten==0) {} 
0FD8:  BTFSS  F81.6
0FDA:  BRA    0FD8
....................  
.................... delay_ms(2500); 
0FDC:  MOVLW  0A
0FDE:  MOVWF  x62
0FE0:  CLRF   16
0FE2:  BTFSC  FF2.7
0FE4:  BSF    16.7
0FE6:  BCF    FF2.7
0FE8:  MOVLW  FA
0FEA:  MOVWF  x6C
0FEC:  RCALL  0AC6
0FEE:  BTFSC  16.7
0FF0:  BSF    FF2.7
0FF2:  DECFSZ x62,F
0FF4:  BRA    0FE0
....................  
.................... chonpid=0; 
0FF6:  CLRF   5D
....................  
.................... dc1n(600); 
0FF8:  MOVLW  02
0FFA:  MOVWF  x63
0FFC:  MOVLW  58
0FFE:  MOVWF  x62
1000:  RCALL  0E68
.................... for ( inv3=0; inv3 < 6 ; inv3++) 
1002:  CLRF   5F
1004:  MOVF   5F,W
1006:  SUBLW  05
1008:  BNC   106E
....................    { 
....................    while (ctt2==1) { dc1n(600);} //if ( qei_get_count()>285 ) {resetdc1(); beep(10,100);} } 
100A:  BTFSS  F81.0
100C:  BRA    101A
100E:  MOVLW  02
1010:  MOVWF  x63
1012:  MOVLW  58
1014:  MOVWF  x62
1016:  RCALL  0E68
1018:  BRA    100A
....................    if (ctt2==0) {vantay2=1; resetdc1();  } 
101A:  BTFSC  F81.0
101C:  BRA    1024
101E:  BSF    F84.0
1020:  CALL   0194
1024:  CLRF   16
1026:  BTFSC  FF2.7
1028:  BSF    16.7
102A:  BCF    FF2.7
....................    delay_ms(100); 
102C:  MOVLW  64
102E:  MOVWF  x6C
1030:  RCALL  0AC6
1032:  BTFSC  16.7
1034:  BSF    FF2.7
....................    if (ctt2==1) {vantay2=0; dc1t(300); delay_ms(400); dc1n(600); } 
1036:  BTFSS  F81.0
1038:  BRA    106A
103A:  BCF    F84.0
103C:  MOVLW  01
103E:  MOVWF  x63
1040:  MOVLW  2C
1042:  MOVWF  x62
1044:  RCALL  0BDA
1046:  MOVLW  02
1048:  MOVWF  x62
104A:  CLRF   16
104C:  BTFSC  FF2.7
104E:  BSF    16.7
1050:  BCF    FF2.7
1052:  MOVLW  C8
1054:  MOVWF  x6C
1056:  RCALL  0AC6
1058:  BTFSC  16.7
105A:  BSF    FF2.7
105C:  DECFSZ x62,F
105E:  BRA    104A
1060:  MOVLW  02
1062:  MOVWF  x63
1064:  MOVLW  58
1066:  MOVWF  x62
1068:  RCALL  0E68
106A:  INCF   5F,F
106C:  BRA    1004
....................    } 
.................... vantay2=1; resetdc1(); 
106E:  BSF    F84.0
1070:  CALL   0194
....................  
.................... delay_ms(1000); 
1074:  MOVLW  04
1076:  MOVWF  x62
1078:  CLRF   16
107A:  BTFSC  FF2.7
107C:  BSF    16.7
107E:  BCF    FF2.7
1080:  MOVLW  FA
1082:  MOVWF  x6C
1084:  RCALL  0AC6
1086:  BTFSC  16.7
1088:  BSF    FF2.7
108A:  DECFSZ x62,F
108C:  BRA    1078
.................... vantay1=0; 
108E:  BCF    F80.5
.................... chonpid=2; 
1090:  MOVLW  02
1092:  MOVWF  5D
.................... setvt2=100; 
1094:  CLRF   52
1096:  MOVLW  64
1098:  MOVWF  51
.................... enable_interrupts(int_timer1); 
109A:  BSF    F9D.0
.................... while ( En2 >250) {} 
109C:  BTFSC  1E.7
109E:  BRA    10AC
10A0:  MOVF   1E,F
10A2:  BNZ   10AA
10A4:  MOVF   1D,W
10A6:  SUBLW  FA
10A8:  BTFSS  FD8.0
10AA:  BRA    109C
....................  
.................... setvt2=10; 
10AC:  CLRF   52
10AE:  MOVLW  0A
10B0:  MOVWF  51
.................... setvt1=0; 
10B2:  CLRF   50
10B4:  CLRF   4F
.................... chonpid=3; 
10B6:  MOVLW  03
10B8:  MOVWF  5D
.................... while ( En2 >10) {} 
10BA:  BTFSC  1E.7
10BC:  BRA    10CA
10BE:  MOVF   1E,F
10C0:  BNZ   10C8
10C2:  MOVF   1D,W
10C4:  SUBLW  0A
10C6:  BTFSS  FD8.0
10C8:  BRA    10BA
.................... chonpid=0; 
10CA:  CLRF   5D
....................  
.................... dc2t(600); 
10CC:  MOVLW  02
10CE:  MOVWF  x63
10D0:  MOVLW  58
10D2:  MOVWF  x62
10D4:  RCALL  0C1C
.................... for (inv3=0; inv3 < 6; inv3++) 
10D6:  CLRF   5F
10D8:  MOVF   5F,W
10DA:  SUBLW  05
10DC:  BNC   1142
....................    { 
....................    while (ctt1==1) { dc2t(600);} //if ( En2 <-5 ) {resetdc2(); beep(10,100);} } 
10DE:  BTFSS  F81.2
10E0:  BRA    10EE
10E2:  MOVLW  02
10E4:  MOVWF  x63
10E6:  MOVLW  58
10E8:  MOVWF  x62
10EA:  RCALL  0C1C
10EC:  BRA    10DE
....................    if (ctt1==0) {vantay1=1;resetdc2();  } 
10EE:  BTFSC  F81.2
10F0:  BRA    10F8
10F2:  BSF    F80.5
10F4:  CALL   01B2
10F8:  CLRF   16
10FA:  BTFSC  FF2.7
10FC:  BSF    16.7
10FE:  BCF    FF2.7
....................    delay_ms(100); 
1100:  MOVLW  64
1102:  MOVWF  x6C
1104:  RCALL  0AC6
1106:  BTFSC  16.7
1108:  BSF    FF2.7
....................    if (ctt1==1) {vantay1=0; dc2n(300); delay_ms(400); dc2t(600); } 
110A:  BTFSS  F81.2
110C:  BRA    113E
110E:  BCF    F80.5
1110:  MOVLW  01
1112:  MOVWF  x63
1114:  MOVLW  2C
1116:  MOVWF  x62
1118:  BRA    0EAA
111A:  MOVLW  02
111C:  MOVWF  x62
111E:  CLRF   16
1120:  BTFSC  FF2.7
1122:  BSF    16.7
1124:  BCF    FF2.7
1126:  MOVLW  C8
1128:  MOVWF  x6C
112A:  RCALL  0AC6
112C:  BTFSC  16.7
112E:  BSF    FF2.7
1130:  DECFSZ x62,F
1132:  BRA    111E
1134:  MOVLW  02
1136:  MOVWF  x63
1138:  MOVLW  58
113A:  MOVWF  x62
113C:  RCALL  0C1C
113E:  INCF   5F,F
1140:  BRA    10D8
....................    } 
.................... vantay1=1;resetdc2();  
1142:  BSF    F80.5
1144:  CALL   01B2
.................... delay_ms(800); 
1148:  MOVLW  04
114A:  MOVWF  x62
114C:  CLRF   16
114E:  BTFSC  FF2.7
1150:  BSF    16.7
1152:  BCF    FF2.7
1154:  MOVLW  C8
1156:  MOVWF  x6C
1158:  RCALL  0AC6
115A:  BTFSC  16.7
115C:  BSF    FF2.7
115E:  DECFSZ x62,F
1160:  BRA    114C
.................... vantay2=0; 
1162:  BCF    F84.0
1164:  CLRF   16
1166:  BTFSC  FF2.7
1168:  BSF    16.7
116A:  BCF    FF2.7
.................... delay_ms(200); 
116C:  MOVLW  C8
116E:  MOVWF  x6C
1170:  RCALL  0AC6
1172:  BTFSC  16.7
1174:  BSF    FF2.7
.................... chonpid=1; 
1176:  MOVLW  01
1178:  MOVWF  5D
.................... setvt1=200; 
117A:  CLRF   50
117C:  MOVLW  C8
117E:  MOVWF  4F
.................... enable_interrupts(int_timer1); 
1180:  BSF    F9D.0
.................... while (qei_get_count() < 30) {} 
1182:  MOVFF  F67,01
1186:  MOVFF  F66,00
118A:  MOVFF  F67,03
118E:  MOVF   03,W
1190:  SUBWF  01,W
1192:  BZ    1198
1194:  MOVFF  F66,00
1198:  MOVF   00,W
119A:  MOVWF  x62
119C:  MOVFF  03,63
11A0:  MOVF   x63,F
11A2:  BNZ   11AC
11A4:  MOVF   x62,W
11A6:  SUBLW  1D
11A8:  BNC   11AC
11AA:  BRA    1182
....................  
.................... setvt1=270; 
11AC:  MOVLW  01
11AE:  MOVWF  50
11B0:  MOVLW  0E
11B2:  MOVWF  4F
.................... setvt2=275; 
11B4:  MOVLW  01
11B6:  MOVWF  52
11B8:  MOVLW  13
11BA:  MOVWF  51
.................... chonpid=3; 
11BC:  MOVLW  03
11BE:  MOVWF  5D
.................... while (qei_get_count() < 270) {} 
11C0:  MOVFF  F67,01
11C4:  MOVFF  F66,00
11C8:  MOVFF  F67,03
11CC:  MOVF   03,W
11CE:  SUBWF  01,W
11D0:  BZ    11D6
11D2:  MOVFF  F66,00
11D6:  MOVF   00,W
11D8:  MOVWF  x62
11DA:  MOVFF  03,63
11DE:  MOVF   x63,W
11E0:  SUBLW  01
11E2:  BNC   11EE
11E4:  BNZ   11EC
11E6:  MOVF   x62,W
11E8:  SUBLW  0D
11EA:  BNC   11EE
11EC:  BRA    11C0
.................... chonpid=0; 
11EE:  CLRF   5D
.................... dc1n(600); 
11F0:  MOVLW  02
11F2:  MOVWF  x63
11F4:  MOVLW  58
11F6:  MOVWF  x62
11F8:  RCALL  0E68
.................... for ( inv3=0; inv3 < 6 ; inv3++) 
11FA:  CLRF   5F
11FC:  MOVF   5F,W
11FE:  SUBLW  05
1200:  BNC   126A
.................... { 
.................... while (ctt2==1) {dc1n(600);} // if ( qei_get_count() >285 ) {resetdc1(); beep(10,100);} } 
1202:  BTFSS  F81.0
1204:  BRA    1212
1206:  MOVLW  02
1208:  MOVWF  x63
120A:  MOVLW  58
120C:  MOVWF  x62
120E:  RCALL  0E68
1210:  BRA    1202
.................... if (ctt2==0) {vantay2=1; resetdc1();  } 
1212:  BTFSC  F81.0
1214:  BRA    121C
1216:  BSF    F84.0
1218:  CALL   0194
121C:  CLRF   16
121E:  BTFSC  FF2.7
1220:  BSF    16.7
1222:  BCF    FF2.7
.................... delay_ms(100); 
1224:  MOVLW  64
1226:  MOVWF  x6C
1228:  RCALL  0AC6
122A:  BTFSC  16.7
122C:  BSF    FF2.7
.................... if (ctt2==1) {vantay2=0; dc1t(300); delay_ms(400); resetdc1(); dc1n(600); } 
122E:  BTFSS  F81.0
1230:  BRA    1266
1232:  BCF    F84.0
1234:  MOVLW  01
1236:  MOVWF  x63
1238:  MOVLW  2C
123A:  MOVWF  x62
123C:  RCALL  0BDA
123E:  MOVLW  02
1240:  MOVWF  x62
1242:  CLRF   16
1244:  BTFSC  FF2.7
1246:  BSF    16.7
1248:  BCF    FF2.7
124A:  MOVLW  C8
124C:  MOVWF  x6C
124E:  RCALL  0AC6
1250:  BTFSC  16.7
1252:  BSF    FF2.7
1254:  DECFSZ x62,F
1256:  BRA    1242
1258:  CALL   0194
125C:  MOVLW  02
125E:  MOVWF  x63
1260:  MOVLW  58
1262:  MOVWF  x62
1264:  RCALL  0E68
1266:  INCF   5F,F
1268:  BRA    11FC
.................... } 
.................... vantay2=1; resetdc1(); 
126A:  BSF    F84.0
126C:  CALL   0194
....................  
.................... delay_ms(1000); 
1270:  MOVLW  04
1272:  MOVWF  x62
1274:  CLRF   16
1276:  BTFSC  FF2.7
1278:  BSF    16.7
127A:  BCF    FF2.7
127C:  MOVLW  FA
127E:  MOVWF  x6C
1280:  RCALL  0AC6
1282:  BTFSC  16.7
1284:  BSF    FF2.7
1286:  DECFSZ x62,F
1288:  BRA    1274
.................... vantay1=0; 
128A:  BCF    F80.5
.................... chonpid=2; 
128C:  MOVLW  02
128E:  MOVWF  5D
.................... setvt2=0; 
1290:  CLRF   52
1292:  CLRF   51
.................... enable_interrupts(int_timer1); 
1294:  BSF    F9D.0
....................  
.................... vancanh2=1; 
1296:  BSF    F80.0
.................... while ( En2 > 240) {} 
1298:  BTFSC  1E.7
129A:  BRA    12A8
129C:  MOVF   1E,F
129E:  BNZ   12A6
12A0:  MOVF   1D,W
12A2:  SUBLW  F0
12A4:  BTFSS  FD8.0
12A6:  BRA    1298
.................... chonpid=0; 
12A8:  CLRF   5D
.................... vancanh2=0; 
12AA:  BCF    F80.0
....................  
.................... while (cten==1) {} 
12AC:  BTFSC  F81.6
12AE:  BRA    12AC
....................  
.................... while (ctsel==1) {} 
12B0:  BTFSC  F81.7
12B2:  BRA    12B0
....................  
.................... vantay2=0; 
12B4:  BCF    F84.0
.................... delay_ms(1000); 
12B6:  MOVLW  04
12B8:  MOVWF  x62
12BA:  CLRF   16
12BC:  BTFSC  FF2.7
12BE:  BSF    16.7
12C0:  BCF    FF2.7
12C2:  MOVLW  FA
12C4:  MOVWF  x6C
12C6:  CALL   0AC6
12CA:  BTFSC  16.7
12CC:  BSF    FF2.7
12CE:  DECFSZ x62,F
12D0:  BRA    12BA
....................  
.................... while (ctsel==1) {} 
12D2:  BTFSC  F81.7
12D4:  BRA    12D2
....................  
....................  resetvan();  
12D6:  RCALL  0C5E
....................   
.................... demct=200; 
12D8:  MOVLW  C8
12DA:  MOVWF  57
.................... enable_interrupts(int_timer5); 
12DC:  BSF    FA3.0
12DE:  GOTO   15B2 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <nhiemvu3x.c> 
....................  
.................... ///// NHIEM VU 3X 
....................  
.................... int8 inv3x=0; 
.................... void nhiemvu3x() 
.................... { 
.................... delay_ms(1000); 
.................... beep(3,100); 
.................... setup_timer_2(T2_DIV_BY_4,250,1);      //401 us overflow, 401 us interrupt 
.................... setup_ccp1 (ccp_pwm); 
.................... setup_ccp2 (ccp_pwm); 
....................  
.................... vantay1=vantay2=vancanh1=vancanh2=vanduoi=1; 
.................... vancanh2=0; 
.................... vancanh1=0; 
....................  
.................... chonpid=2; 
.................... setvt2=235; 
.................... enable_interrupts(int_timer1); 
.................... while (En2<235) {} 
....................  
.................... chonpid=1; 
.................... setvt1=280; 
.................... while (qei_get_count() <280) {} 
....................  
.................... vantay1=vantay2=0; 
....................  
.................... while (ctsel==1) {} 
....................  
.................... vantay2=1; beep(1,100);  
....................  
.................... while (cten==1) {} 
.................... /* 
.................... chonpid=2;  
.................... setvt2=300; 
.................... while (En2 <260) {}; 
.................... */ 
.................... chonpid=0; 
.................... dc2n(600); 
.................... for ( inv3x=0; inv3x < 6 ; inv3x++) 
.................... { 
.................... while (ctt1==1) {dc2n(600);} ///*if ( En2>285 ) {resetdc2(); beep(10,100);}*/} 
.................... if (ctt1==0) {vantay1=1; resetdc2(); } 
.................... delay_ms(100); 
.................... if (ctt1==1) {vantay1=0; dc2t(300); delay_ms(400);resetdc2(); dc2n(600); } 
.................... } 
.................... vantay1=1; resetdc2(); 
....................  
.................... delay_ms(1000); 
.................... vantay2=0; 
.................... chonpid=1; 
.................... setvt1=0; 
.................... enable_interrupts(int_timer1); 
.................... while ( qei_get_count() >220) {} 
....................  
.................... setvt1=10; 
.................... setvt2=0; 
.................... chonpid=3; 
.................... while ( qei_get_count() >10) {} 
.................... chonpid=0; 
.................... delay_ms(100); 
.................... dc1t(500); 
.................... for (inv3x=0; inv3x <6; inv3x++) 
....................    { 
....................    while (ctt2==1) {dc1t(500);} ///* if ( qei_get_count() <-5 ) {resetdc1(); beep(10,100);} */} 
....................    if (ctt2==0) {vantay2=1;resetdc1(); } 
....................    delay_ms(100); 
....................    if (ctt2==1) {vantay2=0; dc1n(300); delay_ms(400);resetdc1(); dc1t(600); } 
....................    } 
.................... vantay2=1;resetdc1();  
....................  
....................  
.................... delay_ms(1000); 
.................... vantay1=0; 
.................... chonpid=2; 
.................... setvt2=120; 
.................... enable_interrupts(int_timer1); 
.................... while (En2 < 50) {} 
....................  
.................... setvt1=280; 
.................... setvt2=270; 
.................... chonpid=3; 
.................... while (En2<270) {} 
.................... chonpid=0; 
....................  
.................... dc2n(600); 
.................... for ( inv3x=0; inv3x < 6 ; inv3x++) 
.................... { 
.................... while (ctt1==1) {dc2n(600);} ///*if ( En2>285 ) {resetdc2(); beep(10,100);}*/ } 
.................... if (ctt1==0) {vantay1=1; resetdc2(); } 
.................... delay_ms(100); 
.................... if (ctt1==1) {vantay1=0; dc2t(300); delay_ms(400);resetdc2(); dc2n(600); } 
.................... } 
.................... vantay1=1; resetdc2(); 
....................  
....................  
.................... delay_ms(1000); 
.................... vantay2=0; 
.................... chonpid=1; 
.................... setvt1=0; 
.................... enable_interrupts(int_timer1); 
....................  
.................... vancanh1=1; 
.................... while ( qei_get_count() > 240) {} 
.................... chonpid=0; 
.................... vancanh1=0; 
.................... while (cten==1) {} 
....................  
.................... while (ctsel==1) {} 
....................  
.................... vantay1=0; delay_ms(500);  
....................  
.................... while (ctsel==1) {} 
....................  
.................... resetvan(); 
....................  
.................... demct=200; 
.................... enable_interrupts(int_timer5); 
....................  
.................... } 
....................  
.................... #include <nhiemvu4.c> 
....................  
.................... ///// NHIEM VU 4 
....................  
.................... void nhiemvu4() 
.................... { 
....................  
.................... int8 inv4; 
.................... delay_ms(1000); 
12E2:  MOVLW  04
12E4:  MOVWF  x63
12E6:  CLRF   16
12E8:  BTFSC  FF2.7
12EA:  BSF    16.7
12EC:  BCF    FF2.7
12EE:  MOVLW  FA
12F0:  MOVWF  x6C
12F2:  CALL   0AC6
12F6:  BTFSC  16.7
12F8:  BSF    FF2.7
12FA:  DECFSZ x63,F
12FC:  BRA    12E6
12FE:  CLRF   16
1300:  BTFSC  FF2.7
1302:  BSF    16.7
1304:  BCF    FF2.7
.................... beep(4,100); 
1306:  MOVLW  04
1308:  MOVWF  x68
130A:  MOVLW  64
130C:  MOVWF  x69
130E:  CALL   0AEC
1312:  BTFSC  16.7
1314:  BSF    FF2.7
....................  
.................... trispwm3=trisdir3=0; 
1316:  BCF    F95.5
1318:  BCF    F95.6
.................... pwm3=dir3=1; 
131A:  BSF    F83.5
131C:  BSF    F83.6
.................... while (cten==1) {} 
131E:  BTFSC  F81.6
1320:  BRA    131E
1322:  CLRF   16
1324:  BTFSC  FF2.7
1326:  BSF    16.7
1328:  BCF    FF2.7
.................... delay_ms(100); 
132A:  MOVLW  64
132C:  MOVWF  x6C
132E:  CALL   0AC6
1332:  BTFSC  16.7
1334:  BSF    FF2.7
....................  
.................... dclep=1; 
1336:  BSF    5A.0
.................... enable_interrupts(int_timer0); 
1338:  BSF    FF2.5
.................... vanduoi=0;    
133A:  BCF    F80.2
.................... while (ctld==1) 
133C:  BTFSS  F81.4
133E:  BRA    1348
....................    { 
....................    dir3=0; 
1340:  BCF    F83.5
....................    xungleo=80; 
1342:  MOVLW  50
1344:  MOVWF  59
1346:  BRA    133C
....................     
....................    }  
.................... dir3=1; 
1348:  BSF    F83.5
.................... xungleo=0; 
134A:  CLRF   59
134C:  CLRF   16
134E:  BTFSC  FF2.7
1350:  BSF    16.7
1352:  BCF    FF2.7
.................... beep(1,100); 
1354:  MOVLW  01
1356:  MOVWF  x68
1358:  MOVLW  64
135A:  MOVWF  x69
135C:  CALL   0AEC
1360:  BTFSC  16.7
1362:  BSF    FF2.7
....................  
.................... for (inv4=0; inv4 < 3; inv4++)    /// 4 lan la ok 
1364:  CLRF   x62
1366:  MOVF   x62,W
1368:  SUBLW  02
136A:  BNC   13C0
....................  { 
....................    while (ctlt==1) 
136C:  BTFSS  F81.5
136E:  BRA    1378
....................       { 
....................       dir3=1; 
1370:  BSF    F83.5
....................       xungleo=80; 
1372:  MOVLW  50
1374:  MOVWF  59
1376:  BRA    136C
....................       } 
....................    dir3=0;    
1378:  BCF    F83.5
....................    xungleo=0; 
137A:  CLRF   59
137C:  CLRF   16
137E:  BTFSC  FF2.7
1380:  BSF    16.7
1382:  BCF    FF2.7
....................    beep(1,100); 
1384:  MOVLW  01
1386:  MOVWF  x68
1388:  MOVLW  64
138A:  MOVWF  x69
138C:  CALL   0AEC
1390:  BTFSC  16.7
1392:  BSF    FF2.7
....................  
....................    while (ctld==1) 
1394:  BTFSS  F81.4
1396:  BRA    13A0
....................       { 
....................       dir3=0; 
1398:  BCF    F83.5
....................       xungleo=85; 
139A:  MOVLW  55
139C:  MOVWF  59
139E:  BRA    1394
....................       } 
....................    dir3=1;    
13A0:  BSF    F83.5
....................    xungleo=0; 
13A2:  CLRF   59
13A4:  CLRF   16
13A6:  BTFSC  FF2.7
13A8:  BSF    16.7
13AA:  BCF    FF2.7
....................    beep(1,100); 
13AC:  MOVLW  01
13AE:  MOVWF  x68
13B0:  MOVLW  64
13B2:  MOVWF  x69
13B4:  CALL   0AEC
13B8:  BTFSC  16.7
13BA:  BSF    FF2.7
13BC:  INCF   x62,F
13BE:  BRA    1366
....................  } 
....................   
....................  //delay_ms(1000); 
....................  /////////////////////delay nga robot 
....................  while (ctlt==1) 
13C0:  BTFSS  F81.5
13C2:  BRA    13CC
....................       { 
....................       dir3=1; 
13C4:  BSF    F83.5
....................       xungleo=80; 
13C6:  MOVLW  50
13C8:  MOVWF  59
13CA:  BRA    13C0
....................       } 
....................    dir3=0;    
13CC:  BCF    F83.5
....................    xungleo=0; 
13CE:  CLRF   59
13D0:  CLRF   16
13D2:  BTFSC  FF2.7
13D4:  BSF    16.7
13D6:  BCF    FF2.7
....................    beep(1,100); 
13D8:  MOVLW  01
13DA:  MOVWF  x68
13DC:  MOVLW  64
13DE:  MOVWF  x69
13E0:  CALL   0AEC
13E4:  BTFSC  16.7
13E6:  BSF    FF2.7
....................  
....................    while (ctld==1) 
13E8:  BTFSS  F81.4
13EA:  BRA    13F4
....................       { 
....................       dir3=0; 
13EC:  BCF    F83.5
....................       xungleo=85; 
13EE:  MOVLW  55
13F0:  MOVWF  59
13F2:  BRA    13E8
....................       } 
....................    dir3=1;    
13F4:  BSF    F83.5
....................    xungleo=0; 
13F6:  CLRF   59
13F8:  CLRF   16
13FA:  BTFSC  FF2.7
13FC:  BSF    16.7
13FE:  BCF    FF2.7
....................    beep(1,100); 
1400:  MOVLW  01
1402:  MOVWF  x68
1404:  MOVLW  64
1406:  MOVWF  x69
1408:  CALL   0AEC
140C:  BTFSC  16.7
140E:  BSF    FF2.7
....................   
....................   
....................  
.................... while (ctlt==1) 
1410:  BTFSS  F81.5
1412:  BRA    141C
....................       { 
....................       dir3=1; 
1414:  BSF    F83.5
....................       xungleo=80; 
1416:  MOVLW  50
1418:  MOVWF  59
141A:  BRA    1410
....................       } 
....................    dir3=0;    
141C:  BCF    F83.5
....................    xungleo=0; 
141E:  CLRF   59
1420:  CLRF   16
1422:  BTFSC  FF2.7
1424:  BSF    16.7
1426:  BCF    FF2.7
....................    beep(1,100); 
1428:  MOVLW  01
142A:  MOVWF  x68
142C:  MOVLW  64
142E:  MOVWF  x69
1430:  CALL   0AEC
1434:  BTFSC  16.7
1436:  BSF    FF2.7
....................     
.................... while (ctlt==0) 
1438:  BTFSC  F81.5
143A:  BRA    1444
....................    { 
....................    dir3=0;  
143C:  BCF    F83.5
....................    xungleo=60; 
143E:  MOVLW  3C
1440:  MOVWF  59
1442:  BRA    1438
....................    } 
....................    xungleo=0; 
1444:  CLRF   59
1446:  CLRF   16
1448:  BTFSC  FF2.7
144A:  BSF    16.7
144C:  BCF    FF2.7
....................    beep(1,100); 
144E:  MOVLW  01
1450:  MOVWF  x68
1452:  MOVLW  64
1454:  MOVWF  x69
1456:  CALL   0AEC
145A:  BTFSC  16.7
145C:  BSF    FF2.7
....................   
.................... vanduoi=1; 
145E:  BSF    F80.2
.................... pwm3=1; 
1460:  BSF    F83.6
.................... dir3=1; 
1462:  BSF    F83.5
.................... dclep=0; 
1464:  BCF    5A.0
.................... xungleo=10; 
1466:  MOVLW  0A
1468:  MOVWF  59
.................... while (cten==1) { } 
146A:  BTFSC  F81.6
146C:  BRA    146A
.................... disable_interrupts(int_timer0); 
146E:  BCF    FF2.5
....................  
.................... demct=200; 
1470:  MOVLW  C8
1472:  MOVWF  57
.................... enable_interrupts(int_timer5); 
1474:  BSF    FA3.0
1476:  GOTO   15D8 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... ///// MAIN ///// 
.................... int8 i=0; 
....................  
.................... void main() 
147A:  CLRF   FF8
147C:  BCF    FD0.7
147E:  BSF    07.7
1480:  CLRF   22
1482:  CLRF   21
1484:  CLRF   20
1486:  MOVLW  80
1488:  MOVWF  1F
148A:  MOVLW  CD
148C:  MOVWF  26
148E:  MOVLW  CC
1490:  MOVWF  25
1492:  MOVLW  4C
1494:  MOVWF  24
1496:  MOVLW  7C
1498:  MOVWF  23
149A:  MOVLW  33
149C:  MOVWF  2A
149E:  MOVWF  29
14A0:  MOVWF  28
14A2:  MOVLW  7E
14A4:  MOVWF  27
14A6:  CLRF   36
14A8:  CLRF   35
14AA:  CLRF   38
14AC:  CLRF   37
14AE:  CLRF   3A
14B0:  CLRF   39
14B2:  CLRF   3C
14B4:  CLRF   3B
14B6:  CLRF   42
14B8:  CLRF   41
14BA:  CLRF   44
14BC:  CLRF   43
14BE:  CLRF   46
14C0:  CLRF   45
14C2:  CLRF   48
14C4:  CLRF   47
14C6:  MOVLW  03
14C8:  MOVWF  54
14CA:  MOVLW  84
14CC:  MOVWF  53
14CE:  MOVLW  03
14D0:  MOVWF  56
14D2:  MOVLW  84
14D4:  MOVWF  55
14D6:  CLRF   57
14D8:  CLRF   58
14DA:  MOVLW  64
14DC:  MOVWF  59
14DE:  BCF    5A.0
14E0:  CLRF   5C
14E2:  CLRF   5B
14E4:  MOVLW  04
14E6:  MOVWF  5D
14E8:  CLRF   5E
14EA:  CLRF   5F
14EC:  CLRF   x60
14EE:  CLRF   x61
14F0:  BCF    FB9.0
14F2:  BCF    FC1.6
14F4:  BCF    FC1.7
14F6:  MOVLW  00
14F8:  MOVWF  FB8
14FA:  CLRF   17
14FC:  CLRF   18
.................... { 
....................     
....................    khoidong();  
14FE:  GOTO   0B6A
....................     
....................    En2=0; 
1502:  CLRF   1E
1504:  CLRF   1D
....................    Ti1=0; 
1506:  CLRF   4C
1508:  CLRF   4B
....................    Ti2=0; 
150A:  CLRF   4E
150C:  CLRF   4D
....................    setvt1=0; 
150E:  CLRF   50
1510:  CLRF   4F
....................    setvt2=0; 
1512:  CLRF   52
1514:  CLRF   51
1516:  CLRF   16
1518:  BTFSC  FF2.7
151A:  BSF    16.7
151C:  BCF    FF2.7
....................    beep(2,100);  
151E:  MOVLW  02
1520:  MOVWF  x68
1522:  MOVLW  64
1524:  MOVWF  x69
1526:  CALL   0AEC
152A:  BTFSC  16.7
152C:  BSF    FF2.7
....................    //ss1=1; 
.................... while(true) 
....................    { 
....................     
....................    if (ctsel==0)  
152E:  BTFSC  F81.7
1530:  BRA    1552
....................       { 
....................       enable_interrupts(int_timer5); 
1532:  BSF    FA3.0
....................       demct=0; i=1; delay_ms(10);  
1534:  CLRF   57
1536:  MOVLW  01
1538:  MOVWF  x61
153A:  CLRF   16
153C:  BTFSC  FF2.7
153E:  BSF    16.7
1540:  BCF    FF2.7
1542:  MOVLW  0A
1544:  MOVWF  x6C
1546:  CALL   0AC6
154A:  BTFSC  16.7
154C:  BSF    FF2.7
....................       while (ctsel==0) {} 
154E:  BTFSS  F81.7
1550:  BRA    154E
....................       } 
....................        
....................    while (i==1)  
1552:  DECFSZ x61,W
1554:  BRA    15DA
....................       { 
....................       if ( demct<50 )  
1556:  MOVF   57,W
1558:  SUBLW  31
155A:  BNC   1566
....................          { 
....................          disable_interrupts(int_timer5); 
155C:  BCF    FA3.0
....................          //ss1=0; spi_write(demct); ss1=1; delay_ms(5); ss1=0; spi_write(demct); ss1=1; 
....................          i=0; demct=0;  resetvan(); 
155E:  CLRF   x61
1560:  CLRF   57
1562:  CALL   0C5E
....................          } 
....................       if ((50<demct)&(demct<100))  
1566:  MOVF   57,W
1568:  SUBLW  32
156A:  BNC   1570
156C:  MOVLW  00
156E:  BRA    1572
1570:  MOVLW  01
1572:  MOVWF  x62
1574:  MOVF   57,W
1576:  SUBLW  63
1578:  BC    157E
157A:  MOVLW  00
157C:  BRA    1580
157E:  MOVLW  01
1580:  ANDWF  x62,W
1582:  BZ    158C
....................          { 
....................          disable_interrupts(int_timer5);  
1584:  BCF    FA3.0
....................          //ss1=0; spi_write(demct); ss1=1; delay_ms(5); ss1=0; spi_write(demct); ss1=1; 
....................          i=0; demct=0; nhiemvu2();  
1586:  CLRF   x61
1588:  CLRF   57
158A:  BRA    0DD4
....................          } 
....................       if ((100<demct)&(demct<150))  
158C:  MOVF   57,W
158E:  SUBLW  64
1590:  BNC   1596
1592:  MOVLW  00
1594:  BRA    1598
1596:  MOVLW  01
1598:  MOVWF  x62
159A:  MOVF   57,W
159C:  SUBLW  95
159E:  BC    15A4
15A0:  MOVLW  00
15A2:  BRA    15A6
15A4:  MOVLW  01
15A6:  ANDWF  x62,W
15A8:  BZ    15B2
....................          { 
....................          disable_interrupts(int_timer5);  
15AA:  BCF    FA3.0
....................          //ss1=0; spi_write(demct); ss1=1; delay_ms(5); ss1=0; spi_write(demct); ss1=1; 
....................          i=0; demct=0; nhiemvu3(); 
15AC:  CLRF   x61
15AE:  CLRF   57
15B0:  BRA    0EEE
....................          } 
....................       if ((150<demct)&(demct<200))  
15B2:  MOVF   57,W
15B4:  SUBLW  96
15B6:  BNC   15BC
15B8:  MOVLW  00
15BA:  BRA    15BE
15BC:  MOVLW  01
15BE:  MOVWF  x62
15C0:  MOVF   57,W
15C2:  SUBLW  C7
15C4:  BC    15CA
15C6:  MOVLW  00
15C8:  BRA    15CC
15CA:  MOVLW  01
15CC:  ANDWF  x62,W
15CE:  BZ    15D8
....................          { 
....................          disable_interrupts(int_timer5);  
15D0:  BCF    FA3.0
....................          //ss1=0; spi_write(demct); ss1=1; delay_ms(5); ss1=0; spi_write(demct); ss1=1; 
....................          i=0; demct=0; nhiemvu4();  
15D2:  CLRF   x61
15D4:  CLRF   57
15D6:  BRA    12E2
....................          } 
15D8:  BRA    1552
....................        
....................       } 
15DA:  BRA    152E
....................      
....................    } 
....................     
.................... } 
15DC:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 3E0C   PUT NOBROWNOUT BORV20 NOWDT WDT32768 NOWINEN
   Word  3: 9D3C   NOPWMPIN LPOL_HIGH HPOL_HIGH T1LOWPOWER FLTAC1 SSP_RC PWM4B5 EXCLKC3 MCLR
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
