CCS PCH C Compiler, Version 4.114, 93460303               04-Mar-14 21:27

               Filename: F:\Robocon 2014\Lap trinh design\LAP TRINH ROBOT TU DONG\tudong3-3-2014\main.lst

               ROM used: 1338 bytes (8%)
                         Largest free fragment is 15042
               RAM used: 34 (4%) at main() level
                         53 (7%) worst case
               Stack:    7 worst case (6 in main + 1 for interrupts)

*
0000:  GOTO   04CC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF0.3
0056:  GOTO   0060
005A:  BTFSC  FF0.0
005C:  GOTO   00CE
0060:  BTFSS  FF0.4
0062:  GOTO   006C
0066:  BTFSC  FF0.1
0068:  GOTO   010E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <18F4431.h> 
.................... //////// Standard Header file for the PIC18F4431 device //////////////// 
.................... #device PIC18F4431 
.................... #list 
....................  
.................... #include <PIC18F4431_registers.h> 
.................... #byte TOSU = 0xFFF 
.................... #word TOS = 0xFFE 
.................... #byte STKPTR = 0xFFC 
.................... #bit    STKPTR0 = STKPTR.0 
.................... #bit    STKPTR1 = STKPTR.1 
.................... #bit    STKPTR2 = STKPTR.2 
.................... #bit    STKPTR3 = STKPTR.3 
.................... #bit    STKPTR4 = STKPTR.4 
.................... #bit    STKUNF = STKPTR.6 
.................... #bit    STKFUL = STKPTR.7 
.................... #byte PCLATU = 0xFFB 
.................... #byte PCLATH = 0xFFA 
.................... #byte PCL = 0xFF9 
.................... #byte TBLPTRU = 0xFF8 
.................... #bit    TBLPTRU0 = TBLPTRU.0 
.................... #bit    TBLPTRU1 = TBLPTRU.1 
.................... #bit    TBLPTRU2 = TBLPTRU.2 
.................... #bit    TBLPTRU3 = TBLPTRU.3 
.................... #bit    TBLPTRU4 = TBLPTRU.4 
.................... #bit    ACSS = TBLPTRU.5 
.................... #word TBLPTR = 0xFF7 
.................... #byte TABLAT = 0xFF5 
.................... #word PROD = 0xFF4 
.................... #byte INTCON = 0xFF2 
.................... #bit    RBIF = INTCON.0 
.................... #bit    INT0IF = INTCON.1 
.................... #bit    TMR0IF = INTCON.2 
.................... #bit    RBIE = INTCON.3 
.................... #bit    INT0IE = INTCON.4 
.................... #bit    TMR0IE = INTCON.5 
.................... #bit    PEIE_GIEL = INTCON.6 
.................... #bit    GIE_GIEH = INTCON.7 
.................... #byte INTCON2 = 0xFF1 
.................... #bit    RBIP = INTCON2.0 
.................... #bit    TMR0IP = INTCON2.2 
.................... #bit    INTEDG2 = INTCON2.4 
.................... #bit    INTEDG1 = INTCON2.5 
.................... #bit    INTEDG0 = INTCON2.6 
.................... #bit    RBPU = INTCON2.7 
.................... #byte INTCON3 = 0xFF0 
.................... #bit    INT1IF = INTCON3.0 
.................... #bit    INT2IF = INTCON3.1 
.................... #bit    INT1IE = INTCON3.3 
.................... #bit    INT2IE = INTCON3.4 
.................... #bit    INT1IP = INTCON3.6 
.................... #bit    INT2IP = INTCON3.7 
.................... #byte INDF0 = 0xFEF 
.................... #byte POSTINC0 = 0xFEE 
.................... #byte POSTDEC0 = 0xFED 
.................... #byte PREINC0 = 0xFEC 
.................... #byte PLUSW0 = 0xFEB 
.................... #word FSR0 = 0xFEA 
.................... #byte WREG = 0xFE8 
.................... #byte INDF1 = 0xFE7 
.................... #byte POSTINC1 = 0xFE6 
.................... #byte POSTDEC1 = 0xFE5 
.................... #byte PREINC1 = 0xFE4 
.................... #byte PLUSW1 = 0xFE3 
.................... #word FSR1 = 0xFE2 
.................... #byte BSR = 0xFE0 
.................... #byte INDF2 = 0xFDF 
.................... #byte POSTINC2 = 0xFDE 
.................... #byte POSTDEC2 = 0xFDD 
.................... #byte PREINC2 = 0xFDC 
.................... #byte PLUSW2 = 0xFDB 
.................... #word FSR2 = 0xFDA 
.................... #byte STATUS = 0xFD8 
.................... #bit    DC = STATUS.1 
.................... #bit    OV = STATUS.3 
.................... #word TMR0 = 0xFD7 
.................... #byte T0CON = 0xFD5 
.................... #bit    T0PS0 = T0CON.0 
.................... #bit    T0PS1 = T0CON.1 
.................... #bit    T0PS2 = T0CON.2 
.................... #bit    PSA = T0CON.3 
.................... #bit    T0SE = T0CON.4 
.................... #bit    T0CS = T0CON.5 
.................... #bit    T016BIT = T0CON.6 
.................... #bit    TMR0ON = T0CON.7 
.................... #byte OSCCON = 0xFD3 
.................... #bit    SCS0 = OSCCON.0 
.................... #bit    SCS1 = OSCCON.1 
.................... #bit    IOFS = OSCCON.2 
.................... #bit    OSTS = OSCCON.3 
.................... #bit    IRCF0 = OSCCON.4 
.................... #bit    IRCF1 = OSCCON.5 
.................... #bit    IRCF2 = OSCCON.6 
.................... #bit    IDLEN = OSCCON.7 
.................... #byte LVDCON = 0xFD2 
.................... #bit    LVDL0 = LVDCON.0 
.................... #bit    LVDL1 = LVDCON.1 
.................... #bit    LVDL2 = LVDCON.2 
.................... #bit    LVDL3 = LVDCON.3 
.................... #bit    LVDEN = LVDCON.4 
.................... #bit    IRVST = LVDCON.5 
.................... #byte WDTCON = 0xFD1 
.................... #bit    SWDTEN = WDTCON.0 
.................... #bit    WDTW = WDTCON.7 
.................... #byte RCON = 0xFD0 
.................... #bit    BOR = RCON.0 
.................... #bit    POR = RCON.1 
.................... #bit    PD = RCON.2 
.................... #bit    TO = RCON.3 
.................... #bit    RI = RCON.4 
.................... #bit    IPEN = RCON.7 
.................... #word TMR1 = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... #bit    TMR1ON = T1CON.0 
.................... #bit    TMR1CS = T1CON.1 
.................... #bit    T1SYNC = T1CON.2 
.................... #bit    T1OSCEN = T1CON.3 
.................... #bit    T1CKPS0 = T1CON.4 
.................... #bit    T1CKPS1 = T1CON.5 
.................... #bit    T1RUN = T1CON.6 
.................... #bit    RD16 = T1CON.7 
.................... #byte TMR2 = 0xFCC 
.................... #byte PR2 = 0xFCB 
.................... #byte T2CON = 0xFCA 
.................... #bit    T2CKPS0 = T2CON.0 
.................... #bit    T2CKPS1 = T2CON.1 
.................... #bit    TMR2ON = T2CON.2 
.................... #bit    TOUTPS0 = T2CON.3 
.................... #bit    TOUTPS1 = T2CON.4 
.................... #bit    TOUTPS2 = T2CON.5 
.................... #bit    TOUTPS3 = T2CON.6 
.................... #byte SSPBUF = 0xFC9 
.................... #byte SSPADD = 0xFC8 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    BF = SSPSTAT.0 
.................... #bit    UA = SSPSTAT.1 
.................... #bit    CKE = SSPSTAT.6 
.................... #bit    SMP = SSPSTAT.7 
.................... #byte SSPCON = 0xFC6 
.................... #bit    SSPM0 = SSPCON.0 
.................... #bit    SSPM1 = SSPCON.1 
.................... #bit    SSPM2 = SSPCON.2 
.................... #bit    SSPM3 = SSPCON.3 
.................... #bit    CKP = SSPCON.4 
.................... #bit    SSPEN = SSPCON.5 
.................... #bit    SSPOV = SSPCON.6 
.................... #bit    WCOL = SSPCON.7 
.................... #word ADRES = 0xFC4 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    ADON = ADCON0.0 
.................... #bit    GO = ADCON0.1 
.................... #bit    ACMOD0 = ADCON0.2 
.................... #bit    ACMOD1 = ADCON0.3 
.................... #bit    ACSCH = ADCON0.4 
.................... #bit    ACONV = ADCON0.5 
.................... #byte ADCON1 = 0xFC1 
.................... #bit    ADPNT0 = ADCON1.0 
.................... #bit    ADPNT1 = ADCON1.1 
.................... #bit    BFOVFL = ADCON1.2 
.................... #bit    BFEMT = ADCON1.3 
.................... #bit    FIFOEN = ADCON1.4 
.................... #bit    VCFG0 = ADCON1.6 
.................... #bit    VCFG1 = ADCON1.7 
.................... #byte ADCON2 = 0xFC0 
.................... #bit    ADCS0 = ADCON2.0 
.................... #bit    ADCS1 = ADCON2.1 
.................... #bit    ADCS2 = ADCON2.2 
.................... #bit    ACQT0 = ADCON2.3 
.................... #bit    ACQT1 = ADCON2.4 
.................... #bit    ACQT2 = ADCON2.5 
.................... #bit    ACQT3 = ADCON2.6 
.................... #bit    ADFM = ADCON2.7 
.................... #word CCPR1 = 0xFBF 
.................... #byte CCP1CON = 0xFBD 
.................... #bit    CCP1M0 = CCP1CON.0 
.................... #bit    CCP1M1 = CCP1CON.1 
.................... #bit    CCP1M2 = CCP1CON.2 
.................... #bit    CCP1M3 = CCP1CON.3 
.................... #bit    DC1B0 = CCP1CON.4 
.................... #bit    DC1B1 = CCP1CON.5 
.................... #word CCPR2 = 0xFBC 
.................... #byte CCP2CON = 0xFBA 
.................... #bit    CCP2M0 = CCP2CON.0 
.................... #bit    CCP2M1 = CCP2CON.1 
.................... #bit    CCP2M2 = CCP2CON.2 
.................... #bit    CCP2M3 = CCP2CON.3 
.................... #bit    DC2B0 = CCP2CON.4 
.................... #bit    DC2B1 = CCP2CON.5 
.................... #byte ANSEL1 = 0xFB9 
.................... #bit    ANS8 = ANSEL1.0 
.................... #byte ANSEL0 = 0xFB8 
.................... #byte T5CON = 0xFB7 
.................... #bit    TMR5ON = T5CON.0 
.................... #bit    TMR5CS = T5CON.1 
.................... #bit    T5SYNC = T5CON.2 
.................... #bit    T5PS0 = T5CON.3 
.................... #bit    T5PS1 = T5CON.4 
.................... #bit    T5MOD = T5CON.5 
.................... #bit    RESEN = T5CON.6 
.................... #bit    T5SEN = T5CON.7 
.................... #byte QEICON = 0xFB6 
.................... #bit    PDEC0 = QEICON.0 
.................... #bit    PDEC1 = QEICON.1 
.................... #bit    QEIM0 = QEICON.2 
.................... #bit    QEIM1 = QEICON.3 
.................... #bit    QEIM2 = QEICON.4 
.................... #bit    UP = QEICON.5 
.................... #bit    ERROR = QEICON.6 
.................... #bit    VELM = QEICON.7 
.................... #byte SPBRGH = 0xFB0 
.................... #byte SPBRG = 0xFAF 
.................... #byte RCREG = 0xFAE 
.................... #byte TXREG = 0xFAD 
.................... #byte TXSTA = 0xFAC 
.................... #bit    TX9D = TXSTA.0 
.................... #bit    TRMT = TXSTA.1 
.................... #bit    BRGH = TXSTA.2 
.................... #bit    SENDB = TXSTA.3 
.................... #bit    SYNC = TXSTA.4 
.................... #bit    TXEN = TXSTA.5 
.................... #bit    TX9 = TXSTA.6 
.................... #bit    CSRC = TXSTA.7 
.................... #byte RCSTA = 0xFAB 
.................... #bit    RX9D = RCSTA.0 
.................... #bit    OERR = RCSTA.1 
.................... #bit    FERR = RCSTA.2 
.................... #bit    ADDEN = RCSTA.3 
.................... #bit    CREN = RCSTA.4 
.................... #bit    SREN = RCSTA.5 
.................... #bit    RX9 = RCSTA.6 
.................... #bit    SPEN = RCSTA.7 
.................... #byte BAUDCON = 0xFAA 
.................... #bit    ABDEN = BAUDCON.0 
.................... #bit    WUE = BAUDCON.1 
.................... #bit    BRG16 = BAUDCON.3 
.................... #bit    TXCKP = BAUDCON.4 
.................... #bit    RXDTP = BAUDCON.5 
.................... #bit    RCIDL = BAUDCON.6 
.................... #bit    ABDOVF = BAUDCON.7 
.................... #byte EEADR = 0xFA9 
.................... #byte EEDATA = 0xFA8 
.................... #byte EECON2 = 0xFA7 
.................... #byte EECON1 = 0xFA6 
.................... #bit    RD = EECON1.0 
.................... #bit    WR = EECON1.1 
.................... #bit    WREN = EECON1.2 
.................... #bit    WRERR = EECON1.3 
.................... #bit    FREE = EECON1.4 
.................... #bit    CFGS = EECON1.6 
.................... #bit    EEPGD = EECON1.7 
.................... #byte IPR3 = 0xFA5 
.................... #bit    TMR5IP = IPR3.0 
.................... #bit    IC1IP = IPR3.1 
.................... #bit    IC2QEIP = IPR3.2 
.................... #bit    IC3DRIP = IPR3.3 
.................... #bit    PTIP = IPR3.4 
.................... #byte PIR3 = 0xFA4 
.................... #bit    TMR5IF = PIR3.0 
.................... #bit    IC1IF = PIR3.1 
.................... #bit    IC2QEIF = PIR3.2 
.................... #bit    IC3DRIF = PIR3.3 
.................... #bit    PTIF = PIR3.4 
.................... #byte PIE3 = 0xFA3 
.................... #bit    TMR5IE = PIE3.0 
.................... #bit    IC1IE = PIE3.1 
.................... #bit    IC2QEIE = PIE3.2 
.................... #bit    IC3DRIE = PIE3.3 
.................... #bit    PTIE = PIE3.4 
.................... #byte IPR2 = 0xFA2 
.................... #bit    CCP2IP = IPR2.0 
.................... #bit    LVDIP = IPR2.2 
.................... #bit    EEIP = IPR2.4 
.................... #bit    OSFIP = IPR2.7 
.................... #byte PIR2 = 0xFA1 
.................... #bit    CCP2IF = PIR2.0 
.................... #bit    LVDIF = PIR2.2 
.................... #bit    EEIF = PIR2.4 
.................... #bit    OSFIF = PIR2.7 
.................... #byte PIE2 = 0xFA0 
.................... #bit    CCP2IE = PIE2.0 
.................... #bit    LVDIE = PIE2.2 
.................... #bit    EEIE = PIE2.4 
.................... #bit    OSFIE = PIE2.7 
.................... #byte IPR1 = 0xF9F 
.................... #bit    TMR1IP = IPR1.0 
.................... #bit    TMR2IP = IPR1.1 
.................... #bit    CCP1IP = IPR1.2 
.................... #bit    SSPIP = IPR1.3 
.................... #bit    TXIP = IPR1.4 
.................... #bit    RCIP = IPR1.5 
.................... #bit    ADIP = IPR1.6 
.................... #byte PIR1 = 0xF9E 
.................... #bit    TMR1IF = PIR1.0 
.................... #bit    TMR2IF = PIR1.1 
.................... #bit    CCP1IF = PIR1.2 
.................... #bit    SSPIF = PIR1.3 
.................... #bit    TXIF = PIR1.4 
.................... #bit    RCIF = PIR1.5 
.................... #bit    ADIF = PIR1.6 
.................... #byte PIE1 = 0xF9D 
.................... #bit    TMR1IE = PIE1.0 
.................... #bit    TMR2IE = PIE1.1 
.................... #bit    CCP1IE = PIE1.2 
.................... #bit    SSPIE = PIE1.3 
.................... #bit    TXIE = PIE1.4 
.................... #bit    RCIE = PIE1.5 
.................... #bit    ADIE = PIE1.6 
.................... #byte OSCTUNE = 0xF9B 
.................... #byte ADCON3 = 0xF9A 
.................... #bit    SSRC0 = ADCON3.0 
.................... #bit    SSRC1 = ADCON3.1 
.................... #bit    SSRC2 = ADCON3.2 
.................... #bit    SSRC3 = ADCON3.3 
.................... #bit    SSRC4 = ADCON3.4 
.................... #bit    ADRS0 = ADCON3.6 
.................... #bit    ADRS1 = ADCON3.7 
.................... #byte ADCHS = 0xF99 
.................... #bit    SASEL0 = ADCHS.0 
.................... #bit    SASEL1 = ADCHS.1 
.................... #bit    SCSEL0 = ADCHS.2 
.................... #bit    SCSEL1 = ADCHS.3 
.................... #bit    SBSEL0 = ADCHS.4 
.................... #bit    SBSEL1 = ADCHS.5 
.................... #bit    SDSEL0 = ADCHS.6 
.................... #bit    SDSEL1 = ADCHS.7 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
.................... #byte TRISA = 0xF92 
.................... #word PR5 = 0xF91 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
.................... #byte LATA = 0xF89 
.................... #word TMR5 = 0xF88 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #byte PTCON0 = 0xF7F 
.................... #bit    PTMOD0 = PTCON0.0 
.................... #bit    PTMOD1 = PTCON0.1 
.................... #bit    PTCKPS0 = PTCON0.2 
.................... #bit    PTCKPS1 = PTCON0.3 
.................... #bit    PTOPS0 = PTCON0.4 
.................... #bit    PTOPS1 = PTCON0.5 
.................... #bit    PTOPS2 = PTCON0.6 
.................... #bit    PTOPS3 = PTCON0.7 
.................... #byte PTCON1 = 0xF7E 
.................... #bit    PTDIR = PTCON1.6 
.................... #bit    PTEN = PTCON1.7 
.................... #byte PTMRL = 0xF7D 
.................... #byte PTMRH = 0xF7C 
.................... #byte PTPERL = 0xF7B 
.................... #byte PTPERH = 0xF7A 
.................... #byte PDC0L = 0xF79 
.................... #byte PDC0H = 0xF78 
.................... #byte PDC1L = 0xF77 
.................... #byte PDC1H = 0xF76 
.................... #byte PDC2L = 0xF75 
.................... #byte PDC2H = 0xF74 
.................... #byte PDC3L = 0xF73 
.................... #byte PDC3H = 0xF72 
.................... #byte SEVTCMPL = 0xF71 
.................... #byte SEVTCMPH = 0xF70 
.................... #byte PWMCON0 = 0xF6F 
.................... #bit    PMOD0 = PWMCON0.0 
.................... #bit    PMOD1 = PWMCON0.1 
.................... #bit    PMOD2 = PWMCON0.2 
.................... #bit    PMOD3 = PWMCON0.3 
.................... #bit    PWMEN0 = PWMCON0.4 
.................... #bit    PWMEN1 = PWMCON0.5 
.................... #bit    PWMEN2 = PWMCON0.6 
.................... #byte PWMCON1 = 0xF6E 
.................... #bit    OSYNC = PWMCON1.0 
.................... #bit    UDIS = PWMCON1.1 
.................... #bit    SEVTDIR = PWMCON1.3 
.................... #bit    SEVOPS0 = PWMCON1.4 
.................... #bit    SEVOPS1 = PWMCON1.5 
.................... #bit    SEVOPS2 = PWMCON1.6 
.................... #bit    SEVOPS3 = PWMCON1.7 
.................... #byte DTCON = 0xF6D 
.................... #bit    DTA0 = DTCON.0 
.................... #bit    DTA1 = DTCON.1 
.................... #bit    DTA2 = DTCON.2 
.................... #bit    DTA3 = DTCON.3 
.................... #bit    DTA4 = DTCON.4 
.................... #bit    DTA5 = DTCON.5 
.................... #bit    DTAPS0 = DTCON.6 
.................... #bit    DTAPS1 = DTCON.7 
.................... #byte FLTCONFIG = 0xF6C 
.................... #bit    FLTAEN = FLTCONFIG.0 
.................... #bit    FLTAMOD = FLTCONFIG.1 
.................... #bit    FLTAS = FLTCONFIG.2 
.................... #bit    FLTCON = FLTCONFIG.3 
.................... #bit    FLTBEN = FLTCONFIG.4 
.................... #bit    FLTBMOD = FLTCONFIG.5 
.................... #bit    FLTBS = FLTCONFIG.6 
.................... #bit    BRFEN = FLTCONFIG.7 
.................... #byte OVDCOND = 0xF6B 
.................... #byte OVDCONS = 0xF6A 
.................... #word CAP1BUF = 0xF69 
.................... #word CAP2BUF = 0xF67 
.................... #word CAP3BUF = 0xF65 
.................... #byte CAP1CON = 0xF63 
.................... #bit    CAP1M0 = CAP1CON.0 
.................... #bit    CAP1M1 = CAP1CON.1 
.................... #bit    CAP1M2 = CAP1CON.2 
.................... #bit    CAP1M3 = CAP1CON.3 
.................... #bit    CAP1TMR = CAP1CON.5 
.................... #bit    CAP1REN = CAP1CON.6 
.................... #byte CAP2CON = 0xF62 
.................... #bit    CAP2M0 = CAP2CON.0 
.................... #bit    CAP2M1 = CAP2CON.1 
.................... #bit    CAP2M2 = CAP2CON.2 
.................... #bit    CAP2M3 = CAP2CON.3 
.................... #bit    CAP2TMR = CAP2CON.5 
.................... #bit    CAP2REN = CAP2CON.6 
.................... #byte CAP3CON = 0xF61 
.................... #bit    CAP3M0 = CAP3CON.0 
.................... #bit    CAP3M1 = CAP3CON.1 
.................... #bit    CAP3M2 = CAP3CON.2 
.................... #bit    CAP3M3 = CAP3CON.3 
.................... #bit    CAP3TMR = CAP3CON.5 
.................... #bit    CAP3REN = CAP3CON.6 
.................... #byte DFLTCON = 0xF60 
.................... #bit    FLTCK0 = DFLTCON.0 
.................... #bit    FLTCK1 = DFLTCON.1 
.................... #bit    FLTCK2 = DFLTCON.2 
.................... #bit    FLT1EN = DFLTCON.3 
.................... #bit    FLT2EN = DFLTCON.4 
.................... #bit    FLT3EN = DFLTCON.5 
.................... #bit    FLT4EN = DFLTCON.6 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES HS,NOWDT,NOLVP 
.................... #use delay(clock=20000000) 
*
016E:  CLRF   FEA
0170:  MOVLW  2B
0172:  MOVWF  FE9
0174:  MOVF   FEF,W
0176:  BZ    0192
0178:  MOVLW  06
017A:  MOVWF  01
017C:  CLRF   00
017E:  DECFSZ 00,F
0180:  BRA    017E
0182:  DECFSZ 01,F
0184:  BRA    017C
0186:  MOVLW  7B
0188:  MOVWF  00
018A:  DECFSZ 00,F
018C:  BRA    018A
018E:  DECFSZ FEF,F
0190:  BRA    0178
0192:  RETLW  00
.................... #use fast_io(a) 
.................... #use fast_io(d) 
.................... #use fast_io(c) 
.................... #use fast_io(e) 
....................  
.................... #define LCD_RS_PIN      PIN_B0                                  
.................... #define LCD_RW_PIN      PIN_B1     
.................... #define LCD_ENABLE_PIN  PIN_B2                                                               
.................... #define LCD_DATA4       PIN_B4                                  
.................... #define LCD_DATA5       PIN_B5                                   
.................... #define LCD_DATA6       PIN_B6                                    
.................... #define LCD_DATA7       PIN_B7 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
022A:  BSF    F93.4
....................    output_float(LCD_DATA5); 
022C:  BSF    F93.5
....................    output_float(LCD_DATA6); 
022E:  BSF    F93.6
....................    output_float(LCD_DATA7); 
0230:  BSF    F93.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0232:  BSF    F8A.1
0234:  BCF    F93.1
....................    delay_cycles(1); 
0236:  NOP   
....................    lcd_output_enable(1); 
0238:  BSF    F8A.2
023A:  BCF    F93.2
....................    delay_cycles(1); 
023C:  NOP   
....................    high = lcd_read_nibble(); 
023E:  RCALL  01D8
0240:  MOVFF  01,32
....................        
....................    lcd_output_enable(0); 
0244:  BCF    F8A.2
0246:  BCF    F93.2
....................    delay_cycles(1); 
0248:  NOP   
....................    lcd_output_enable(1); 
024A:  BSF    F8A.2
024C:  BCF    F93.2
....................    delay_us(1); 
024E:  BRA    0250
0250:  BRA    0252
0252:  NOP   
....................    low = lcd_read_nibble(); 
0254:  RCALL  01D8
0256:  MOVFF  01,31
....................        
....................    lcd_output_enable(0); 
025A:  BCF    F8A.2
025C:  BCF    F93.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
025E:  BCF    F93.4
....................    output_drive(LCD_DATA5); 
0260:  BCF    F93.5
....................    output_drive(LCD_DATA6); 
0262:  BCF    F93.6
....................    output_drive(LCD_DATA7); 
0264:  BCF    F93.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0266:  SWAPF  32,W
0268:  MOVWF  00
026A:  MOVLW  F0
026C:  ANDWF  00,F
026E:  MOVF   00,W
0270:  IORWF  31,W
0272:  MOVWF  01
.................... } 
0274:  GOTO   0284 (RETURN)
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01D8:  CLRF   33
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01DA:  BSF    F93.4
01DC:  MOVLW  00
01DE:  BTFSC  F81.4
01E0:  MOVLW  01
01E2:  IORWF  33,F
....................    n |= input(LCD_DATA5) << 1; 
01E4:  BSF    F93.5
01E6:  MOVLW  00
01E8:  BTFSC  F81.5
01EA:  MOVLW  01
01EC:  MOVWF  00
01EE:  BCF    FD8.0
01F0:  RLCF   00,F
01F2:  MOVF   00,W
01F4:  IORWF  33,F
....................    n |= input(LCD_DATA6) << 2; 
01F6:  BSF    F93.6
01F8:  MOVLW  00
01FA:  BTFSC  F81.6
01FC:  MOVLW  01
01FE:  MOVWF  00
0200:  RLCF   00,F
0202:  RLCF   00,F
0204:  MOVLW  FC
0206:  ANDWF  00,F
0208:  MOVF   00,W
020A:  IORWF  33,F
....................    n |= input(LCD_DATA7) << 3; 
020C:  BSF    F93.7
020E:  MOVLW  00
0210:  BTFSC  F81.7
0212:  MOVLW  01
0214:  MOVWF  00
0216:  RLCF   00,F
0218:  RLCF   00,F
021A:  RLCF   00,F
021C:  MOVLW  F8
021E:  ANDWF  00,F
0220:  MOVF   00,W
0222:  IORWF  33,F
....................     
....................    return(n); 
0224:  MOVFF  33,01
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
0228:  RETLW  00
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0194:  BTFSC  32.0
0196:  BRA    019C
0198:  BCF    F8A.4
019A:  BRA    019E
019C:  BSF    F8A.4
019E:  BCF    F93.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
01A0:  BTFSC  32.1
01A2:  BRA    01A8
01A4:  BCF    F8A.5
01A6:  BRA    01AA
01A8:  BSF    F8A.5
01AA:  BCF    F93.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
01AC:  BTFSC  32.2
01AE:  BRA    01B4
01B0:  BCF    F8A.6
01B2:  BRA    01B6
01B4:  BSF    F8A.6
01B6:  BCF    F93.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01B8:  BTFSC  32.3
01BA:  BRA    01C0
01BC:  BCF    F8A.7
01BE:  BRA    01C2
01C0:  BSF    F8A.7
01C2:  BCF    F93.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01C4:  NOP   
....................    lcd_output_enable(1); 
01C6:  BSF    F8A.2
01C8:  BCF    F93.2
....................    delay_us(2); 
01CA:  MOVLW  03
01CC:  MOVWF  00
01CE:  DECFSZ 00,F
01D0:  BRA    01CE
....................    lcd_output_enable(0); 
01D2:  BCF    F8A.2
01D4:  BCF    F93.2
.................... } 
01D6:  RETLW  00
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0278:  BCF    F93.2
....................    lcd_rs_tris(); 
027A:  BCF    F93.0
....................    lcd_rw_tris(); 
027C:  BCF    F93.1
....................   #endif 
....................  
....................    lcd_output_rs(0); 
027E:  BCF    F8A.0
0280:  BCF    F93.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
0282:  BRA    022A
0284:  MOVFF  01,31
0288:  BTFSC  01.7
028A:  BRA    0282
....................    lcd_output_rs(address); 
028C:  MOVF   2F,F
028E:  BNZ   0294
0290:  BCF    F8A.0
0292:  BRA    0296
0294:  BSF    F8A.0
0296:  BCF    F93.0
....................    delay_cycles(1); 
0298:  NOP   
....................    lcd_output_rw(0); 
029A:  BCF    F8A.1
029C:  BCF    F93.1
....................    delay_cycles(1); 
029E:  NOP   
....................    lcd_output_enable(0); 
02A0:  BCF    F8A.2
02A2:  BCF    F93.2
....................    lcd_send_nibble(n >> 4); 
02A4:  SWAPF  30,W
02A6:  MOVWF  31
02A8:  MOVLW  0F
02AA:  ANDWF  31,F
02AC:  MOVFF  31,32
02B0:  RCALL  0194
....................    lcd_send_nibble(n & 0xf); 
02B2:  MOVF   30,W
02B4:  ANDLW  0F
02B6:  MOVWF  31
02B8:  MOVWF  32
02BA:  RCALL  0194
.................... } 
02BC:  RETLW  00
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
02BE:  BCF    F93.4
....................    output_drive(LCD_DATA5); 
02C0:  BCF    F93.5
....................    output_drive(LCD_DATA6); 
02C2:  BCF    F93.6
....................    output_drive(LCD_DATA7); 
02C4:  BCF    F93.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
02C6:  BCF    F93.2
....................    lcd_rs_tris(); 
02C8:  BCF    F93.0
....................    lcd_rw_tris(); 
02CA:  BCF    F93.1
....................  #endif 
....................  
....................    lcd_output_rs(0); 
02CC:  BCF    F8A.0
02CE:  BCF    F93.0
....................    lcd_output_rw(0); 
02D0:  BCF    F8A.1
02D2:  BCF    F93.1
....................    lcd_output_enable(0); 
02D4:  BCF    F8A.2
02D6:  BCF    F93.2
....................      
....................    delay_ms(15); 
02D8:  MOVLW  0F
02DA:  MOVWF  2B
02DC:  RCALL  016E
....................    for(i=1;i<=3;++i) 
02DE:  MOVLW  01
02E0:  MOVWF  21
02E2:  MOVF   21,W
02E4:  SUBLW  03
02E6:  BNC   02FC
....................    { 
....................        lcd_send_nibble(3); 
02E8:  MOVLW  03
02EA:  MOVWF  32
02EC:  RCALL  0194
....................        lcd_send_nibble(0); 
02EE:  CLRF   32
02F0:  RCALL  0194
....................        delay_ms(5); 
02F2:  MOVLW  05
02F4:  MOVWF  2B
02F6:  RCALL  016E
....................    } 
02F8:  INCF   21,F
02FA:  BRA    02E2
....................     
....................    lcd_send_nibble(2); 
02FC:  MOVLW  02
02FE:  MOVWF  32
0300:  RCALL  0194
....................    lcd_send_nibble(0); 
0302:  CLRF   32
0304:  RCALL  0194
....................    delay_ms(5); 
0306:  MOVLW  05
0308:  MOVWF  2B
030A:  RCALL  016E
....................    for(i=0;i<=3;++i) 
030C:  CLRF   21
030E:  MOVF   21,W
0310:  SUBLW  03
0312:  BNC   0326
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0314:  CLRF   03
0316:  MOVF   21,W
0318:  RCALL  00BA
031A:  MOVWF  22
031C:  CLRF   2F
031E:  MOVWF  30
0320:  RCALL  0278
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0322:  INCF   21,F
0324:  BRA    030E
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
0326:  GOTO   04EA (RETURN)
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
....................    BYTE address; 
....................     
....................    if(y!=1) 
032A:  DECFSZ 2C,W
032C:  BRA    0330
032E:  BRA    0336
....................       address=LCD_LINE_TWO; 
0330:  MOVLW  40
0332:  MOVWF  2D
....................    else 
0334:  BRA    0338
....................       address=0; 
0336:  CLRF   2D
....................       
....................    address+=x-1; 
0338:  MOVLW  01
033A:  SUBWF  2B,W
033C:  ADDWF  2D,F
....................    lcd_send_byte(0,0x80|address); 
033E:  MOVF   2D,W
0340:  IORLW  80
0342:  MOVWF  2E
0344:  CLRF   2F
0346:  MOVWF  30
0348:  RCALL  0278
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
034A:  RETLW  00
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
034C:  MOVF   2A,W
034E:  XORLW  07
0350:  BZ    0360
0352:  XORLW  0B
0354:  BZ    036A
0356:  XORLW  06
0358:  BZ    037A
035A:  XORLW  02
035C:  BZ    0386
035E:  BRA    0390
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0360:  MOVLW  01
0362:  MOVWF  2B
0364:  MOVWF  2C
0366:  RCALL  032A
0368:  BRA    039C
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
036A:  CLRF   2F
036C:  MOVLW  01
036E:  MOVWF  30
0370:  RCALL  0278
....................                      delay_ms(2); 
0372:  MOVLW  02
0374:  MOVWF  2B
0376:  RCALL  016E
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0378:  BRA    039C
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
037A:  MOVLW  01
037C:  MOVWF  2B
037E:  MOVLW  02
0380:  MOVWF  2C
0382:  RCALL  032A
0384:  BRA    039C
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0386:  CLRF   2F
0388:  MOVLW  10
038A:  MOVWF  30
038C:  RCALL  0278
038E:  BRA    039C
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0390:  MOVLW  01
0392:  MOVWF  2F
0394:  MOVFF  2A,30
0398:  RCALL  0278
039A:  BRA    039C
....................      #endif 
....................    } 
.................... } 
039C:  RETLW  00
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... void lcd_putnum(int16 so,INT8 x,int8 y) 
.................... { 
....................    INT32 a, b, c, d, e; 
....................    a = so / 10000; 
....................    b = (so - 10000 * a) / 1000; 
....................    c = (so - 10000 * a - 1000 * b) / 100; 
....................    d = (so - 10000 * a - 1000 * b - 100 * c) / 10; 
....................    e = so - 10000 * a - 1000 * b - 100 * c - 10 * d; 
....................    lcd_gotoxy (x, y); 
....................    lcd_putc (a + 48); 
....................    lcd_putc (b + 48); 
....................    lcd_putc (c + 48); 
....................    lcd_putc (d + 48); 
....................    lcd_putc (e + 48); 
.................... } 
....................   
.................... #define ChanelA PIN_C4 
.................... #define ChanelB PIN_C5 
....................  
.................... signed int16 En2; 
....................  
.................... #INT_EXT1 
.................... void  EXT1_L2H_isr(void)  
.................... { 
.................... INTEDG1^=1; 
*
00CE:  MOVLW  00
00D0:  BTFSS  FF1.5
00D2:  MOVLW  01
00D4:  BCF    FF1.5
00D6:  BTFSC  FE8.0
00D8:  BSF    FF1.5
.................... if (INTEDG1) 
00DA:  BTFSS  FF1.5
00DC:  BRA    00F4
....................    { 
....................    if (input(ChanelB)) {En2++;}  
00DE:  BTFSS  F82.5
00E0:  BRA    00EA
00E2:  INCF   1F,F
00E4:  BTFSC  FD8.2
00E6:  INCF   20,F
....................    else {En2--;} 
00E8:  BRA    00F2
00EA:  MOVF   1F,W
00EC:  BTFSC  FD8.2
00EE:  DECF   20,F
00F0:  DECF   1F,F
....................    } 
.................... else  
00F2:  BRA    0108
....................    {  
....................    if (input(ChanelB)) {En2--;} 
00F4:  BTFSS  F82.5
00F6:  BRA    0102
00F8:  MOVF   1F,W
00FA:  BTFSC  FD8.2
00FC:  DECF   20,F
00FE:  DECF   1F,F
....................    else {En2++;} 
0100:  BRA    0108
0102:  INCF   1F,F
0104:  BTFSC  FD8.2
0106:  INCF   20,F
....................    } 
.................... } 
....................  
0108:  BCF    FF0.0
010A:  GOTO   006C
.................... #int_EXT2 
.................... void  EXT2_isr(void)  
.................... { 
.................... INTEDG2^=1; 
010E:  MOVLW  00
0110:  BTFSS  FF1.4
0112:  MOVLW  01
0114:  BCF    FF1.4
0116:  BTFSC  FE8.0
0118:  BSF    FF1.4
.................... if (INTEDG2) 
011A:  BTFSS  FF1.4
011C:  BRA    0134
....................    { 
....................    if (input(ChanelA)) {En2--;}  
011E:  BTFSS  F82.4
0120:  BRA    012C
0122:  MOVF   1F,W
0124:  BTFSC  FD8.2
0126:  DECF   20,F
0128:  DECF   1F,F
....................    else {En2++;} 
012A:  BRA    0132
012C:  INCF   1F,F
012E:  BTFSC  FD8.2
0130:  INCF   20,F
....................    } 
.................... else  
0132:  BRA    0148
....................    {  
....................    if (input(ChanelA)) {En2++;} 
0134:  BTFSS  F82.4
0136:  BRA    0140
0138:  INCF   1F,F
013A:  BTFSC  FD8.2
013C:  INCF   20,F
....................    else {En2--;} 
013E:  BRA    0148
0140:  MOVF   1F,W
0142:  BTFSC  FD8.2
0144:  DECF   20,F
0146:  DECF   1F,F
....................    } 
.................... } 
....................  
....................  
0148:  BCF    FF0.1
014A:  GOTO   006C
.................... void main() 
.................... { 
*
04CC:  CLRF   FF8
04CE:  BCF    FD0.7
04D0:  BSF    07.7
04D2:  CLRF   FEA
04D4:  CLRF   FE9
04D6:  BCF    FB9.0
04D8:  BCF    FC1.6
04DA:  BCF    FC1.7
04DC:  MOVLW  00
04DE:  MOVWF  FB8
04E0:  CLRF   19
04E2:  CLRF   1A
....................    trisc=0xff; 
04E4:  MOVLW  FF
04E6:  MOVWF  F94
....................    lcd_init(); 
04E8:  BRA    02BE
....................    lcd_putc ("Ready........."); 
04EA:  MOVLW  4E
04EC:  MOVWF  FF6
04EE:  MOVLW  01
04F0:  MOVWF  FF7
04F2:  BRA    039E
....................    delay_ms(1000); 
04F4:  MOVLW  04
04F6:  MOVWF  21
04F8:  MOVLW  FA
04FA:  MOVWF  2B
04FC:  RCALL  016E
04FE:  DECFSZ 21,F
0500:  BRA    04F8
....................    lcd_putc ('\f'); 
0502:  MOVLW  0C
0504:  MOVWF  2A
0506:  RCALL  034C
....................     
....................    enable_interrupts(INT_EXT1); 
0508:  BSF    FF0.3
....................    enable_interrupts(INT_EXT2); 
050A:  BSF    FF0.4
....................    enable_interrupts(GLOBAL); 
050C:  MOVLW  C0
050E:  IORWF  FF2,F
....................    ext_int_edge(1,L_to_H); 
0510:  BSF    FF1.5
....................    ext_int_edge(2,L_to_H); 
0512:  BSF    FF1.4
....................    
....................    En2=0; 
0514:  CLRF   20
0516:  CLRF   1F
....................    while(true) 
....................       { 
....................       printf(LCD_PUTC, "\fEn_count=%5Ld",En2); 
0518:  MOVLW  5E
051A:  MOVWF  FF6
051C:  MOVLW  01
051E:  MOVWF  FF7
0520:  MOVLW  0A
0522:  MOVWF  21
0524:  BRA    03C0
0526:  MOVLW  01
0528:  MOVWF  FE9
052A:  MOVFF  20,22
052E:  MOVFF  1F,21
0532:  BRA    03E0
....................       delay_ms(200); 
0534:  MOVLW  C8
0536:  MOVWF  2B
0538:  RCALL  016E
.................... //      lcd_putnum(En2,0,1); 
....................       } 
053A:  BRA    0518
....................  
.................... } 
053C:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 3E0E   PUT BROWNOUT BORRES NOWDT WDT32768 NOWINEN
   Word  3: 9D3C   NOPWMPIN LPOL_HIGH HPOL_HIGH T1LOWPOWER FLTAC1 SSP_RC PWM4B5 EXCLKC3 MCLR
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
