CCS PCH C Compiler, Version 4.114, 93460303               18-Mar-14 13:54

               Filename: F:\Robocon 2014\Lap trinh design\LAP TRINH ROBOT TU DONG\tudong18-3\tudong16-3\tudong4016-3\16-3.lst

               ROM used: 3608 bytes (22%)
                         Largest free fragment is 12772
               RAM used: 91 (12%) at main() level
                         117 (15%) worst case
               Stack:    6 worst case (3 in main + 3 for interrupts)

*
0000:  GOTO   0D26
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   015E
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   09B0
006C:  BTFSS  FF0.3
006E:  GOTO   0078
0072:  BTFSC  FF0.0
0074:  GOTO   00DE
0078:  BTFSS  FF0.4
007A:  GOTO   0084
007E:  BTFSC  FF0.1
0080:  GOTO   011E
0084:  BTFSS  FA3.0
0086:  GOTO   0090
008A:  BTFSC  FA4.0
008C:  GOTO   09D6
0090:  MOVFF  0E,00
0094:  MOVFF  0F,01
0098:  MOVFF  10,02
009C:  MOVFF  11,03
00A0:  MOVFF  0C,FE9
00A4:  MOVFF  07,FEA
00A8:  BSF    07.7
00AA:  MOVFF  08,FE1
00AE:  MOVFF  09,FE2
00B2:  MOVFF  0A,FD9
00B6:  MOVFF  0B,FDA
00BA:  MOVFF  12,FF3
00BE:  MOVFF  13,FF4
00C2:  MOVFF  14,FFA
00C6:  MOVFF  15,FF5
00CA:  MOVFF  16,FF6
00CE:  MOVFF  17,FF7
00D2:  MOVF   04,W
00D4:  MOVFF  06,FE0
00D8:  MOVFF  05,FD8
00DC:  RETFIE 0
....................  
.................... ///// CHUONG TRINH CHINH 
.................... #include <khoidong.c> 
....................  
.................... ///// KHOI DONG PIC 
....................  
.................... #include <18F4431.h> 
.................... //////// Standard Header file for the PIC18F4431 device //////////////// 
.................... #device PIC18F4431 
.................... #list 
....................  
.................... #include <PIC18F4431_registers.h> 
.................... #byte TOSU = 0xFFF 
.................... #word TOS = 0xFFE 
.................... #byte STKPTR = 0xFFC 
.................... #bit    STKPTR0 = STKPTR.0 
.................... #bit    STKPTR1 = STKPTR.1 
.................... #bit    STKPTR2 = STKPTR.2 
.................... #bit    STKPTR3 = STKPTR.3 
.................... #bit    STKPTR4 = STKPTR.4 
.................... #bit    STKUNF = STKPTR.6 
.................... #bit    STKFUL = STKPTR.7 
.................... #byte PCLATU = 0xFFB 
.................... #byte PCLATH = 0xFFA 
.................... #byte PCL = 0xFF9 
.................... #byte TBLPTRU = 0xFF8 
.................... #bit    TBLPTRU0 = TBLPTRU.0 
.................... #bit    TBLPTRU1 = TBLPTRU.1 
.................... #bit    TBLPTRU2 = TBLPTRU.2 
.................... #bit    TBLPTRU3 = TBLPTRU.3 
.................... #bit    TBLPTRU4 = TBLPTRU.4 
.................... #bit    ACSS = TBLPTRU.5 
.................... #word TBLPTR = 0xFF7 
.................... #byte TABLAT = 0xFF5 
.................... #word PROD = 0xFF4 
.................... #byte INTCON = 0xFF2 
.................... #bit    RBIF = INTCON.0 
.................... #bit    INT0IF = INTCON.1 
.................... #bit    TMR0IF = INTCON.2 
.................... #bit    RBIE = INTCON.3 
.................... #bit    INT0IE = INTCON.4 
.................... #bit    TMR0IE = INTCON.5 
.................... #bit    PEIE_GIEL = INTCON.6 
.................... #bit    GIE_GIEH = INTCON.7 
.................... #byte INTCON2 = 0xFF1 
.................... #bit    RBIP = INTCON2.0 
.................... #bit    TMR0IP = INTCON2.2 
.................... #bit    INTEDG2 = INTCON2.4 
.................... #bit    INTEDG1 = INTCON2.5 
.................... #bit    INTEDG0 = INTCON2.6 
.................... #bit    RBPU = INTCON2.7 
.................... #byte INTCON3 = 0xFF0 
.................... #bit    INT1IF = INTCON3.0 
.................... #bit    INT2IF = INTCON3.1 
.................... #bit    INT1IE = INTCON3.3 
.................... #bit    INT2IE = INTCON3.4 
.................... #bit    INT1IP = INTCON3.6 
.................... #bit    INT2IP = INTCON3.7 
.................... #byte INDF0 = 0xFEF 
.................... #byte POSTINC0 = 0xFEE 
.................... #byte POSTDEC0 = 0xFED 
.................... #byte PREINC0 = 0xFEC 
.................... #byte PLUSW0 = 0xFEB 
.................... #word FSR0 = 0xFEA 
.................... #byte WREG = 0xFE8 
.................... #byte INDF1 = 0xFE7 
.................... #byte POSTINC1 = 0xFE6 
.................... #byte POSTDEC1 = 0xFE5 
.................... #byte PREINC1 = 0xFE4 
.................... #byte PLUSW1 = 0xFE3 
.................... #word FSR1 = 0xFE2 
.................... #byte BSR = 0xFE0 
.................... #byte INDF2 = 0xFDF 
.................... #byte POSTINC2 = 0xFDE 
.................... #byte POSTDEC2 = 0xFDD 
.................... #byte PREINC2 = 0xFDC 
.................... #byte PLUSW2 = 0xFDB 
.................... #word FSR2 = 0xFDA 
.................... #byte STATUS = 0xFD8 
.................... #bit    DC = STATUS.1 
.................... #bit    OV = STATUS.3 
.................... #word TMR0 = 0xFD7 
.................... #byte T0CON = 0xFD5 
.................... #bit    T0PS0 = T0CON.0 
.................... #bit    T0PS1 = T0CON.1 
.................... #bit    T0PS2 = T0CON.2 
.................... #bit    PSA = T0CON.3 
.................... #bit    T0SE = T0CON.4 
.................... #bit    T0CS = T0CON.5 
.................... #bit    T016BIT = T0CON.6 
.................... #bit    TMR0ON = T0CON.7 
.................... #byte OSCCON = 0xFD3 
.................... #bit    SCS0 = OSCCON.0 
.................... #bit    SCS1 = OSCCON.1 
.................... #bit    IOFS = OSCCON.2 
.................... #bit    OSTS = OSCCON.3 
.................... #bit    IRCF0 = OSCCON.4 
.................... #bit    IRCF1 = OSCCON.5 
.................... #bit    IRCF2 = OSCCON.6 
.................... #bit    IDLEN = OSCCON.7 
.................... #byte LVDCON = 0xFD2 
.................... #bit    LVDL0 = LVDCON.0 
.................... #bit    LVDL1 = LVDCON.1 
.................... #bit    LVDL2 = LVDCON.2 
.................... #bit    LVDL3 = LVDCON.3 
.................... #bit    LVDEN = LVDCON.4 
.................... #bit    IRVST = LVDCON.5 
.................... #byte WDTCON = 0xFD1 
.................... #bit    SWDTEN = WDTCON.0 
.................... #bit    WDTW = WDTCON.7 
.................... #byte RCON = 0xFD0 
.................... #bit    BOR = RCON.0 
.................... #bit    POR = RCON.1 
.................... #bit    PD = RCON.2 
.................... #bit    TO = RCON.3 
.................... #bit    RI = RCON.4 
.................... #bit    IPEN = RCON.7 
.................... #word TMR1 = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... #bit    TMR1ON = T1CON.0 
.................... #bit    TMR1CS = T1CON.1 
.................... #bit    T1SYNC = T1CON.2 
.................... #bit    T1OSCEN = T1CON.3 
.................... #bit    T1CKPS0 = T1CON.4 
.................... #bit    T1CKPS1 = T1CON.5 
.................... #bit    T1RUN = T1CON.6 
.................... #bit    RD16 = T1CON.7 
.................... #byte TMR2 = 0xFCC 
.................... #byte PR2 = 0xFCB 
.................... #byte T2CON = 0xFCA 
.................... #bit    T2CKPS0 = T2CON.0 
.................... #bit    T2CKPS1 = T2CON.1 
.................... #bit    TMR2ON = T2CON.2 
.................... #bit    TOUTPS0 = T2CON.3 
.................... #bit    TOUTPS1 = T2CON.4 
.................... #bit    TOUTPS2 = T2CON.5 
.................... #bit    TOUTPS3 = T2CON.6 
.................... #byte SSPBUF = 0xFC9 
.................... #byte SSPADD = 0xFC8 
.................... #byte SSPSTAT = 0xFC7 
.................... #bit    BF = SSPSTAT.0 
.................... #bit    UA = SSPSTAT.1 
.................... #bit    CKE = SSPSTAT.6 
.................... #bit    SMP = SSPSTAT.7 
.................... #byte SSPCON = 0xFC6 
.................... #bit    SSPM0 = SSPCON.0 
.................... #bit    SSPM1 = SSPCON.1 
.................... #bit    SSPM2 = SSPCON.2 
.................... #bit    SSPM3 = SSPCON.3 
.................... #bit    CKP = SSPCON.4 
.................... #bit    SSPEN = SSPCON.5 
.................... #bit    SSPOV = SSPCON.6 
.................... #bit    WCOL = SSPCON.7 
.................... #word ADRES = 0xFC4 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    ADON = ADCON0.0 
.................... #bit    GO = ADCON0.1 
.................... #bit    ACMOD0 = ADCON0.2 
.................... #bit    ACMOD1 = ADCON0.3 
.................... #bit    ACSCH = ADCON0.4 
.................... #bit    ACONV = ADCON0.5 
.................... #byte ADCON1 = 0xFC1 
.................... #bit    ADPNT0 = ADCON1.0 
.................... #bit    ADPNT1 = ADCON1.1 
.................... #bit    BFOVFL = ADCON1.2 
.................... #bit    BFEMT = ADCON1.3 
.................... #bit    FIFOEN = ADCON1.4 
.................... #bit    VCFG0 = ADCON1.6 
.................... #bit    VCFG1 = ADCON1.7 
.................... #byte ADCON2 = 0xFC0 
.................... #bit    ADCS0 = ADCON2.0 
.................... #bit    ADCS1 = ADCON2.1 
.................... #bit    ADCS2 = ADCON2.2 
.................... #bit    ACQT0 = ADCON2.3 
.................... #bit    ACQT1 = ADCON2.4 
.................... #bit    ACQT2 = ADCON2.5 
.................... #bit    ACQT3 = ADCON2.6 
.................... #bit    ADFM = ADCON2.7 
.................... #word CCPR1 = 0xFBF 
.................... #byte CCP1CON = 0xFBD 
.................... #bit    CCP1M0 = CCP1CON.0 
.................... #bit    CCP1M1 = CCP1CON.1 
.................... #bit    CCP1M2 = CCP1CON.2 
.................... #bit    CCP1M3 = CCP1CON.3 
.................... #bit    DC1B0 = CCP1CON.4 
.................... #bit    DC1B1 = CCP1CON.5 
.................... #word CCPR2 = 0xFBC 
.................... #byte CCP2CON = 0xFBA 
.................... #bit    CCP2M0 = CCP2CON.0 
.................... #bit    CCP2M1 = CCP2CON.1 
.................... #bit    CCP2M2 = CCP2CON.2 
.................... #bit    CCP2M3 = CCP2CON.3 
.................... #bit    DC2B0 = CCP2CON.4 
.................... #bit    DC2B1 = CCP2CON.5 
.................... #byte ANSEL1 = 0xFB9 
.................... #bit    ANS8 = ANSEL1.0 
.................... #byte ANSEL0 = 0xFB8 
.................... #byte T5CON = 0xFB7 
.................... #bit    TMR5ON = T5CON.0 
.................... #bit    TMR5CS = T5CON.1 
.................... #bit    T5SYNC = T5CON.2 
.................... #bit    T5PS0 = T5CON.3 
.................... #bit    T5PS1 = T5CON.4 
.................... #bit    T5MOD = T5CON.5 
.................... #bit    RESEN = T5CON.6 
.................... #bit    T5SEN = T5CON.7 
.................... #byte QEICON = 0xFB6 
.................... #bit    PDEC0 = QEICON.0 
.................... #bit    PDEC1 = QEICON.1 
.................... #bit    QEIM0 = QEICON.2 
.................... #bit    QEIM1 = QEICON.3 
.................... #bit    QEIM2 = QEICON.4 
.................... #bit    UP = QEICON.5 
.................... #bit    ERROR = QEICON.6 
.................... #bit    VELM = QEICON.7 
.................... #byte SPBRGH = 0xFB0 
.................... #byte SPBRG = 0xFAF 
.................... #byte RCREG = 0xFAE 
.................... #byte TXREG = 0xFAD 
.................... #byte TXSTA = 0xFAC 
.................... #bit    TX9D = TXSTA.0 
.................... #bit    TRMT = TXSTA.1 
.................... #bit    BRGH = TXSTA.2 
.................... #bit    SENDB = TXSTA.3 
.................... #bit    SYNC = TXSTA.4 
.................... #bit    TXEN = TXSTA.5 
.................... #bit    TX9 = TXSTA.6 
.................... #bit    CSRC = TXSTA.7 
.................... #byte RCSTA = 0xFAB 
.................... #bit    RX9D = RCSTA.0 
.................... #bit    OERR = RCSTA.1 
.................... #bit    FERR = RCSTA.2 
.................... #bit    ADDEN = RCSTA.3 
.................... #bit    CREN = RCSTA.4 
.................... #bit    SREN = RCSTA.5 
.................... #bit    RX9 = RCSTA.6 
.................... #bit    SPEN = RCSTA.7 
.................... #byte BAUDCON = 0xFAA 
.................... #bit    ABDEN = BAUDCON.0 
.................... #bit    WUE = BAUDCON.1 
.................... #bit    BRG16 = BAUDCON.3 
.................... #bit    TXCKP = BAUDCON.4 
.................... #bit    RXDTP = BAUDCON.5 
.................... #bit    RCIDL = BAUDCON.6 
.................... #bit    ABDOVF = BAUDCON.7 
.................... #byte EEADR = 0xFA9 
.................... #byte EEDATA = 0xFA8 
.................... #byte EECON2 = 0xFA7 
.................... #byte EECON1 = 0xFA6 
.................... #bit    RD = EECON1.0 
.................... #bit    WR = EECON1.1 
.................... #bit    WREN = EECON1.2 
.................... #bit    WRERR = EECON1.3 
.................... #bit    FREE = EECON1.4 
.................... #bit    CFGS = EECON1.6 
.................... #bit    EEPGD = EECON1.7 
.................... #byte IPR3 = 0xFA5 
.................... #bit    TMR5IP = IPR3.0 
.................... #bit    IC1IP = IPR3.1 
.................... #bit    IC2QEIP = IPR3.2 
.................... #bit    IC3DRIP = IPR3.3 
.................... #bit    PTIP = IPR3.4 
.................... #byte PIR3 = 0xFA4 
.................... #bit    TMR5IF = PIR3.0 
.................... #bit    IC1IF = PIR3.1 
.................... #bit    IC2QEIF = PIR3.2 
.................... #bit    IC3DRIF = PIR3.3 
.................... #bit    PTIF = PIR3.4 
.................... #byte PIE3 = 0xFA3 
.................... #bit    TMR5IE = PIE3.0 
.................... #bit    IC1IE = PIE3.1 
.................... #bit    IC2QEIE = PIE3.2 
.................... #bit    IC3DRIE = PIE3.3 
.................... #bit    PTIE = PIE3.4 
.................... #byte IPR2 = 0xFA2 
.................... #bit    CCP2IP = IPR2.0 
.................... #bit    LVDIP = IPR2.2 
.................... #bit    EEIP = IPR2.4 
.................... #bit    OSFIP = IPR2.7 
.................... #byte PIR2 = 0xFA1 
.................... #bit    CCP2IF = PIR2.0 
.................... #bit    LVDIF = PIR2.2 
.................... #bit    EEIF = PIR2.4 
.................... #bit    OSFIF = PIR2.7 
.................... #byte PIE2 = 0xFA0 
.................... #bit    CCP2IE = PIE2.0 
.................... #bit    LVDIE = PIE2.2 
.................... #bit    EEIE = PIE2.4 
.................... #bit    OSFIE = PIE2.7 
.................... #byte IPR1 = 0xF9F 
.................... #bit    TMR1IP = IPR1.0 
.................... #bit    TMR2IP = IPR1.1 
.................... #bit    CCP1IP = IPR1.2 
.................... #bit    SSPIP = IPR1.3 
.................... #bit    TXIP = IPR1.4 
.................... #bit    RCIP = IPR1.5 
.................... #bit    ADIP = IPR1.6 
.................... #byte PIR1 = 0xF9E 
.................... #bit    TMR1IF = PIR1.0 
.................... #bit    TMR2IF = PIR1.1 
.................... #bit    CCP1IF = PIR1.2 
.................... #bit    SSPIF = PIR1.3 
.................... #bit    TXIF = PIR1.4 
.................... #bit    RCIF = PIR1.5 
.................... #bit    ADIF = PIR1.6 
.................... #byte PIE1 = 0xF9D 
.................... #bit    TMR1IE = PIE1.0 
.................... #bit    TMR2IE = PIE1.1 
.................... #bit    CCP1IE = PIE1.2 
.................... #bit    SSPIE = PIE1.3 
.................... #bit    TXIE = PIE1.4 
.................... #bit    RCIE = PIE1.5 
.................... #bit    ADIE = PIE1.6 
.................... #byte OSCTUNE = 0xF9B 
.................... #byte ADCON3 = 0xF9A 
.................... #bit    SSRC0 = ADCON3.0 
.................... #bit    SSRC1 = ADCON3.1 
.................... #bit    SSRC2 = ADCON3.2 
.................... #bit    SSRC3 = ADCON3.3 
.................... #bit    SSRC4 = ADCON3.4 
.................... #bit    ADRS0 = ADCON3.6 
.................... #bit    ADRS1 = ADCON3.7 
.................... #byte ADCHS = 0xF99 
.................... #bit    SASEL0 = ADCHS.0 
.................... #bit    SASEL1 = ADCHS.1 
.................... #bit    SCSEL0 = ADCHS.2 
.................... #bit    SCSEL1 = ADCHS.3 
.................... #bit    SBSEL0 = ADCHS.4 
.................... #bit    SBSEL1 = ADCHS.5 
.................... #bit    SDSEL0 = ADCHS.6 
.................... #bit    SDSEL1 = ADCHS.7 
.................... #byte TRISE = 0xF96 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
.................... #byte TRISA = 0xF92 
.................... #word PR5 = 0xF91 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
.................... #byte LATA = 0xF89 
.................... #word TMR5 = 0xF88 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #byte PTCON0 = 0xF7F 
.................... #bit    PTMOD0 = PTCON0.0 
.................... #bit    PTMOD1 = PTCON0.1 
.................... #bit    PTCKPS0 = PTCON0.2 
.................... #bit    PTCKPS1 = PTCON0.3 
.................... #bit    PTOPS0 = PTCON0.4 
.................... #bit    PTOPS1 = PTCON0.5 
.................... #bit    PTOPS2 = PTCON0.6 
.................... #bit    PTOPS3 = PTCON0.7 
.................... #byte PTCON1 = 0xF7E 
.................... #bit    PTDIR = PTCON1.6 
.................... #bit    PTEN = PTCON1.7 
.................... #byte PTMRL = 0xF7D 
.................... #byte PTMRH = 0xF7C 
.................... #byte PTPERL = 0xF7B 
.................... #byte PTPERH = 0xF7A 
.................... #byte PDC0L = 0xF79 
.................... #byte PDC0H = 0xF78 
.................... #byte PDC1L = 0xF77 
.................... #byte PDC1H = 0xF76 
.................... #byte PDC2L = 0xF75 
.................... #byte PDC2H = 0xF74 
.................... #byte PDC3L = 0xF73 
.................... #byte PDC3H = 0xF72 
.................... #byte SEVTCMPL = 0xF71 
.................... #byte SEVTCMPH = 0xF70 
.................... #byte PWMCON0 = 0xF6F 
.................... #bit    PMOD0 = PWMCON0.0 
.................... #bit    PMOD1 = PWMCON0.1 
.................... #bit    PMOD2 = PWMCON0.2 
.................... #bit    PMOD3 = PWMCON0.3 
.................... #bit    PWMEN0 = PWMCON0.4 
.................... #bit    PWMEN1 = PWMCON0.5 
.................... #bit    PWMEN2 = PWMCON0.6 
.................... #byte PWMCON1 = 0xF6E 
.................... #bit    OSYNC = PWMCON1.0 
.................... #bit    UDIS = PWMCON1.1 
.................... #bit    SEVTDIR = PWMCON1.3 
.................... #bit    SEVOPS0 = PWMCON1.4 
.................... #bit    SEVOPS1 = PWMCON1.5 
.................... #bit    SEVOPS2 = PWMCON1.6 
.................... #bit    SEVOPS3 = PWMCON1.7 
.................... #byte DTCON = 0xF6D 
.................... #bit    DTA0 = DTCON.0 
.................... #bit    DTA1 = DTCON.1 
.................... #bit    DTA2 = DTCON.2 
.................... #bit    DTA3 = DTCON.3 
.................... #bit    DTA4 = DTCON.4 
.................... #bit    DTA5 = DTCON.5 
.................... #bit    DTAPS0 = DTCON.6 
.................... #bit    DTAPS1 = DTCON.7 
.................... #byte FLTCONFIG = 0xF6C 
.................... #bit    FLTAEN = FLTCONFIG.0 
.................... #bit    FLTAMOD = FLTCONFIG.1 
.................... #bit    FLTAS = FLTCONFIG.2 
.................... #bit    FLTCON = FLTCONFIG.3 
.................... #bit    FLTBEN = FLTCONFIG.4 
.................... #bit    FLTBMOD = FLTCONFIG.5 
.................... #bit    FLTBS = FLTCONFIG.6 
.................... #bit    BRFEN = FLTCONFIG.7 
.................... #byte OVDCOND = 0xF6B 
.................... #byte OVDCONS = 0xF6A 
.................... #word CAP1BUF = 0xF69 
.................... #word CAP2BUF = 0xF67 
.................... #word CAP3BUF = 0xF65 
.................... #byte CAP1CON = 0xF63 
.................... #bit    CAP1M0 = CAP1CON.0 
.................... #bit    CAP1M1 = CAP1CON.1 
.................... #bit    CAP1M2 = CAP1CON.2 
.................... #bit    CAP1M3 = CAP1CON.3 
.................... #bit    CAP1TMR = CAP1CON.5 
.................... #bit    CAP1REN = CAP1CON.6 
.................... #byte CAP2CON = 0xF62 
.................... #bit    CAP2M0 = CAP2CON.0 
.................... #bit    CAP2M1 = CAP2CON.1 
.................... #bit    CAP2M2 = CAP2CON.2 
.................... #bit    CAP2M3 = CAP2CON.3 
.................... #bit    CAP2TMR = CAP2CON.5 
.................... #bit    CAP2REN = CAP2CON.6 
.................... #byte CAP3CON = 0xF61 
.................... #bit    CAP3M0 = CAP3CON.0 
.................... #bit    CAP3M1 = CAP3CON.1 
.................... #bit    CAP3M2 = CAP3CON.2 
.................... #bit    CAP3M3 = CAP3CON.3 
.................... #bit    CAP3TMR = CAP3CON.5 
.................... #bit    CAP3REN = CAP3CON.6 
.................... #byte DFLTCON = 0xF60 
.................... #bit    FLTCK0 = DFLTCON.0 
.................... #bit    FLTCK1 = DFLTCON.1 
.................... #bit    FLTCK2 = DFLTCON.2 
.................... #bit    FLT1EN = DFLTCON.3 
.................... #bit    FLT2EN = DFLTCON.4 
.................... #bit    FLT3EN = DFLTCON.5 
.................... #bit    FLT4EN = DFLTCON.6 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, H4,PUT, NOPROTECT, NODEBUG, NOBROWNOUT, NOLVP, NOCPD, NOWRT//, SSP_RD 
.................... #use delay(clock=40000000) 
*
0AC6:  CLRF   FEA
0AC8:  MOVLW  5E
0ACA:  MOVWF  FE9
0ACC:  MOVF   FEF,W
0ACE:  BZ    0AEC
0AD0:  MOVLW  0C
0AD2:  MOVWF  01
0AD4:  CLRF   00
0AD6:  DECFSZ 00,F
0AD8:  BRA    0AD6
0ADA:  DECFSZ 01,F
0ADC:  BRA    0AD4
0ADE:  MOVLW  F7
0AE0:  MOVWF  00
0AE2:  DECFSZ 00,F
0AE4:  BRA    0AE2
0AE6:  BRA    0AE8
0AE8:  DECFSZ FEF,F
0AEA:  BRA    0AD0
0AEC:  RETLW  00
....................  
.................... //#use spi(MASTER ,FORCE_HW, BITS=16) 
.................... //#bit ss1 = PORTD.0 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(d) 
.................... #use fast_io(c) 
.................... #use fast_io(e) 
....................  
.................... void khoidong() 
.................... { 
....................    trisa=0b00011000; /// DAU VAO QEI CUNG 
*
09EA:  MOVLW  18
09EC:  MOVWF  F92
....................    trisb=0b11111111; /// DAU VAO CONG TAC HANH TRINH 
09EE:  MOVLW  FF
09F0:  MOVWF  F93
....................    port_b_pullups(0xff); 
09F2:  BCF    FF1.7
....................    portb=0xff; 
09F4:  MOVWF  F81
....................    trisc=0b00110000; /// DAU VAO QEI MEM 
09F6:  MOVLW  30
09F8:  MOVWF  F94
....................    portc=0b00000000; 
09FA:  CLRF   F82
....................    trisd=0b00000000; /// DAU VAO SPI 0b00000100 
09FC:  CLRF   F95
....................    portd=0x00; 
09FE:  CLRF   F83
....................    trise=0b00000000; 
0A00:  CLRF   F96
....................     
....................    enable_interrupts(INT_EXT1); 
0A02:  BSF    FF0.3
....................    enable_interrupts(INT_EXT2); 
0A04:  BSF    FF0.4
....................     
....................    //enable_interrupts(int_timer0); 
....................    //enable_interrupts(int_timer1); 
....................    enable_interrupts(int_timer5); 
0A06:  BSF    FA3.0
....................     
....................    enable_interrupts(GLOBAL); 
0A08:  MOVLW  C0
0A0A:  IORWF  FF2,F
....................    ext_int_edge(1,L_to_H); 
0A0C:  BSF    FF1.5
....................    ext_int_edge(2,L_to_H); 
0A0E:  BSF    FF1.4
....................     
....................    clear_interrupt(INT_EXT1); 
0A10:  BCF    FF0.0
....................    clear_interrupt(INT_EXT2); 
0A12:  BCF    FF0.1
....................    //clear_interrupt(int_timer0); 
....................    clear_interrupt(int_timer1); 
0A14:  BCF    F9E.0
....................    clear_interrupt(int_timer5); 
0A16:  BCF    FA4.0
....................     
....................    setup_qei(qei_mode_x4,qei_filter_enable_qea|qei_filter_enable_qeb|qei_filter_div_2,65535); 
0A18:  MOVLW  14
0A1A:  MOVWF  FB6
0A1C:  MOVLW  31
0A1E:  MOVWF  F60
0A20:  MOVLW  FF
0A22:  MOVWF  F65
0A24:  MOVWF  F64
0A26:  CLRF   F67
0A28:  CLRF   F66
....................    qei_set_count(0); 
0A2A:  CLRF   F67
0A2C:  CLRF   F66
....................     
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_4|RTCC_8_bit);      //102 us overflow, 0.4us 
0A2E:  MOVLW  C1
0A30:  MOVWF  FD5
....................    set_timer0(5); 
0A32:  CLRF   FD7
0A34:  MOVLW  05
0A36:  MOVWF  FD6
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);      //52.4 ms overflow, 0.8us 
0A38:  MOVLW  B5
0A3A:  MOVWF  FCD
....................    set_timer1(59286); 
0A3C:  MOVLW  E7
0A3E:  MOVWF  FCF
0A40:  MOVLW  96
0A42:  MOVWF  FCE
....................    setup_timer_5(T5_INTERNAL|T5_DIV_BY_8);      //52.4 ms overflow, 0.8us 
0A44:  MOVLW  19
0A46:  MOVWF  FB7
....................    set_timer5(59286); 
0A48:  MOVLW  E7
0A4A:  MOVWF  F88
0A4C:  MOVLW  96
0A4E:  MOVWF  F87
....................     
....................    //setup_spi(SPI_MASTER|SPI_L_TO_H|SPI_CLK_DIV_16); 
....................    //ss1=1; 
....................     
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0A50:  MOVLW  00
0A52:  IORLW  04
0A54:  MOVWF  FCA
0A56:  MOVLW  F9
0A58:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
0A5A:  BCF    F8B.2
0A5C:  MOVLW  0C
0A5E:  MOVWF  FBD
....................    
.................... } 
0A60:  GOTO   0D88 (RETURN)
....................  
.................... #include <van-ctht.c> 
....................  
.................... ///// DEFINE VAN 
....................  
.................... #bit vantay1=porte.1 
.................... #bit vantay2=porte.0 
.................... #bit vancanh1=porta.2     
.................... #bit vancanh2=porta.0     
.................... #bit vanleo=porta.1 
.................... #bit vanduoi=porta.5 
....................  
.................... ///// DEFINE CONG TAC HANH TRINH 
.................... #bit ctc1=portb.0 
.................... #bit ctt1=portb.1 
.................... #bit ctc2=portb.2 
.................... #bit ctt2=portb.3 
.................... #bit ctsel=portb.7 
.................... #bit cten=portb.6 
....................  
.................... ///// CHUONG TRINH LOA TIN HIEU 
.................... #bit trisloa = trisd.7 
.................... #bit loa = portd.7 
.................... void beep(int8 solan,int8 time) 
.................... { 
.................... int8 i; 
.................... for (i=0; i<solan; i++) 
*
0AEE:  CLRF   5C
0AF0:  MOVF   5A,W
0AF2:  SUBWF  5C,W
0AF4:  BC    0B10
....................    { 
....................    trisloa = 0; 
0AF6:  BCF    F95.7
....................    loa = 0; 
0AF8:  BCF    F83.7
....................    delay_ms(30); 
0AFA:  MOVLW  1E
0AFC:  MOVWF  5E
0AFE:  RCALL  0AC6
....................    loa = 1; 
0B00:  BSF    F83.7
....................    delay_ms(time-30); 
0B02:  MOVLW  1E
0B04:  SUBWF  5B,W
0B06:  MOVWF  5D
0B08:  MOVWF  5E
0B0A:  RCALL  0AC6
....................    } 
0B0C:  INCF   5C,F
0B0E:  BRA    0AF0
.................... } 
0B10:  RETLW  00
....................  
.................... #include <dongco.c> 
....................  
.................... ///// DEFINE CAC DONG CO 
....................  
.................... #bit br1=portd.4 
.................... #bit br2=portd.5 
.................... #bit trisbr1 = trisd.4 
.................... #bit trisbr2 = trisd.5 
.................... #bit dir1=portc.3 
.................... #bit dir2=portc.0 
.................... #bit trisdir1 = trisc.3 
.................... #bit trisdir2 = trisc.0 
.................... #bit pwm1=portc.2 
.................... #bit pwm2=portc.1 
.................... #bit trispwm1 = trisc.2 
.................... #bit trispwm2 = trisc.1 
....................  
.................... void dc1t(INT16 x) 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
*
0A64:  BCF    F95.4
0A66:  BCF    F94.3
0A68:  BCF    F94.2
....................    dir1 = 1; 
0A6A:  BSF    F82.3
....................    br1 = 0; 
0A6C:  BCF    F83.4
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0A6E:  MOVLW  00
0A70:  IORLW  04
0A72:  MOVWF  FCA
0A74:  MOVLW  F9
0A76:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
0A78:  BCF    F8B.2
0A7A:  MOVLW  0C
0A7C:  MOVWF  FBD
....................    set_pwm1_duty (x); 
0A7E:  MOVFF  5B,02
0A82:  MOVFF  5A,01
0A86:  RRCF   02,F
0A88:  RRCF   01,F
0A8A:  RRCF   02,F
0A8C:  RRCF   01,F
0A8E:  RRCF   02,F
0A90:  MOVFF  01,FBE
0A94:  RRCF   02,F
0A96:  RRCF   02,W
0A98:  ANDLW  30
0A9A:  MOVWF  00
0A9C:  MOVF   FBD,W
0A9E:  ANDLW  CF
0AA0:  IORWF  00,W
0AA2:  MOVWF  FBD
.................... } 
0AA4:  GOTO   0B8A (RETURN)
....................  
.................... void dc1n(INT16 x) 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
....................    dir1 = 0; 
....................    br1 = 0; 
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
....................    setup_ccp1 (ccp_pwm); 
....................    set_pwm1_duty (x); 
.................... } 
....................  
.................... void resetdc1() 
.................... { 
....................    trispwm1 = trisdir1 = trisbr1 = 0; 
0AA8:  BCF    F95.4
0AAA:  BCF    F94.3
0AAC:  BCF    F94.2
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0AAE:  MOVLW  00
0AB0:  IORLW  04
0AB2:  MOVWF  FCA
0AB4:  MOVLW  F9
0AB6:  MOVWF  FCB
....................    setup_ccp1 (ccp_pwm); 
0AB8:  BCF    F8B.2
0ABA:  MOVLW  0C
0ABC:  MOVWF  FBD
....................    set_pwm1_duty (0); 
0ABE:  CLRF   FBE
....................    br1 = 1; 
0AC0:  BSF    F83.4
....................    dir1 = 0; 
0AC2:  BCF    F82.3
.................... } 
0AC4:  RETLW  00
....................  
.................... void dc2n(INT16 x) 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
....................    dir2 = 1; 
....................    br2 = 0; 
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
....................    setup_ccp2 (ccp_pwm); 
....................    set_pwm2_duty (x); 
.................... } 
....................  
.................... void dc2t(INT16 x) 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
*
0B12:  BCF    F95.5
0B14:  BCF    F94.0
0B16:  BCF    F94.1
....................    br2 = 0; 
0B18:  BCF    F83.5
....................    dir2 = 0; 
0B1A:  BCF    F82.0
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0B1C:  MOVLW  00
0B1E:  IORLW  04
0B20:  MOVWF  FCA
0B22:  MOVLW  F9
0B24:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
0B26:  BCF    F8B.1
0B28:  MOVLW  0C
0B2A:  MOVWF  FBA
....................    set_pwm2_duty (x); 
0B2C:  MOVFF  5B,02
0B30:  MOVFF  5A,01
0B34:  RRCF   02,F
0B36:  RRCF   01,F
0B38:  RRCF   02,F
0B3A:  RRCF   01,F
0B3C:  RRCF   02,F
0B3E:  MOVFF  01,FBB
0B42:  RRCF   02,F
0B44:  RRCF   02,W
0B46:  ANDLW  30
0B48:  MOVWF  00
0B4A:  MOVF   FBA,W
0B4C:  ANDLW  CF
0B4E:  IORWF  00,W
0B50:  MOVWF  FBA
.................... } 
0B52:  GOTO   0BA6 (RETURN)
....................  
.................... void resetdc2() 
.................... { 
....................    trispwm2 = trisdir2 = trisbr2 = 0; 
0B56:  BCF    F95.5
0B58:  BCF    F94.0
0B5A:  BCF    F94.1
....................    br2 = 1; 
0B5C:  BSF    F83.5
....................    dir2 = 0; 
0B5E:  BCF    F82.0
....................    setup_timer_2 (t2_div_by_1, 249, 1); 
0B60:  MOVLW  00
0B62:  IORLW  04
0B64:  MOVWF  FCA
0B66:  MOVLW  F9
0B68:  MOVWF  FCB
....................    setup_ccp2 (ccp_pwm); 
0B6A:  BCF    F8B.1
0B6C:  MOVLW  0C
0B6E:  MOVWF  FBA
....................    set_pwm2_duty (0); 
0B70:  CLRF   FBB
.................... } 
0B72:  RETLW  00
....................  
....................  
.................... #include <qei_piddc.c> 
....................  
.................... ///// QEI MEM + DU LIEU QEI 
.................... signed int16 En2; 
.................... #define ChanelA PIN_C4 
.................... #define ChanelB PIN_C5 
.................... #INT_EXT1 
.................... void  EXT1_L2H_isr(void)  
.................... { 
.................... INTEDG1^=1; 
*
00DE:  MOVLW  00
00E0:  BTFSS  FF1.5
00E2:  MOVLW  01
00E4:  BCF    FF1.5
00E6:  BTFSC  FE8.0
00E8:  BSF    FF1.5
.................... if (INTEDG1) 
00EA:  BTFSS  FF1.5
00EC:  BRA    0104
....................    { 
....................    if (input(ChanelB)) {En2--;}  
00EE:  BTFSS  F82.5
00F0:  BRA    00FC
00F2:  MOVF   1F,W
00F4:  BTFSC  FD8.2
00F6:  DECF   20,F
00F8:  DECF   1F,F
....................    else {En2++;} 
00FA:  BRA    0102
00FC:  INCF   1F,F
00FE:  BTFSC  FD8.2
0100:  INCF   20,F
....................    } 
.................... else  
0102:  BRA    0118
....................    {  
....................    if (input(ChanelB)) {En2++;} 
0104:  BTFSS  F82.5
0106:  BRA    0110
0108:  INCF   1F,F
010A:  BTFSC  FD8.2
010C:  INCF   20,F
....................    else {En2--;} 
010E:  BRA    0118
0110:  MOVF   1F,W
0112:  BTFSC  FD8.2
0114:  DECF   20,F
0116:  DECF   1F,F
....................    } 
.................... } 
0118:  BCF    FF0.0
011A:  GOTO   0090
.................... #int_EXT2 
.................... void  EXT2_isr(void)  
.................... { 
.................... INTEDG2^=1; 
011E:  MOVLW  00
0120:  BTFSS  FF1.4
0122:  MOVLW  01
0124:  BCF    FF1.4
0126:  BTFSC  FE8.0
0128:  BSF    FF1.4
.................... if (INTEDG2) 
012A:  BTFSS  FF1.4
012C:  BRA    0144
....................    { 
....................    if (input(ChanelA)) {En2++;}  
012E:  BTFSS  F82.4
0130:  BRA    013A
0132:  INCF   1F,F
0134:  BTFSC  FD8.2
0136:  INCF   20,F
....................    else {En2--;} 
0138:  BRA    0142
013A:  MOVF   1F,W
013C:  BTFSC  FD8.2
013E:  DECF   20,F
0140:  DECF   1F,F
....................    } 
.................... else  
0142:  BRA    0158
....................    {  
....................    if (input(ChanelA)) {En2--;} 
0144:  BTFSS  F82.4
0146:  BRA    0152
0148:  MOVF   1F,W
014A:  BTFSC  FD8.2
014C:  DECF   20,F
014E:  DECF   1F,F
....................    else {En2++;} 
0150:  BRA    0158
0152:  INCF   1F,F
0154:  BTFSC  FD8.2
0156:  INCF   20,F
....................    } 
.................... } 
....................  
.................... /// PID DONG CO 1 ////////////////// 
0158:  BCF    FF0.1
015A:  GOTO   0090
.................... float kp=2, ki=0.2,kd=0.7, pid1; 
.................... signed int16 realvt1, errs1=0, err1, delta1=0, epre1=0, duty1 ; 
.................... volatile unsigned int8 Ti1,Ti2; 
.................... volatile signed int16 setvt1,setvt2; 
....................  
.................... void piddc1(signed int16 setvt1) 
....................      { 
....................      br1=0; 
*
055A:  BCF    F83.4
....................      realvt1 =  qei_get_count();  
055C:  MOVFF  F66,31
0560:  MOVFF  F67,32
....................      err1 = setvt1 - realvt1; 
0564:  MOVF   31,W
0566:  SUBWF  5F,W
0568:  MOVWF  35
056A:  MOVF   32,W
056C:  SUBWFB x60,W
056E:  MOVWF  36
....................      if(Ti1>=2) 
0570:  MOVF   3D,W
0572:  SUBLW  01
0574:  BC    05D6
....................      { 
....................        delta1 = err1-epre1; 
0576:  MOVF   39,W
0578:  SUBWF  35,W
057A:  MOVWF  37
057C:  MOVF   3A,W
057E:  SUBWFB 36,W
0580:  MOVWF  38
....................        Ti1=0; 
0582:  CLRF   3D
....................        if(delta1>-10) errs1 += err1;//(err1>-20)&&(err1<20) 
0584:  BTFSS  38.7
0586:  BRA    0598
0588:  MOVF   38,W
058A:  SUBLW  FE
058C:  BC    05A0
058E:  XORLW  FF
0590:  BNZ   0598
0592:  MOVF   37,W
0594:  SUBLW  F6
0596:  BC    05A0
0598:  MOVF   35,W
059A:  ADDWF  33,F
059C:  MOVF   36,W
059E:  ADDWFC 34,F
....................        if (errs1 > 200 ) errs1=200; 
05A0:  BTFSC  34.7
05A2:  BRA    05B4
05A4:  MOVF   34,F
05A6:  BNZ   05AE
05A8:  MOVF   33,W
05AA:  SUBLW  C8
05AC:  BC    05B4
05AE:  CLRF   34
05B0:  MOVLW  C8
05B2:  MOVWF  33
....................        if (errs1 < -200 ) errs1=-200; 
05B4:  BTFSS  34.7
05B6:  BRA    05CE
05B8:  MOVF   34,W
05BA:  SUBLW  FF
05BC:  BNC   05CE
05BE:  BNZ   05C6
05C0:  MOVF   33,W
05C2:  SUBLW  37
05C4:  BNC   05CE
05C6:  MOVLW  FF
05C8:  MOVWF  34
05CA:  MOVLW  38
05CC:  MOVWF  33
....................        epre1=err1; 
05CE:  MOVFF  36,3A
05D2:  MOVFF  35,39
....................      } 
....................    
....................      pid1 =kp*err1 + ki*errs1+kd*delta1;  
05D6:  MOVFF  36,66
05DA:  MOVFF  35,65
05DE:  RCALL  017E
05E0:  MOVFF  24,68
05E4:  MOVFF  23,67
05E8:  MOVFF  22,66
05EC:  MOVFF  21,65
05F0:  MOVFF  03,6C
05F4:  MOVFF  02,6B
05F8:  MOVFF  01,6A
05FC:  MOVFF  00,69
0600:  RCALL  01C6
0602:  MOVFF  00,61
0606:  MOVFF  01,62
060A:  MOVFF  02,63
060E:  MOVFF  03,64
0612:  MOVFF  34,66
0616:  MOVFF  33,65
061A:  RCALL  017E
061C:  MOVFF  28,68
0620:  MOVFF  27,67
0624:  MOVFF  26,66
0628:  MOVFF  25,65
062C:  MOVFF  03,6C
0630:  MOVFF  02,6B
0634:  MOVFF  01,6A
0638:  MOVFF  00,69
063C:  RCALL  01C6
063E:  BCF    FD8.1
0640:  MOVFF  64,68
0644:  MOVFF  63,67
0648:  MOVFF  62,66
064C:  MOVFF  61,65
0650:  MOVFF  03,6C
0654:  MOVFF  02,6B
0658:  MOVFF  01,6A
065C:  MOVFF  00,69
0660:  RCALL  02B8
0662:  MOVFF  00,61
0666:  MOVFF  01,62
066A:  MOVFF  02,63
066E:  MOVFF  03,64
0672:  MOVFF  38,66
0676:  MOVFF  37,65
067A:  RCALL  017E
067C:  MOVFF  2C,68
0680:  MOVFF  2B,67
0684:  MOVFF  2A,66
0688:  MOVFF  29,65
068C:  MOVFF  03,6C
0690:  MOVFF  02,6B
0694:  MOVFF  01,6A
0698:  MOVFF  00,69
069C:  RCALL  01C6
069E:  BCF    FD8.1
06A0:  MOVFF  64,68
06A4:  MOVFF  63,67
06A8:  MOVFF  62,66
06AC:  MOVFF  61,65
06B0:  MOVFF  03,6C
06B4:  MOVFF  02,6B
06B8:  MOVFF  01,6A
06BC:  MOVFF  00,69
06C0:  RCALL  02B8
06C2:  MOVFF  03,30
06C6:  MOVFF  02,2F
06CA:  MOVFF  01,2E
06CE:  MOVFF  00,2D
....................      duty1=pid1;    
06D2:  MOVFF  30,64
06D6:  MOVFF  2F,63
06DA:  MOVFF  2E,62
06DE:  MOVFF  2D,61
06E2:  RCALL  0522
06E4:  MOVFF  02,3C
06E8:  MOVFF  01,3B
....................      if (duty1 > 0)   dir1 = 0; 
06EC:  BTFSC  3C.7
06EE:  BRA    06FC
06F0:  MOVF   3C,F
06F2:  BNZ   06FA
06F4:  MOVF   3B,W
06F6:  SUBLW  00
06F8:  BTFSS  FD8.0
06FA:  BCF    F82.3
....................      if (duty1 <  0)    dir1 = 1; 
06FC:  BTFSS  3C.7
06FE:  BRA    0702
0700:  BSF    F82.3
....................      duty1= abs(duty1); 
0702:  MOVFF  3C,03
0706:  MOVF   3B,W
0708:  BTFSS  3C.7
070A:  BRA    071C
070C:  MOVLW  00
070E:  BSF    FD8.0
0710:  SUBFWB 3B,W
0712:  MOVWF  00
0714:  MOVLW  00
0716:  SUBFWB 3C,W
0718:  MOVWF  03
071A:  MOVF   00,W
071C:  MOVWF  3B
071E:  MOVFF  03,3C
....................      if(duty1>5) duty1+=200; 
0722:  BTFSC  3C.7
0724:  BRA    0738
0726:  MOVF   3C,F
0728:  BNZ   0730
072A:  MOVF   3B,W
072C:  SUBLW  05
072E:  BC    0738
0730:  MOVLW  C8
0732:  ADDWF  3B,F
0734:  MOVLW  00
0736:  ADDWFC 3C,F
....................      if(duty1>500) duty1=500; 
0738:  BTFSC  3C.7
073A:  BRA    0754
073C:  MOVF   3C,W
073E:  SUBLW  00
0740:  BC    0754
0742:  XORLW  FF
0744:  BNZ   074C
0746:  MOVF   3B,W
0748:  SUBLW  F4
074A:  BC    0754
074C:  MOVLW  01
074E:  MOVWF  3C
0750:  MOVLW  F4
0752:  MOVWF  3B
....................      set_pwm1_duty (duty1); 
0754:  MOVFF  3C,02
0758:  MOVFF  3B,01
075C:  RRCF   02,F
075E:  RRCF   01,F
0760:  RRCF   02,F
0762:  RRCF   01,F
0764:  RRCF   02,F
0766:  MOVFF  01,FBE
076A:  RRCF   02,F
076C:  RRCF   02,W
076E:  ANDLW  30
0770:  MOVWF  00
0772:  MOVF   FBD,W
0774:  ANDLW  CF
0776:  IORWF  00,W
0778:  MOVWF  FBD
....................      } 
077A:  GOTO   09C6 (RETURN)
....................       
.................... /// PID DONG CO 2 ////////////////// 
.................... signed int16 realvt2, errs2=0, err2, delta2=0, epre2=0, duty2 ; 
.................... float pid2; 
.................... void piddc2(signed int16 setvt2) 
....................      { 
....................      br2=0; 
077E:  BCF    F83.5
....................      realvt2 =  En2;  
0780:  MOVFF  20,44
0784:  MOVFF  1F,43
....................      err2 = setvt2 - realvt2; 
0788:  MOVF   43,W
078A:  SUBWF  5F,W
078C:  MOVWF  47
078E:  MOVF   44,W
0790:  SUBWFB x60,W
0792:  MOVWF  48
....................      if(Ti2>=2) 
0794:  MOVF   3E,W
0796:  SUBLW  01
0798:  BC    0808
....................      { 
....................        Ti2=0; 
079A:  CLRF   3E
....................        if((err2>-20)&&(err2<20)) errs2 += err2; 
079C:  BTFSS  48.7
079E:  BRA    07B0
07A0:  MOVF   48,W
07A2:  SUBLW  FE
07A4:  BC    07C6
07A6:  XORLW  FF
07A8:  BNZ   07B0
07AA:  MOVF   47,W
07AC:  SUBLW  EC
07AE:  BC    07C6
07B0:  BTFSC  48.7
07B2:  BRA    07BE
07B4:  MOVF   48,F
07B6:  BNZ   07C6
07B8:  MOVF   47,W
07BA:  SUBLW  13
07BC:  BNC   07C6
07BE:  MOVF   47,W
07C0:  ADDWF  45,F
07C2:  MOVF   48,W
07C4:  ADDWFC 46,F
....................        if (errs2 > 200 ) errs2=200; 
07C6:  BTFSC  46.7
07C8:  BRA    07DA
07CA:  MOVF   46,F
07CC:  BNZ   07D4
07CE:  MOVF   45,W
07D0:  SUBLW  C8
07D2:  BC    07DA
07D4:  CLRF   46
07D6:  MOVLW  C8
07D8:  MOVWF  45
....................        if (errs2 < -200 ) errs2=-200; 
07DA:  BTFSS  46.7
07DC:  BRA    07F4
07DE:  MOVF   46,W
07E0:  SUBLW  FF
07E2:  BNC   07F4
07E4:  BNZ   07EC
07E6:  MOVF   45,W
07E8:  SUBLW  37
07EA:  BNC   07F4
07EC:  MOVLW  FF
07EE:  MOVWF  46
07F0:  MOVLW  38
07F2:  MOVWF  45
....................        delta2 = err2-epre2; 
07F4:  MOVF   4B,W
07F6:  SUBWF  47,W
07F8:  MOVWF  49
07FA:  MOVF   4C,W
07FC:  SUBWFB 48,W
07FE:  MOVWF  4A
....................        epre2=err2; 
0800:  MOVFF  48,4C
0804:  MOVFF  47,4B
....................      } 
....................    
....................      pid2 =kp*err2 + ki*errs2+kd*delta2;  
0808:  MOVFF  48,66
080C:  MOVFF  47,65
0810:  RCALL  017E
0812:  MOVFF  24,68
0816:  MOVFF  23,67
081A:  MOVFF  22,66
081E:  MOVFF  21,65
0822:  MOVFF  03,6C
0826:  MOVFF  02,6B
082A:  MOVFF  01,6A
082E:  MOVFF  00,69
0832:  RCALL  01C6
0834:  MOVFF  00,61
0838:  MOVFF  01,62
083C:  MOVFF  02,63
0840:  MOVFF  03,64
0844:  MOVFF  46,66
0848:  MOVFF  45,65
084C:  RCALL  017E
084E:  MOVFF  28,68
0852:  MOVFF  27,67
0856:  MOVFF  26,66
085A:  MOVFF  25,65
085E:  MOVFF  03,6C
0862:  MOVFF  02,6B
0866:  MOVFF  01,6A
086A:  MOVFF  00,69
086E:  RCALL  01C6
0870:  BCF    FD8.1
0872:  MOVFF  64,68
0876:  MOVFF  63,67
087A:  MOVFF  62,66
087E:  MOVFF  61,65
0882:  MOVFF  03,6C
0886:  MOVFF  02,6B
088A:  MOVFF  01,6A
088E:  MOVFF  00,69
0892:  RCALL  02B8
0894:  MOVFF  00,61
0898:  MOVFF  01,62
089C:  MOVFF  02,63
08A0:  MOVFF  03,64
08A4:  MOVFF  4A,66
08A8:  MOVFF  49,65
08AC:  RCALL  017E
08AE:  MOVFF  2C,68
08B2:  MOVFF  2B,67
08B6:  MOVFF  2A,66
08BA:  MOVFF  29,65
08BE:  MOVFF  03,6C
08C2:  MOVFF  02,6B
08C6:  MOVFF  01,6A
08CA:  MOVFF  00,69
08CE:  RCALL  01C6
08D0:  BCF    FD8.1
08D2:  MOVFF  64,68
08D6:  MOVFF  63,67
08DA:  MOVFF  62,66
08DE:  MOVFF  61,65
08E2:  MOVFF  03,6C
08E6:  MOVFF  02,6B
08EA:  MOVFF  01,6A
08EE:  MOVFF  00,69
08F2:  RCALL  02B8
08F4:  MOVFF  03,52
08F8:  MOVFF  02,51
08FC:  MOVFF  01,50
0900:  MOVFF  00,4F
....................      duty2=pid2;     
0904:  MOVFF  52,64
0908:  MOVFF  51,63
090C:  MOVFF  50,62
0910:  MOVFF  4F,61
0914:  RCALL  0522
0916:  MOVFF  02,4E
091A:  MOVFF  01,4D
....................      if (duty2 > 0)   dir2 = 1; 
091E:  BTFSC  4E.7
0920:  BRA    092E
0922:  MOVF   4E,F
0924:  BNZ   092C
0926:  MOVF   4D,W
0928:  SUBLW  00
092A:  BTFSS  FD8.0
092C:  BSF    F82.0
....................      if (duty2 <  0)    dir2 = 0; 
092E:  BTFSS  4E.7
0930:  BRA    0934
0932:  BCF    F82.0
....................      duty2= abs(duty2); 
0934:  MOVFF  4E,03
0938:  MOVF   4D,W
093A:  BTFSS  4E.7
093C:  BRA    094E
093E:  MOVLW  00
0940:  BSF    FD8.0
0942:  SUBFWB 4D,W
0944:  MOVWF  00
0946:  MOVLW  00
0948:  SUBFWB 4E,W
094A:  MOVWF  03
094C:  MOVF   00,W
094E:  MOVWF  4D
0950:  MOVFF  03,4E
....................      if(duty2>5) duty2+=200; 
0954:  BTFSC  4E.7
0956:  BRA    096A
0958:  MOVF   4E,F
095A:  BNZ   0962
095C:  MOVF   4D,W
095E:  SUBLW  05
0960:  BC    096A
0962:  MOVLW  C8
0964:  ADDWF  4D,F
0966:  MOVLW  00
0968:  ADDWFC 4E,F
....................      if(duty2>400) duty2=400; 
096A:  BTFSC  4E.7
096C:  BRA    0986
096E:  MOVF   4E,W
0970:  SUBLW  00
0972:  BC    0986
0974:  XORLW  FF
0976:  BNZ   097E
0978:  MOVF   4D,W
097A:  SUBLW  90
097C:  BC    0986
097E:  MOVLW  01
0980:  MOVWF  4E
0982:  MOVLW  90
0984:  MOVWF  4D
....................      set_pwm2_duty (duty2); 
0986:  MOVFF  4E,02
098A:  MOVFF  4D,01
098E:  RRCF   02,F
0990:  RRCF   01,F
0992:  RRCF   02,F
0994:  RRCF   01,F
0996:  RRCF   02,F
0998:  MOVFF  01,FBB
099C:  RRCF   02,F
099E:  RRCF   02,W
09A0:  ANDLW  30
09A2:  MOVWF  00
09A4:  MOVF   FBA,W
09A6:  ANDLW  CF
09A8:  IORWF  00,W
09AA:  MOVWF  FBA
....................      } 
09AC:  GOTO   09D0 (RETURN)
....................       
....................  
....................  
.................... ///// CHUONG TRINH QUET PHIM 
.................... volatile int16 dem=0, chonct=0; 
....................  
.................... ///// NGAT TIMER0 
.................... char demservo, xungservo; 
.................... #int_timer0 
.................... void ngat_timer0(void)  
....................    { 
....................    set_timer0(5); 
*
015E:  CLRF   FD7
0160:  MOVLW  05
0162:  MOVWF  FD6
....................    demservo++; 
0164:  INCF   57,F
....................    if (demservo>=200) 
0166:  MOVF   57,W
0168:  SUBLW  C7
016A:  BC    0170
....................       { 
....................       demservo=0; 
016C:  CLRF   57
....................       output_high(pin_d2); 
016E:  BSF    F8C.2
....................       } 
....................    if (demservo >=xungservo) output_low(pin_d2); 
0170:  MOVF   58,W
0172:  SUBWF  57,W
0174:  BTFSC  FD8.0
0176:  BCF    F8C.2
....................        
....................    } 
....................       
.................... ///// NGAT TIMER1 PID 
0178:  BCF    FF2.2
017A:  GOTO   0090
.................... #int_timer1 
.................... void ngat_timer1(void)  
....................    { 
....................       set_timer1(59286); 
*
09B0:  MOVLW  E7
09B2:  MOVWF  FCF
09B4:  MOVLW  96
09B6:  MOVWF  FCE
....................       Ti1++; 
09B8:  INCF   3D,F
....................       Ti2++; 
09BA:  INCF   3E,F
....................       piddc1(setvt1); 
09BC:  MOVFF  40,60
09C0:  MOVFF  3F,5F
09C4:  BRA    055A
....................       piddc2(setvt2); 
09C6:  MOVFF  42,60
09CA:  MOVFF  41,5F
09CE:  BRA    077E
....................    } 
....................     
.................... ///// NGAT TIMER5 QUET PHIM  
09D0:  BCF    F9E.0
09D2:  GOTO   0090
.................... #int_timer5 
.................... void ngat_timer5(void)  
....................    { 
....................       set_timer5(59286); 
09D6:  MOVLW  E7
09D8:  MOVWF  F88
09DA:  MOVLW  96
09DC:  MOVWF  F87
....................       dem++; 
09DE:  INCF   53,F
09E0:  BTFSC  FD8.2
09E2:  INCF   54,F
....................    }    
....................  
.................... ///// KHAI BAO NHIEM VU 
.................... #include <resetall.c> 
.................... ///// RESETALL 
....................  
09E4:  BCF    FA4.0
09E6:  GOTO   0090
.................... void resetall() 
.................... { 
.................... disable_interrupts(int_timer1); 
*
0B74:  BCF    F9D.0
.................... disable_interrupts(int_timer5); 
0B76:  BCF    FA3.0
....................  
.................... Ti1=0; 
0B78:  CLRF   3D
.................... Ti2=0; 
0B7A:  CLRF   3E
.................... while (ctc1==1) { dc1t(370); } 
0B7C:  BTFSS  F81.0
0B7E:  BRA    0B8C
0B80:  MOVLW  01
0B82:  MOVWF  5B
0B84:  MOVLW  72
0B86:  MOVWF  5A
0B88:  BRA    0A64
0B8A:  BRA    0B7C
.................... resetdc1(); 
0B8C:  RCALL  0AA8
.................... beep(1,100); 
0B8E:  MOVLW  01
0B90:  MOVWF  5A
0B92:  MOVLW  64
0B94:  MOVWF  5B
0B96:  RCALL  0AEE
.................... while (ctc2==1) { dc2t(370); } 
0B98:  BTFSS  F81.2
0B9A:  BRA    0BA8
0B9C:  MOVLW  01
0B9E:  MOVWF  5B
0BA0:  MOVLW  72
0BA2:  MOVWF  5A
0BA4:  BRA    0B12
0BA6:  BRA    0B98
.................... resetdc2(); 
0BA8:  RCALL  0B56
.................... beep(1,100); 
0BAA:  MOVLW  01
0BAC:  MOVWF  5A
0BAE:  MOVLW  64
0BB0:  MOVWF  5B
0BB2:  RCALL  0AEE
.................... qei_set_count(0); 
0BB4:  CLRF   F67
0BB6:  CLRF   F66
.................... En2=0; 
0BB8:  CLRF   20
0BBA:  CLRF   1F
.................... setvt1=0; 
0BBC:  CLRF   40
0BBE:  CLRF   3F
.................... setvt2=0; 
0BC0:  CLRF   42
0BC2:  CLRF   41
.................... vantay1=vantay2=vancanh1=vanleo=vancanh2=vanduoi=1; 
0BC4:  BSF    F80.5
0BC6:  BSF    F80.0
0BC8:  BSF    F80.1
0BCA:  BSF    F80.2
0BCC:  BSF    F84.0
0BCE:  BSF    F84.1
....................  
.................... enable_interrupts(int_timer5); 
0BD0:  BSF    FA3.0
.................... clear_interrupt(int_timer5); 
0BD2:  BCF    FA4.0
.................... set_timer5(59286); 
0BD4:  MOVLW  E7
0BD6:  MOVWF  F88
0BD8:  MOVLW  96
0BDA:  MOVWF  F87
.................... } 
0BDC:  RETLW  00
....................  
....................  
.................... #include <nhiemvu2.c> 
....................  
.................... ///// NHIEM VU 2 
....................  
.................... void nhiemvu2() 
.................... { 
.................... disable_interrupts(int_timer1); 
0BDE:  BCF    F9D.0
.................... disable_interrupts(int_timer5); 
0BE0:  BCF    FA3.0
....................  
.................... beep(2,100); 
0BE2:  MOVLW  02
0BE4:  MOVWF  5A
0BE6:  MOVLW  64
0BE8:  MOVWF  5B
0BEA:  RCALL  0AEE
.................... chonct=0; 
0BEC:  CLRF   56
0BEE:  CLRF   55
.................... while(cten==1){delay_ms(50);} 
0BF0:  BTFSS  F81.6
0BF2:  BRA    0BFC
0BF4:  MOVLW  32
0BF6:  MOVWF  5E
0BF8:  RCALL  0AC6
0BFA:  BRA    0BF0
.................... if(cten==0) 
0BFC:  BTFSC  F81.6
0BFE:  BRA    0C0C
....................    { 
....................    delay_ms(20); 
0C00:  MOVLW  14
0C02:  MOVWF  5E
0C04:  RCALL  0AC6
....................    if(cten==0) 
0C06:  BTFSC  F81.6
0C08:  BRA    0C0C
....................       { 
....................       vanduoi=0; 
0C0A:  BCF    F80.5
....................       } 
....................    } 
.................... while(cten==0) {delay_ms(50);} 
0C0C:  BTFSC  F81.6
0C0E:  BRA    0C18
0C10:  MOVLW  32
0C12:  MOVWF  5E
0C14:  RCALL  0AC6
0C16:  BRA    0C0C
....................     
.................... enable_interrupts(int_timer5); 
0C18:  BSF    FA3.0
.................... clear_interrupt(int_timer5); 
0C1A:  BCF    FA4.0
.................... set_timer5(59286); 
0C1C:  MOVLW  E7
0C1E:  MOVWF  F88
0C20:  MOVLW  96
0C22:  MOVWF  F87
.................... } 
0C24:  GOTO   0DE0 (RETURN)
....................  
.................... #include <nhiemvu3.c> 
....................  
.................... ///// NHIEM VU 3 
....................  
.................... void nhiemvu3() 
.................... { 
.................... disable_interrupts(int_timer5); 
0C28:  BCF    FA3.0
.................... enable_interrupts(int_timer1); 
0C2A:  BSF    F9D.0
....................  
.................... beep(3,100); 
0C2C:  MOVLW  03
0C2E:  MOVWF  5A
0C30:  MOVLW  64
0C32:  MOVWF  5B
0C34:  RCALL  0AEE
.................... chonct=0; 
0C36:  CLRF   56
0C38:  CLRF   55
.................... qei_set_count(0); 
0C3A:  CLRF   F67
0C3C:  CLRF   F66
.................... En2=0; 
0C3E:  CLRF   20
0C40:  CLRF   1F
.................... Ti1=0; 
0C42:  CLRF   3D
.................... Ti2=0; 
0C44:  CLRF   3E
....................  
.................... enable_interrupts(int_timer5); 
0C46:  BSF    FA3.0
.................... clear_interrupt(int_timer5); 
0C48:  BCF    FA4.0
.................... set_timer5(59286); 
0C4A:  MOVLW  E7
0C4C:  MOVWF  F88
0C4E:  MOVLW  96
0C50:  MOVWF  F87
.................... } 
0C52:  GOTO   0DEC (RETURN)
....................  
.................... #include <nhiemvu4.c> 
....................  
.................... ///// NHIEM VU 4 
....................  
.................... void nhiemvu4() 
.................... { 
.................... disable_interrupts(int_timer1); 
0C56:  BCF    F9D.0
.................... disable_interrupts(int_timer5); 
0C58:  BCF    FA3.0
.................... beep(4,100); 
0C5A:  MOVLW  04
0C5C:  MOVWF  5A
0C5E:  MOVLW  64
0C60:  MOVWF  5B
0C62:  RCALL  0AEE
.................... resetdc1(); 
0C64:  RCALL  0AA8
.................... resetdc2(); 
0C66:  RCALL  0B56
.................... chonct=0; 
0C68:  CLRF   56
0C6A:  CLRF   55
....................  
.................... while (cten==1) {delay_ms(50);}; 
0C6C:  BTFSS  F81.6
0C6E:  BRA    0C78
0C70:  MOVLW  32
0C72:  MOVWF  5E
0C74:  RCALL  0AC6
0C76:  BRA    0C6C
.................... vanleo=0; 
0C78:  BCF    F80.1
.................... vanduoi=0; 
0C7A:  BCF    F80.5
.................... delay_ms(2000); 
0C7C:  MOVLW  08
0C7E:  MOVWF  5A
0C80:  MOVLW  FA
0C82:  MOVWF  5E
0C84:  RCALL  0AC6
0C86:  DECFSZ 5A,F
0C88:  BRA    0C80
.................... vanleo=1; 
0C8A:  BSF    F80.1
.................... delay_ms(2000); 
0C8C:  MOVLW  08
0C8E:  MOVWF  5A
0C90:  MOVLW  FA
0C92:  MOVWF  5E
0C94:  RCALL  0AC6
0C96:  DECFSZ 5A,F
0C98:  BRA    0C90
.................... vanleo=0; 
0C9A:  BCF    F80.1
.................... delay_ms(2000); 
0C9C:  MOVLW  08
0C9E:  MOVWF  5A
0CA0:  MOVLW  FA
0CA2:  MOVWF  5E
0CA4:  RCALL  0AC6
0CA6:  DECFSZ 5A,F
0CA8:  BRA    0CA0
.................... vanleo=1;  
0CAA:  BSF    F80.1
.................... delay_ms(2000); 
0CAC:  MOVLW  08
0CAE:  MOVWF  5A
0CB0:  MOVLW  FA
0CB2:  MOVWF  5E
0CB4:  RCALL  0AC6
0CB6:  DECFSZ 5A,F
0CB8:  BRA    0CB0
.................... vanleo=0; 
0CBA:  BCF    F80.1
.................... delay_ms(2000); 
0CBC:  MOVLW  08
0CBE:  MOVWF  5A
0CC0:  MOVLW  FA
0CC2:  MOVWF  5E
0CC4:  RCALL  0AC6
0CC6:  DECFSZ 5A,F
0CC8:  BRA    0CC0
.................... vanleo=1; 
0CCA:  BSF    F80.1
.................... delay_ms(2000); 
0CCC:  MOVLW  08
0CCE:  MOVWF  5A
0CD0:  MOVLW  FA
0CD2:  MOVWF  5E
0CD4:  RCALL  0AC6
0CD6:  DECFSZ 5A,F
0CD8:  BRA    0CD0
.................... vanleo=0; 
0CDA:  BCF    F80.1
.................... delay_ms(2000); 
0CDC:  MOVLW  08
0CDE:  MOVWF  5A
0CE0:  MOVLW  FA
0CE2:  MOVWF  5E
0CE4:  RCALL  0AC6
0CE6:  DECFSZ 5A,F
0CE8:  BRA    0CE0
.................... vanleo=1; 
0CEA:  BSF    F80.1
.................... delay_ms(2000); 
0CEC:  MOVLW  08
0CEE:  MOVWF  5A
0CF0:  MOVLW  FA
0CF2:  MOVWF  5E
0CF4:  RCALL  0AC6
0CF6:  DECFSZ 5A,F
0CF8:  BRA    0CF0
.................... vanleo=0; 
0CFA:  BCF    F80.1
.................... delay_ms(2000); 
0CFC:  MOVLW  08
0CFE:  MOVWF  5A
0D00:  MOVLW  FA
0D02:  MOVWF  5E
0D04:  RCALL  0AC6
0D06:  DECFSZ 5A,F
0D08:  BRA    0D00
.................... vanleo=1; 
0D0A:  BSF    F80.1
.................... delay_ms(2000); 
0D0C:  MOVLW  08
0D0E:  MOVWF  5A
0D10:  MOVLW  FA
0D12:  MOVWF  5E
0D14:  RCALL  0AC6
0D16:  DECFSZ 5A,F
0D18:  BRA    0D10
....................  
.................... enable_interrupts(int_timer0); 
0D1A:  BSF    FF2.5
.................... clear_interrupt(int_timer0); 
0D1C:  BCF    FF2.2
....................  
.................... xungservo=10; 
0D1E:  MOVLW  0A
0D20:  MOVWF  58
.................... } 
0D22:  GOTO   0DF8 (RETURN)
....................  
....................  
.................... ///// MAIN ///// 
.................... int8 i=0; 
....................  
.................... void main() 
.................... { 
0D26:  CLRF   FF8
0D28:  BCF    FD0.7
0D2A:  BSF    07.7
0D2C:  CLRF   FEA
0D2E:  CLRF   FE9
0D30:  CLRF   24
0D32:  CLRF   23
0D34:  CLRF   22
0D36:  MOVLW  80
0D38:  MOVWF  21
0D3A:  MOVLW  CD
0D3C:  MOVWF  28
0D3E:  MOVLW  CC
0D40:  MOVWF  27
0D42:  MOVLW  4C
0D44:  MOVWF  26
0D46:  MOVLW  7C
0D48:  MOVWF  25
0D4A:  MOVLW  33
0D4C:  MOVWF  2C
0D4E:  MOVWF  2B
0D50:  MOVWF  2A
0D52:  MOVLW  7E
0D54:  MOVWF  29
0D56:  CLRF   34
0D58:  CLRF   33
0D5A:  CLRF   38
0D5C:  CLRF   37
0D5E:  CLRF   3A
0D60:  CLRF   39
0D62:  CLRF   46
0D64:  CLRF   45
0D66:  CLRF   4A
0D68:  CLRF   49
0D6A:  CLRF   4C
0D6C:  CLRF   4B
0D6E:  CLRF   54
0D70:  CLRF   53
0D72:  CLRF   56
0D74:  CLRF   55
0D76:  CLRF   59
0D78:  BCF    FB9.0
0D7A:  BCF    FC1.6
0D7C:  BCF    FC1.7
0D7E:  MOVLW  00
0D80:  MOVWF  FB8
0D82:  CLRF   19
0D84:  CLRF   1A
....................    khoidong();  
0D86:  BRA    09EA
....................    resetall(); 
0D88:  RCALL  0B74
....................    chonct=0; 
0D8A:  CLRF   56
0D8C:  CLRF   55
....................    beep(1,100);  
0D8E:  MOVLW  01
0D90:  MOVWF  5A
0D92:  MOVLW  64
0D94:  MOVWF  5B
0D96:  RCALL  0AEE
....................     
....................     
.................... while(true) 
....................    { 
....................     if (ctsel==0) 
0D98:  BTFSC  F81.7
0D9A:  BRA    0E18
....................       { 
....................       dem=0; 
0D9C:  CLRF   54
0D9E:  CLRF   53
....................       i=0; 
0DA0:  CLRF   59
....................       beep(1,100); 
0DA2:  MOVLW  01
0DA4:  MOVWF  5A
0DA6:  MOVLW  64
0DA8:  MOVWF  5B
0DAA:  RCALL  0AEE
....................       while (i==0) 
....................          { 
0DAC:  MOVF   59,F
0DAE:  BNZ   0DC0
....................          if (ctsel==1) {delay_ms(50); i=1;} 
0DB0:  BTFSS  F81.7
0DB2:  BRA    0DBE
0DB4:  MOVLW  32
0DB6:  MOVWF  5E
0DB8:  RCALL  0AC6
0DBA:  MOVLW  01
0DBC:  MOVWF  59
....................          } 
0DBE:  BRA    0DAC
....................       if (dem>50) 
0DC0:  MOVF   54,F
0DC2:  BNZ   0DCA
0DC4:  MOVF   53,W
0DC6:  SUBLW  32
0DC8:  BC    0DFA
....................          { 
....................          if (chonct==1) resetall(); 
0DCA:  DECFSZ 55,W
0DCC:  BRA    0DD4
0DCE:  MOVF   56,F
0DD0:  BNZ   0DD4
0DD2:  RCALL  0B74
....................          if (chonct==2) nhiemvu2(); 
0DD4:  MOVF   55,W
0DD6:  SUBLW  02
0DD8:  BNZ   0DE0
0DDA:  MOVF   56,F
0DDC:  BNZ   0DE0
0DDE:  BRA    0BDE
....................          if (chonct==3) nhiemvu3(); 
0DE0:  MOVF   55,W
0DE2:  SUBLW  03
0DE4:  BNZ   0DEC
0DE6:  MOVF   56,F
0DE8:  BNZ   0DEC
0DEA:  BRA    0C28
....................          if (chonct==4) nhiemvu4(); 
0DEC:  MOVF   55,W
0DEE:  SUBLW  04
0DF0:  BNZ   0DF8
0DF2:  MOVF   56,F
0DF4:  BNZ   0DF8
0DF6:  BRA    0C56
....................          } 
....................       else  
0DF8:  BRA    0E18
....................          { 
....................          chonct++; 
0DFA:  INCF   55,F
0DFC:  BTFSC  FD8.2
0DFE:  INCF   56,F
....................          if (chonct>4) {chonct=0; beep(10,100);} 
0E00:  MOVF   56,F
0E02:  BNZ   0E0A
0E04:  MOVF   55,W
0E06:  SUBLW  04
0E08:  BC    0E18
0E0A:  CLRF   56
0E0C:  CLRF   55
0E0E:  MOVLW  0A
0E10:  MOVWF  5A
0E12:  MOVLW  64
0E14:  MOVWF  5B
0E16:  RCALL  0AEE
....................          } 
....................       } 
....................    }    
0E18:  BRA    0D98
.................... }  
....................  
....................  
....................  
0E1A:  SLEEP 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 3E0C   PUT NOBROWNOUT BORRES NOWDT WDT32768 NOWINEN
   Word  3: 9D3C   NOPWMPIN LPOL_HIGH HPOL_HIGH T1LOWPOWER FLTAC1 SSP_RC PWM4B5 EXCLKC3 MCLR
   Word  4: 0081   STVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
